/**
 * @file tiny_matrix.cpp
 * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)
 * @brief This file is the source file for the submodule matrix (advanced matrix operations) of the tiny_math middleware.
 * @version 1.0
 * @date 2025-04-17
 * @copyright Copyright (c) 2025
 *
 */

/* DEPENDENCIES */
// TinyMath
#include "tiny_matrix.hpp"

// Standard Libraries
#include <cstring>
#include <iostream>
#include <stdexcept>
#include <string.h>
#include <math.h>
#include <cmath>
#include <inttypes.h>
#include <iomanip>

// Namespace
using std::endl;
using std::istream;
using std::ostream;

/* LIBRARIE CONTENTS */
namespace tiny
{
    Mat::Rect::Rect(int x, int y, int width, int height)
        : x(x), y(y), width(width), height(height) {}

    void Mat::Rect::resizeRect(int x, int y, int width, int height)
    {
        this->x = x;
        this->y = y;
        this->width = width;
        this->height = height;
    }

    int Mat::Rect::areaRect(void) const
    {
        return width * height;
    }

    // Constructor with initialization to 0
    Mat::Mat(int rows, int cols)
        : rows(rows), cols(cols), stride(cols), padding(0), length(rows * cols),
          data(nullptr), ext_buff(false), sub_matrix(false)
    {
        allocate();
        std::memset(this->data, 0, this->length * sizeof(float));
    }

    // Constructor with external buffer
    Mat::Mat(float *data, int rows, int cols)
        : rows(rows), cols(cols), stride(cols), padding(0), length(rows * cols),
          data(data), ext_buff(true), sub_matrix(false) {}

    // Constructor with external buffer and stride
    Mat::Mat(float *data, int rows, int cols, int stride)
        : rows(rows), cols(cols), stride(stride), padding(stride - cols), length(rows * cols),
          data(data), ext_buff(true), sub_matrix(false) {}

    // Default constructor
    Mat::Mat()
        : rows(1), cols(1), stride(1), padding(0), length(1),
          data(nullptr), ext_buff(false), sub_matrix(false)
    {
        allocate();
        std::memset(this->data, 0, this->length * sizeof(float));
    }

    // Destructor
    Mat::~Mat()
    {
        if (!this->ext_buff && this->data)
        {
            delete[] this->data;
        }
    }

    // Memory allocation for the matrix
    void Mat::allocate()
    {
        this->ext_buff = false;
        this->length = this->rows * this->cols;
        this->data = new float[this->length];
    }

    // Copy constructor - if it is a sub-matrix, only the header is copied, else both header and data are copied
    Mat::Mat(const Mat &m)
        : rows(m.rows), cols(m.cols), stride(m.stride), padding(m.padding), length(m.length),
          data(nullptr), ext_buff(false), sub_matrix(m.sub_matrix)
    {
        if (m.sub_matrix)
        {
            this->data = m.data;
            this->ext_buff = true;
        }
        else
        {
            allocate();
            std::memcpy(this->data, m.data, this->length * sizeof(float));
        }
    }

    // Get a sub-matrix (ROI) from the original matrix
    Mat Mat::getROI(int startRow, int startCol, int roiRows, int roiCols, int stride)
    {
        Mat result(this->data, roiRows, roiCols, 0); // this is an illegal matrix, for illegal access

        if ((startRow + roiRows) > this->rows)
        {
            return result;
        }
        if ((startCol + roiCols) > this->cols)
        {
            return result;
        }

        const int ptr_move = startRow * this->cols + startCol;
        float *new_data_ptr = this->data + ptr_move;

        result.data = new_data_ptr;
        result.stride = stride;
        result.padding = result.stride - result.cols;
        return result;
    }

    // Get a sub-matrix (ROI) from the original matrix, compact version
    Mat Mat::getROI(int startRow, int startCol, int roiRows, int roiCols)
    {
        return (getROI(startRow, startCol, roiRows, roiCols, this->cols));
    }

    // Get a sub-matrix (ROI) from the original matrix using Rect structure
    Mat Mat::getROI(const Mat::Rect &rect)
    {
        return (getROI(rect.y, rect.x, rect.height, rect.width, this->cols));
    }

    // Make copy of matrix.
    void Mat::Copy(const Mat &src, int row_pos, int col_pos)
    {
        if ((row_pos + src.rows) > this->rows)
        {
            return;
        }
        if ((col_pos + src.cols) > this->cols)
        {
            return;
        }

        for (size_t r = 0; r < src.rows; r++)
        {
            memcpy(&this->data[(r + row_pos) * this->stride + col_pos], &src.data[r * src.cols], src.cols * sizeof(float));
        }
    }

    // Copy header of matrix
    void Mat::CopyHead(const Mat &src)
    {
        if (!this->ext_buff)
        {
            delete[] this->data;
        }
        this->rows = src.rows;
        this->cols = src.cols;
        this->length = src.length;
        this->padding = src.padding;
        this->stride = src.stride;
        this->data = src.data;
        this->ext_buff = src.ext_buff;
        this->sub_matrix = src.sub_matrix;
    }

    // Print matrix header information
    void Mat::PrintHead(void)
    {
        std::cout << "rows     " << this->rows << std::endl;
        std::cout << "cols     " << this->cols << std::endl;
        std::cout << "lenght   " << this->length << std::endl;
        std::cout << "data     " << this->data << std::endl;
        std::cout << "ext_buff " << this->ext_buff << std::endl;
        std::cout << "sub_mat  " << this->sub_matrix << std::endl;
        std::cout << "stride   " << this->stride << std::endl;
        std::cout << "padding  " << this->padding << std::endl
                  << std::endl;
    }

    // Print Matrix
    void Mat::PrintMatrix(bool show_padding, const std::string &label)
    {
        std::cout << label << "\n";
        std::cout << "rows: " << rows << ", cols: " << cols << "\n";
        std::cout << "stride: " << stride << ", length: " << length << "\n";
        std::cout << "ext_buff: " << ext_buff << ", sub_matrix: " << sub_matrix << "\n";
        std::cout << "data pointer: " << static_cast<void *>(data) << "\n";
        std::cout << "data (row-major):\n";

        int display_cols = show_padding ? stride : cols;

        for (int i = 0; i < rows; ++i)
        {
            for (int j = 0; j < display_cols; ++j)
            {
                std::cout << std::setw(8) << data[i * stride + j] << " ";
            }
            std::cout << "\n";
        }
        std::cout << std::endl;
    }

    // Get a sub-matrix (ROI) from the original matrix
    Mat Mat::Get(int row_start, int row_size, int col_start, int col_size)
    {
        Mat result(row_size, col_size);

        if ((row_start + row_size) > this->rows)
        {
            return result;
        }
        if ((col_start + col_size) > this->cols)
        {
            return result;
        }

        for (size_t r = 0; r < result.rows; r++)
        {
            memcpy(&result.data[r * result.cols], &this->data[(r + row_start) * this->stride + col_start], result.cols * sizeof(float));
        }
        return result;
    }

    // Get a sub-matrix (ROI) from the original matrix using Rect structure
    Mat Mat::Get(const Mat::Rect &rect)
    {
        return (Get(rect.y, rect.height, rect.x, rect.width));
    }

    // Copy operator
    Mat &Mat::operator=(const Mat &m)
    {
        if (this == &m)
        {
            return *this;
        }

        // matrix dimensions not equal, note the dimension will be changed! (for non-sub-matrix)
        if (this->rows != m.rows || this->cols != m.cols)
        {
            // left operand is a sub-matrix - error
            if (this->sub_matrix)
            {
                std::cerr << "operator = Error for sub-matrices: operands matrices dimensions " << this->rows << "x" << this->cols << " and " << m.rows << "x" << m.cols << " do not match" << std::endl;
                return *this;
            }
            if (!this->ext_buff)
            {
                delete[] this->data;
            }
            this->ext_buff = false;
            this->rows = m.rows;
            this->cols = m.cols;
            this->stride = this->cols;
            this->padding = 0;
            this->sub_matrix = false;
            allocate();
        }

        for (int row = 0; row < this->rows; row++)
        {
            memcpy(this->data + (row * this->stride), m.data + (row * m.stride), this->cols * sizeof(float));
        }
        return *this;
    }

    Mat &Mat::operator+=(const Mat &m)
    {
        if ((this->rows != m.rows) || (this->cols != m.cols))
        {
            std::cerr << "operator += Error: matrices do not have equal dimensions" << std::endl;
            return *this;
        }

        if (this->sub_matrix || m.sub_matrix)
        {
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_add_f32(this->data, m.data, this->data, this->rows, this->cols, this->padding, m.padding, this->padding, 1, 1, 1);
#else
            tiny_mat_add_f32(this->data, m.data, this->data, this->rows, this->cols, this->padding, m.padding, this->padding, 1, 1, 1);
#endif
        }
        else
        {
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dsps_add_f32(this->data, m.data, this->data, this->length, 1, 1, 1);
#else
            tiny_vec_add_f32(this->data, m.data, this->data, this->length, 1, 1, 1);
#endif
        }
        return *this;
    }

    Mat &Mat::operator+=(float C)
    {
        if (this->sub_matrix)
        {
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_addc_f32(this->data, this->data, C, this->rows, this->cols, this->padding, this->padding, 1, 1);
#else
            tiny_mat_addc_f32(this->data, this->data, C, this->rows, this->cols, this->padding, this->padding, 1, 1);
#endif
        }
        else
        {
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dsps_addc_f32_ansi(this->data, this->data, this->length, C, 1, 1);
#else
            tiny_vec_addc_f32(this->data, this->data, this->length, C, 1, 1);
#endif
        }
        return *this;
    }

    Mat &Mat::operator-=(const Mat &m)
    {
        if ((this->rows != m.rows) || (this->cols != m.cols))
        {
            std::cerr << "operator -= Error: matrices do not have equal dimensions" << std::endl;
            return *this;
        }

        if (this->sub_matrix || m.sub_matrix)
        {
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_sub_f32(this->data, m.data, this->data, this->rows, this->cols, this->padding, m.padding, this->padding, 1, 1, 1);
#else
            tiny_mat_sub_f32(this->data, m.data, this->data, this->rows, this->cols, this->padding, m.padding, this->padding, 1, 1, 1);
#endif
        }
        else
        {
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dsps_sub_f32(this->data, m.data, this->data, this->length, 1, 1, 1);
#else
            tiny_vec_sub_f32(this->data, m.data, this->data, this->length, 1, 1, 1);
#endif
        }
        return *this;
    }

    Mat &Mat::operator-=(float C)
    {
        if (this->sub_matrix)
        {
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_addc_f32(this->data, this->data, -C, this->rows, this->cols, this->padding, this->padding, 1, 1);
#else
            tiny_mat_addc_f32(this->data, this->data, -C, this->rows, this->cols, this->padding, this->padding, 1, 1);
#endif
        }
        else
        {
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dsps_addc_f32_ansi(this->data, this->data, this->length, -C, 1, 1);
#else
            tiny_vec_addc_f32(this->data, this->data, this->length, -C, 1, 1);
#endif
        }
        return *this;
    }

    Mat &Mat::operator*=(const Mat &m)
    {
        if (this->cols != m.rows)
        {
            std::cerr << "operator *= Error: matrices do not have equal dimensions" << std::endl;
            return *this;
        }

        if (this->sub_matrix || m.sub_matrix)
        {
            Mat temp = this->Get(0, this->rows, 0, this->cols);
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_mult_ex_f32(temp.data, m.data, this->data, temp.rows, temp.cols, m.cols, temp.padding, m.padding, this->padding);
#else
            tiny_mat_mult_ex_f32(temp.data, m.data, this->data, temp.rows, temp.cols, m.cols, temp.padding, m.padding, this->padding);
#endif
        }
        else
        {
            Mat temp = *this;
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_mult_f32(temp.data, m.data, this->data, temp.rows, temp.cols, m.cols);
#else
            tiny_mat_mult_f32(temp.data, m.data, this->data, temp.rows, temp.cols, m.cols);
#endif
        }
        return (*this);
    }

    Mat &Mat::operator*=(float num)
    {
        if (this->sub_matrix)
        {
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_mulc_f32(this->data, this->data, num, this->rows, this->cols, this->padding, this->padding, 1, 1);
#else
            tiny_mat_mulc_f32(this->data, this->data, num, this->rows, this->cols, this->padding, this->padding, 1, 1);
#endif
        }
        else
        {
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dsps_mulc_f32_ansi(this->data, this->data, this->length, num, 1, 1);
#else
            tiny_vec_mulc_f32(this->data, this->data, this->length, num, 1, 1);
#endif
        }
        return *this;
    }

    Mat &Mat::operator/=(const Mat &B) // note this is element-wise division
    {
        // dimension check
        if ((this->rows != B.rows) || (this->cols != B.cols))
        {
            std::cerr << "operator /= Error: matrices do not have equal dimensions" << std::endl;
            return *this;
        }

        // check for zero division
        for (int row = 0; row < B.rows; row++)
        {
            for (int col = 0; col < B.cols; col++)
            {
                if (B(row, col) == 0)
                {
                    std::cerr << "operator /= Error: division by zero" << std::endl;
                    return *this;
                }
            }
        }

        for (int row = 0; row < this->rows; row++)
        {
            for (int col = 0; col < this->cols; col++)
            {
                (*this)(row, col) = (*this)(row, col) / B(row, col); // note this is element-wise division
            }
        }
        return (*this);
    }

    Mat &Mat::operator/=(float num)
    {
        if (num == 0)
        {
            std::cerr << "operator /= Error: division by zero" << std::endl;
            return *this;
        }

        if (this->sub_matrix)
        {
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_mulc_f32(this->data, this->data, 1 / num, this->rows, this->cols, this->padding, this->padding, 1, 1);
#else
            tiny_mat_multc_f32(this->data, this->data, 1 / num, this->rows, this->cols, this->padding, this->padding, 1, 1);
#endif
        }
        else
        {
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dsps_mulc_f32_ansi(this->data, this->data, this->length, 1 / num, 1, 1);
#else
            tiny_vec_mulc_f32(this->data, this->data, this->length, 1 / num, 1, 1);
#endif
        }
        return *this;
    }

    Mat Mat::expHelper(const Mat &m, int num)
    {
        if (num == 0)
        {
            return Mat::eye(m.rows);
        }
        else if (num == 1)
        {
            return m;
        }
        else if (num % 2 == 0)
        { // num is even
            return expHelper(m * m, num / 2);
        }
        else
        { // num is odd
            return m * expHelper(m * m, (num - 1) / 2);
        }
    }

    Mat Mat::operator^(int num)
    {
        Mat temp(*this);
        return expHelper(temp, num);
    }

    void Mat::swapRows(int r1, int r2)
    {
        if ((this->rows <= r1) || (this->rows <= r2))
        {
            std::cerr << "swapRows Error: row " << r1 << " or " << r2 << " out of matrix row " << this->rows << " range" << std::endl;
        }
        else
        {
            for (int i = 0; i < this->cols; i++)
            {
                float temp = this->data[r1 * this->stride + i];
                this->data[r1 * this->stride + i] = this->data[r2 * this->stride + i];
                this->data[r2 * this->stride + i] = temp;
            }
        }
    }

    Mat Mat::t()
    {
        Mat ret(this->cols, this->rows);
        for (int i = 0; i < this->rows; ++i)
        {
            for (int j = 0; j < this->cols; ++j)
            {
                ret(j, i) = this->data[i * this->stride + j];
            }
        }
        return ret;
    }

    Mat Mat::eye(int size)
    {
        Mat temp(size, size);
        for (int i = 0; i < temp.rows; ++i)
        {
            for (int j = 0; j < temp.cols; ++j)
            {
                if (i == j)
                {
                    temp(i, j) = 1;
                }
                else
                {
                    temp(i, j) = 0;
                }
            }
        }
        return temp;
    }

    Mat Mat::ones(int size)
    {
        return (ones(size, size));
    }

    Mat Mat::ones(int rows, int cols)
    {
        Mat temp(rows, cols);
        for (int row = 0; row < temp.rows; ++row)
        {
            for (int col = 0; col < temp.cols; ++col)
            {
                temp(row, col) = 1;
            }
        }
        return temp;
    }

    void Mat::clear()
    {
        for (int row = 0; row < this->rows; row++)
        {
            memset(this->data + (row * this->stride), 0, this->cols * sizeof(float));
        }
    }

    // Duplicate to Get method
    Mat Mat::block(int startRow, int startCol, int blockRows, int blockCols)
    {
        Mat result(blockRows, blockCols);
        for (int i = 0; i < blockRows; ++i)
        {
            for (int j = 0; j < blockCols; ++j)
            {
                result(i, j) = (*this)(startRow + i, startCol + j);
            }
        }
        return result;
    }

    void Mat::normalize(void) // normalize the matrix
    {
        float sqr_norm = 0;
        for (int i = 0; i < this->rows; ++i)
        {
            for (int j = 0; j < this->cols; ++j)
            {
                sqr_norm += (*this)(i, j) * (*this)(i, j);
            }
        }
        sqr_norm = 1 / sqrtf(sqr_norm);
        *this *= sqr_norm;
    }

    float Mat::norm(void) // calculate matrix norm
    {
        float sqr_norm = 0;
        for (int i = 0; i < this->rows; ++i)
        {
            for (int j = 0; j < this->cols; ++j)
            {
                sqr_norm += (*this)(i, j) * (*this)(i, j);
            }
        }
        sqr_norm = sqrtf(sqr_norm);
        return sqr_norm;
    }

    Mat Mat::solve(Mat A, Mat b)
    {
        // Gaussian elimination
        for (int i = 0; i < A.rows; ++i)
        {
            if (A(i, i) == 0)
            {
                // pivot 0 - error
                std::cerr << "Error: the coefficient matrix has 0 as a pivot. Please fix the input and try again." << std::endl;
                Mat err_result(0, 0);
                return err_result;
            }
            float a_ii = 1 / A(i, i);
            for (int j = i + 1; j < A.rows; ++j)
            {
                float a_ji = A(j, i) * a_ii;
                for (int k = i + 1; k < A.cols; ++k)
                {
                    A(j, k) -= A(i, k) * a_ji;
                    if ((A(j, k) < TINY_MATH_MIN_POSITIVE_INPUT_F32) && (A(j, k) > -1 * TINY_MATH_MIN_POSITIVE_INPUT_F32))
                    {
                        A(j, k) = 0;
                    }
                }
                b(j, 0) -= b(i, 0) * a_ji;
                if (A(j, 0) < TINY_MATH_MIN_POSITIVE_INPUT_F32 && A(j, 0) > -1 * TINY_MATH_MIN_POSITIVE_INPUT_F32)
                {
                    A(j, 0) = 0;
                }
                A(j, i) = 0;
            }
        }

        // Back substitution
        Mat x(b.rows, 1);
        x((x.rows - 1), 0) = b((x.rows - 1), 0) / A((x.rows - 1), (x.rows - 1));
        if (x((x.rows - 1), 0) < TINY_MATH_MIN_POSITIVE_INPUT_F32 && x((x.rows - 1), 0) > -1 * TINY_MATH_MIN_POSITIVE_INPUT_F32)
        {
            x((x.rows - 1), 0) = 0;
        }
        for (int i = x.rows - 2; i >= 0; --i)
        {
            float sum = 0;
            for (int j = i + 1; j < x.rows; ++j)
            {
                sum += A(i, j) * x(j, 0);
            }
            x(i, 0) = (b(i, 0) - sum) / A(i, i);
            if (x(i, 0) < TINY_MATH_MIN_POSITIVE_INPUT_F32 && x(i, 0) > -1 * TINY_MATH_MIN_POSITIVE_INPUT_F32)
            {
                x(i, 0) = 0;
            }
        }
        return x;
    }

    Mat Mat::bandSolve(Mat A, Mat b, int k)
    {
        // optimized Gaussian elimination
        int bandsBelow = (k - 1) / 2;
        for (int i = 0; i < A.rows; ++i)
        {
            if (A(i, i) == 0)
            {
                // pivot 0 - error
                std::cerr << "Error: the coefficient matrix has 0 as a pivot. Please fix the input and try again." << std::endl;
                Mat err_result(b.rows, 1);
                memset(err_result.data, 0, b.rows * sizeof(float));
                return err_result;
            }
            float a_ii = 1 / A(i, i);
            for (int j = i + 1; j < A.rows && j <= i + bandsBelow; ++j)
            {
                int k = i + 1;
                while ((k < A.cols) && (fabs(A(j, k)) > TINY_MATH_MIN_POSITIVE_INPUT_F32))
                {
                    A(j, k) -= A(i, k) * (A(j, i) * a_ii);
                    k++;
                }
                b(j, 0) -= b(i, 0) * (A(j, i) * a_ii);
                A(j, i) = 0;
            }
        }

        // Back substitution
        Mat x(b.rows, 1);
        x((x.rows - 1), 0) = b((x.rows - 1), 0) / A((x.rows - 1), (x.rows - 1));
        for (int i = x.rows - 2; i >= 0; --i)
        {
            float sum = 0;
            for (int j = i + 1; j < x.rows; ++j)
            {
                sum += A(i, j) * x(j, 0);
            }
            x(i, 0) = (b(i, 0) - sum) / A(i, i);
        }

        return x;
    }

    Mat Mat::roots(Mat A, Mat y)
    {
        int n = A.cols + 1;

        Mat result(y.rows, 1);

        Mat g_m = Mat::augment(A, y);
        for (int j = 0; j < A.cols; j++)
        {
            float g_jj = 1 / g_m(j, j);
            for (int i = 0; i < A.cols; i++)
            {
                if (i != j)
                {
                    float c = g_m(i, j) * g_jj;
                    for (int k = 0; k < n; k++)
                    {
                        g_m(i, k) = g_m(i, k) - c * g_m(j, k);
                    }
                }
            }
        }
        for (int i = 0; i < A.rows; i++)
        {
            result(i, 0) = g_m(i, A.cols) / g_m(i, i);
        }
        return result;
    }

    float Mat::dotProduct(Mat a, Mat b)
    {
        float sum = 0;
        for (int i = 0; i < a.rows; ++i)
        {
            sum += (a(i, 0) * b(i, 0));
        }
        return sum;
    }

    Mat Mat::augment(Mat A, Mat B)
    {
        Mat AB(A.rows, A.cols + B.cols);
        for (int i = 0; i < AB.rows; ++i)
        {
            for (int j = 0; j < AB.cols; ++j)
            {
                if (j < A.cols)
                {
                    AB(i, j) = A(i, j);
                }
                else
                {
                    AB(i, j) = B(i, j - A.cols);
                }
            }
        }
        return AB;
    }

    Mat Mat::gaussianEliminate()
    {
        Mat Ab(*this);
        int rows = Ab.rows;
        int cols = Ab.cols;
        int Acols = cols - 1;

        int i = 0; // row tracker
        int j = 0; // column tracker

        // iterate through the rows
        while (i < rows)
        {
            // find a pivot for the row
            bool pivot_found = false;
            while (j < Acols && !pivot_found)
            {
                if (Ab(i, j) != 0)
                { // pivot not equal to 0
                    pivot_found = true;
                }
                else
                { // check for a possible swap
                    int max_row = i;
                    float max_val = 0;
                    for (int k = i + 1; k < rows; ++k)
                    {
                        float cur_abs = Ab(k, j) >= 0 ? Ab(k, j) : -1 * Ab(k, j);
                        if (cur_abs > max_val)
                        {
                            max_row = k;
                            max_val = cur_abs;
                        }
                    }
                    if (max_row != i)
                    {
                        Ab.swapRows(max_row, i);
                        pivot_found = true;
                    }
                    else
                    {
                        j++;
                    }
                }
            }

            // perform elimination as normal if pivot was found
            if (pivot_found)
            {
                for (int t = i + 1; t < rows; ++t)
                {
                    for (int s = j + 1; s < cols; ++s)
                    {
                        Ab(t, s) = Ab(t, s) - Ab(i, s) * (Ab(t, j) / Ab(i, j));
                        if (Ab(t, s) < TINY_MATH_MIN_POSITIVE_INPUT_F32 && Ab(t, s) > -1 * TINY_MATH_MIN_POSITIVE_INPUT_F32)
                        {
                            Ab(t, s) = 0;
                        }
                    }
                    Ab(t, j) = 0;
                }
            }

            i++;
            j++;
        }

        return Ab;
    }

    Mat Mat::rowReduceFromGaussian()
    {
        Mat R(*this);
        int rows = R.rows;
        int cols = R.cols;

        int i = rows - 1; // row tracker
        int j = cols - 2; // column tracker

        // iterate through every row
        while (i >= 0)
        {
            // find the pivot column
            int k = j - 1;
            while (k >= 0)
            {
                if (R(i, k) != 0)
                {
                    j = k;
                }
                k--;
            }

            // zero out elements above pivots if pivot not 0
            if (R(i, j) != 0)
            {
                for (int t = i - 1; t >= 0; --t)
                {
                    for (int s = 0; s < cols; ++s)
                    {
                        if (s != j)
                        {
                            R(t, s) = R(t, s) - R(i, s) * (R(t, j) / R(i, j));
                            if (R(t, s) < TINY_MATH_MIN_POSITIVE_INPUT_F32 && R(t, s) > -1 * TINY_MATH_MIN_POSITIVE_INPUT_F32)
                            {
                                R(t, s) = 0;
                            }
                        }
                    }
                    R(t, j) = 0;
                }

                // divide row by pivot
                for (int k = j + 1; k < cols; ++k)
                {
                    R(i, k) = R(i, k) / R(i, j);
                    if (R(i, k) < TINY_MATH_MIN_POSITIVE_INPUT_F32 && R(i, k) > -1 * TINY_MATH_MIN_POSITIVE_INPUT_F32)
                    {
                        R(i, k) = 0;
                    }
                }
                R(i, j) = 1;
            }

            i--;
            j--;
        }

        return R;
    }

    Mat Mat::pinv()
    {
        Mat I = Mat::eye(this->rows);
        Mat AI = Mat::augment(*this, I);
        Mat U = AI.gaussianEliminate();
        Mat IAInverse = U.rowReduceFromGaussian();
        Mat AInverse(this->rows, this->cols);
        for (int i = 0; i < this->rows; ++i)
        {
            for (int j = 0; j < this->cols; ++j)
            {
                AInverse(i, j) = IAInverse(i, j + this->cols);
            }
        }
        return AInverse;
    }

    float Mat::det(int n)
    {
        float D = 0; // Initialize result

        //  Base case : if matrix contains single element
        if (n == 1)
        {
            return (*this)(0, 0);
        }

        Mat temp(this->rows, this->rows); // To store cofactors

        int sign = 1; // To store sign multiplier

        // Iterate for each element of first row
        for (int f = 0; f < n; f++)
        {
            // Getting Cofactor of A[0][f]
            Mat temp = this->cofactor(0, f, n);
            D += (*this)(0, f) * temp.det(n - 1) * sign;

            // terms are to be added with alternate sign
            sign = -sign;
        }

        return D;
    }

    Mat Mat::inverse()
    {
        Mat result(this->rows, this->cols);
        // Find determinant of matrix
        float det = this->det(this->rows);
        if (det == 0)
        {
            // std::cout << "Singular matrix, can't find its inverse";
            return result;
        }

        // Find adjoint
        Mat adj = this->adjoint();

        // Find Inverse using formula "inverse(A) = adj(A)/det(A)"
        for (int i = 0; i < this->rows; i++)
            for (int j = 0; j < this->cols; j++)
            {
                result(i, j) = adj(i, j) / float(det);
            }

        return result;
    }

    Mat Mat::adjoint()
    {
        Mat adj(this->rows, this->cols);
        if (this->rows == 1)
        {
            adj(0, 0) = 1;
            return adj;
        }

        // temp is used to store cofactors of A(,)
        int sign = 1;
        Mat temp(this->rows, this->cols);

        for (int i = 0; i < this->rows; i++)
        {
            for (int j = 0; j < this->cols; j++)
            {
                // Get cofactor of A(i,j)
                temp = this->cofactor(i, j, this->rows);

                // sign of adj(j,i) positive if sum of row
                // and column indexes is even.
                sign = ((i + j) % 2 == 0) ? 1 : -1;

                // Interchanging rows and columns to get the
                // transpose of the cofactor matrix
                adj(j, i) = (sign) * (temp.det(this->rows - 1));
            }
        }
        return adj;
    }

    ostream &operator<<(ostream &os, const Mat &m)
    {
        for (int i = 0; i < m.rows; ++i)
        {
            os << m(i, 0);
            for (int j = 1; j < m.cols; ++j)
            {
                os << " " << m(i, j);
            }
            os << endl;
        }
        return os;
    }

    ostream &operator<<(ostream &os, const Mat::Rect &rect)
    {
        os << "row start " << rect.y << endl;
        os << "col start " << rect.x << endl;
        os << "row count " << rect.height << endl;
        os << "col count " << rect.width << endl;

        return os;
    }

    istream &operator>>(istream &is, Mat &m)
    {
        for (int i = 0; i < m.rows; ++i)
        {
            for (int j = 0; j < m.cols; ++j)
            {
                is >> m(i, j);
            }
        }
        return is;
    }

    Mat operator+(const Mat &m1, const Mat &m2)
    {
        if ((m1.rows != m2.rows) || (m1.cols != m2.cols))
        {
            std::cerr << "operator + Error: matrices do not have equal dimensions" << std::endl;
            Mat err_ret;
            return err_ret;
        }

        if (m1.sub_matrix || m2.sub_matrix)
        {
            Mat temp(m1.rows, m2.cols);
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_add_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m1.padding, m2.padding, temp.padding, 1, 1, 1);
#else
            tiny_mat_add_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m1.padding, m2.padding, temp.padding, 1, 1, 1);
#endif
            return temp;
        }
        else
        {
            Mat temp(m1);
            return (temp += m2);
        }
    }

    Mat operator+(const Mat &m, float C)
    {
        if (m.sub_matrix)
        {
            Mat temp(m.rows, m.cols);
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_addc_f32(m.data, temp.data, C, m.rows, m.cols, m.padding, temp.padding, 1, 1);
#else
            tiny_mat_addc_f32(m.data, temp.data, C, m.rows, m.cols, m.padding, temp.padding, 1, 1);
#endif
            return temp;
        }
        else
        {
            Mat temp(m);
            return (temp += C);
        }
    }

    bool operator==(const Mat &m1, const Mat &m2)
    {
        if ((m1.cols != m2.cols) || (m1.rows != m2.rows))
        {
            return false;
        }

        for (int row = 0; row < m1.rows; row++)
        {
            for (int col = 0; col < m1.cols; col++)
            {
                if (m1(row, col) != m2(row, col))
                {
                    std::cout << "operator == Error: " << row << " " << col << ", m1.data=" << m1(row, col) << ", m2.data=" << m2(row, col) << std::endl;
                    return false;
                }
            }
        }

        return true;
    }

    Mat operator-(const Mat &m1, const Mat &m2)
    {
        if ((m1.rows != m2.rows) || (m1.cols != m2.cols))
        {
            std::cerr << "operator - Error: matrices do not have equal dimensions" << std::endl;
            Mat err_ret;
            return err_ret;
        }

        if (m1.sub_matrix || m2.sub_matrix)
        {
            Mat temp(m1.rows, m1.cols);
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_sub_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m1.padding, m2.padding, temp.padding, 1, 1, 1);
#else
            tiny_mat_sub_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m1.padding, m2.padding, temp.padding, 1, 1, 1);
#endif
            return temp;
        }
        else
        {
            Mat temp(m1);
            return (temp -= m2);
        }
    }

    Mat operator-(const Mat &m, float C)
    {
        if (m.sub_matrix)
        {
            Mat temp(m.rows, m.cols);
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_addc_f32(m.data, temp.data, -C, m.rows, m.cols, m.padding, temp.padding, 1, 1);
#else
            tiny_mat_addc_f32(m.data, temp.data, -C, m.rows, m.cols, m.padding, temp.padding, 1, 1);
#endif
            return temp;
        }
        else
        {
            Mat temp(m);
            return (temp -= C);
        }
    }

    Mat operator*(const Mat &m1, const Mat &m2)
    {
        if (m1.cols != m2.rows)
        {
            std::cerr << "operator * Error: matrices do not have correct dimensions" << std::endl;
            Mat err_ret;
            return err_ret;
        }
        Mat temp(m1.rows, m2.cols);

        if (m1.sub_matrix || m2.sub_matrix)
        {
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_mult_ex_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m2.cols, m1.padding, m2.padding, temp.padding);
#else
            tiny_mat_mult_ex_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m2.cols, m1.padding, m2.padding, temp.padding);
#endif
        }
        else
        {
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_mult_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m2.cols);
#else
            tiny_mat_mult_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m2.cols);
#endif
        }

        return temp;
    }

    Mat operator*(const Mat &m, float num)
    {
        if (m.sub_matrix)
        {
            Mat temp(m.rows, m.cols);
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_mulc_f32(m.data, temp.data, num, m.rows, m.cols, m.padding, temp.padding, 1, 1);
#else
            tiny_mat_mulc_f32(m.data, temp.data, num, m.rows, m.cols, m.padding, temp.padding, 1, 1);
#endif
            return temp;
        }
        else
        {
            Mat temp(m);
            return (temp *= num);
        }
    }

    Mat operator*(float num, const Mat &m)
    {
        return (m * num);
    }

    Mat operator/(const Mat &m, float num)
    {
        if (m.sub_matrix)
        {
            Mat temp(m.rows, m.cols);
#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32
            dspm_mulc_f32(m.data, temp.data, 1 / num, m.rows, m.cols, m.padding, temp.padding, 1, 1);
#else
            tiny_mat_multc_f32(m.data, temp.data, 1 / num, m.rows, m.cols, m.padding, temp.padding, 1, 1);
#endif
            return temp;
        }
        else
        {
            Mat temp(m);
            return (temp /= num);
        }
    }

    Mat operator/(const Mat &A, const Mat &B)
    {
        if ((A.rows != B.rows) || (A.cols != B.cols))
        {
            std::cerr << "operator / Error: matrices do not have equal dimensions" << std::endl;
            Mat err_ret;
            return err_ret;
        }

        Mat temp(A.rows, A.cols);
        for (int row = 0; row < A.rows; row++)
        {
            for (int col = 0; col < A.cols; col++)
            {
                temp(row, col) = A(row, col) / B(row, col);
            }
        }
        return temp;
    }

}