{"config":{"lang":["en","zh"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TinySHM: Distributed Intelligence Enabling Framework for Structural Health Monitoring","text":""},{"location":"#about-this-project","title":"ABOUT THIS PROJECT","text":"<p>This project aims to develop an empowering framework that equips MCU-level IoT devices with distributed computing and intelligence capabilities to facilitate structural health monitoring applications. If you think this project is interesting, please give it a star and stay tuned.</p> <p>TinySHM</p> <p>\"TinySHM\" is a combination of \"Tiny\" and \"SHM\". \"Tiny\" means the codes are designed to run on MCU devices, while \"SHM\" stands for \"Structural Health Monitoring\".</p>"},{"location":"#target-hardware","title":"TARGET HARDWARE","text":"<ul> <li>MCU devices (ESP32 as the main target)</li> </ul>"},{"location":"#scope","title":"SCOPE","text":"<ul> <li>Basic Math Operations</li> <li>Digital Signal Processing</li> <li>TinyML / Edge AI</li> <li>Measurement</li> <li>System Identification</li> <li>Damage Monitoring, Localization, and Assessment</li> </ul>"},{"location":"ABOUT/about/","title":"TinySHM: Distributed Intelligence Enabling Framework for Structural Health Monitoring","text":""},{"location":"ABOUT/about/#about-this-project","title":"ABOUT THIS PROJECT","text":"<p>This project aims to develop an empowering framework that equips MCU-level IoT devices with distributed computing and intelligence capabilities to facilitate structural health monitoring applications. If you think this project is interesting, please give it a star and stay tuned.</p> <p>TinySHM</p> <p>\"TinySHM\" is a combination of \"Tiny\" and \"SHM\". \"Tiny\" means the codes are designed to run on MCU devices, while \"SHM\" stands for \"Structural Health Monitoring\".</p>"},{"location":"ABOUT/about/#target-hardware","title":"TARGET HARDWARE","text":"<ul> <li>MCU devices (ESP32 as the main target)</li> </ul>"},{"location":"ABOUT/about/#scope","title":"SCOPE","text":"<ul> <li>Basic Math Operations</li> <li>Digital Signal Processing</li> <li>TinyML / Edge AI</li> <li>Measurement</li> <li>System Identification</li> <li>Damage Monitoring, Localization, and Assessment</li> </ul>"},{"location":"ADAPTATION/adaptation/","title":"ADAPTATION","text":"<p>ADAPTATION</p> <p>The adaptation layer serves as a buffer layer between the MCU platform and TinySHM. Its core function is to decouple the platform-specific components from the computational and intelligent components in TinySHM, facilitating cross-platform migration and application of TinySHM. </p> <p>Warning</p> <p>Currently, development is based on ESP32, and migration to platforms like STM32 will require some modifications to the adaptation layer.</p>"},{"location":"ADAPTATION/adaptation/#support-for-esp32-official-libs","title":"SUPPORT FOR ESP32 OFFICIAL LIBS","text":"<ul> <li> <p> ESP-DSP</p> <p>  Online Doc </p> </li> <li> <p> ESP-DL</p> <p>  Online Doc </p> </li> </ul>"},{"location":"ADAPTATION/code/","title":"CODE","text":"<p>Warning</p> <p>The following code should be based on the code in the release code, which may have been updated.</p>"},{"location":"ADAPTATION/code/#cmakeliststxt","title":"CMakeLists.txt","text":"<pre><code>set(src_dirs\n    .\n)\n\nset(include_dirs\n    include\n)\n\nset(requires\n    esp_timer\n    espressif__esp-dsp\n    espressif__esp_jpeg\n    espressif__esp-dl\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"ADAPTATION/code/#tinyadapterh","title":"TinyAdapter.h","text":"<pre><code>/**\n * @file TinyAdapter.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the TinyAdapter middleware.\n * @version 1.0\n * @date 2025-03-26\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINYADAPTER_H__\n#define __TINYADAPTER_H__\n\n/* CONFIGURATIONS */\n\n/* DEPENDENCIES */\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n#include \"esp_timer.h\"\n#include \"esp_heap_caps.h\"\n#include \"esp_dsp.h\"\n// #include \"esp_dl.h\"\n\n/* DEFINITIONS */\ntypedef TickType_t TinyTimeMark_t;\n\n/* FUNCTIONS */\nTinyTimeMark_t tiny_get_running_time(void);\n\n#endif /* __TINYADAPTER_H__ */\n</code></pre>"},{"location":"ADAPTATION/code/#tinyadapterc","title":"TinyAdapter.c","text":"<pre><code>/**\n * @file TinyAdapter.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the source file for the TinyAdapter middleware.\n * @version 1.0\n * @date 2025-03-26\n *\n * @copyright Copyright (c) 2025\n *\n */\n\n/* DEPENDENCIES */\n#include \"TinyAdapter.h\"\n\n/* DEFINITIONS */\n\n/* FUNCTIONS */\nTinyTimeMark_t tiny_get_running_time(void)\n{\n    return esp_timer_get_time();\n}\n</code></pre>"},{"location":"ADAPTATION/log/","title":"DEV LOG","text":"<p>2025-04-08</p> <ul> <li>Running time query function tiny_get_running_time()</li> </ul>"},{"location":"ADAPTATION/notes/","title":"NOTES","text":""},{"location":"ADAPTATION/notes/#dependencies","title":"DEPENDENCIES","text":"<p>FreeRTOS</p> <pre><code>#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n</code></pre> <p>log</p> <pre><code>#include \"esp_log.h\"\n</code></pre> <p>timer</p> <pre><code>#include \"esp_timer.h\"\n</code></pre>"},{"location":"ADAPTATION/notes/#running-time-query","title":"RUNNING TIME QUERY","text":"<p>We first define a new data type based on ESP32 built-in data type</p> <pre><code>typedef TickType_t TinyTimeMark_t;\n</code></pre> <p>Then we define a function in the adaptation layer to get the current system running time since startup, in microseconds</p> <pre><code>TinyTimeMark_t tiny_get_running_time(void)\n{\n    return esp_timer_get_time();\n}\n</code></pre>"},{"location":"AI/ai/","title":"ARTIFICIAL INTELLIGENCE","text":""},{"location":"ARCHITECTURE/architecture/","title":"ARCHITECTURE","text":""},{"location":"ARCHITECTURE/architecture/#layered-architecture","title":"LAYERED ARCHITECTURE","text":"<pre><code>+------------------------------+\n| AI                           | &lt;-- AI/ML Functions for Edge Devices based on Low Level Functions\n+------------------------------+\n| DSP                          | &lt;-- Digital Signal Processing Functions\n+------------------------------+\n| Math Operations              | &lt;-- Commonly Used Math Functions for Various Applications\n+------------------------------+\n| Adaptation Layer             | &lt;-- To Replace Functions in Standard C with Platform Optimized/Specific Functions\n+------------------------------+\n</code></pre>"},{"location":"ARCHITECTURE/architecture/#code-organization","title":"CODE ORGANIZATION","text":"<pre><code>+------------------------------+\n| APPLICATION                  |\n|   - measurement              | &lt;-- measurement / sensing\n|   - system_identification    | &lt;-- system identification\n|   - damage detection         | &lt;-- damage detection, localization, and assessment\n+------------------------------+\n| MIDDLEWARE                   |\n|   - TinyAdapter              | &lt;-- Platform-specific Low-level Optimization\n|   - TinyMath                 | &lt;-- Common Math Functions\n|   - TinyDSP                  | &lt;-- DSP Functions\n|   - TinyAI                   | &lt;-- AI Functions\n+------------------------------+\n| DRIVERS                      |\n+------------------------------+\n| HARDWARE                     |\n+------------------------------+\n</code></pre>"},{"location":"DEVKITS/devkits/","title":"DEVKITS","text":""},{"location":"DEVKITS/devkits/#host-mcu-hardwares","title":"HOST MCU HARDWARES","text":"<ul> <li>DNESP32S3M from Alientek (ESP32-S3)</li> </ul>"},{"location":"DEVKITS/devkits/#deb-boards-setup-guidance","title":"DEB BOARDS SETUP GUIDANCE","text":"<ul> <li> <p> NexNode</p> <p>  Repo </p> <p>  Online Doc </p> </li> </ul>"},{"location":"DSP/dsp/","title":"DIGITAL SIGNAL PROCESSING","text":""},{"location":"MATH/math/","title":"MATH OPERATIONS","text":""},{"location":"MEASUREMENT/code/","title":"CODE","text":"<p>Warning</p> <p>The following code should be based on the code in the release code, which may have been updated.</p>"},{"location":"MEASUREMENT/code/#cmakeliststxt","title":"CMakeLists.txt","text":"<pre><code>set(src_dirs\n    .\n)\n\nset(include_dirs\n    include\n)\n\nset(requires\n    driver\n    tim\n    esp_rtc\n    spi_sdcard\n    mpu6050\n    exit\n    lcd\n    led\n    wifi\n    esp32_mqtt\n    TinyAdapter\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"MEASUREMENT/code/#measurementh","title":"measurement.h","text":"<pre><code>/**\n * @file measurement.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the measurement module.\n * @version 1.0\n * @date 2025-04-01\n * @copyright Copyright (c) 2025\n * @note Currently, the sesning is realized by FreeRTOS, and therefore the upper limit sampling rate is 1kHz.\n * @todo Sampling by timer + interrupt\n * @todo Sampling by DMA\n */\n\n#ifndef __MEASUREMENT_H__\n#define __MEASUREMENT_H__\n\n/* DEPENDENCIES */\n// SYSTEM\n#include \"esp_system.h\" // ESP32 System\n#include \"esp_log.h\"    // ESP32 Logging\n\n// RTOS\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/event_groups.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/timers.h\"\n#include \"freertos/semphr.h\"\n\n// BSP\n#include \"driver/gptimer.h\"\n#include \"led.h\"\n#include \"lcd.h\"\n#include \"tim.h\"\n#include \"esp_rtc.h\"\n#include \"spi_sdcard.h\"\n#include \"wifi_wpa2_enterprise.h\"\n#include \"mqtt.h\"\n#include \"mpu6050.h\"\n\n// TinyAuton/TinySHM\n#include \"TinyAdapter.h\"\n\n/* VARIABLES */\nextern struct SenseConfig streamline_config; // Streamline configuration\nextern struct SenseConfig sense_config; // Sense configuration\n\n/* FUNCTIONS */\n/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters);\n\n/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters);\n\n#endif /* __MEASUREMENT_H__ */\n</code></pre>"},{"location":"MEASUREMENT/code/#measurementc","title":"measurement.c","text":"<pre><code>/**\n * @file measurement.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the source file for the measurement module.\n * @version 1.0\n * @date 2025-04-01\n * @copyright Copyright (c) 2025\n * @note Currently, the sesning is realized by FreeRTOS, and therefore the upper limit sampling rate is 1kHz.\n * @todo Sampling by timer + interrupt\n * @todo Sampling by DMA\n */\n\n/* DEPENDENCIES */\n#include \"measurement.h\"\n\n/* VARIABLES */\nstatic const char *TAG = \"TinySHM-Measurement\"; // Tag for logging\n\n// static uint8_t mpu6050_deviceid;    // MPU6050 Device ID\nstatic mpu6050_acce_value_t acce; // MPU6050 Accelerometer Value\n// static mpu6050_gyro_value_t gyro;   // MPU6050 Gyroscope Value\nstatic mpu6050_temp_value_t temp; // MPU6050 Temperature Value\n// static complimentary_angle_t angle; // Complimentary Angle\n\n/* DEFINITION */\nstruct SenseConfig\n{\n    int sample_rate;\n    int sample_duration;\n    bool temperature_sense; // whether to sense temperature\n    bool printout;          // not recommened for high sample rate as it will slow down the process\n    bool mqtt_pub;          // not recommened for high sample rate as it will slow down the process\n};\n\nstruct DataStruct\n{\n    int sample_rate;\n    int sample_duration;\n    float sensor_temperature;\n    TinyTimeMark_t start_time_stamp;\n    TinyTimeMark_t *time_stamp;\n    float *acc_data;\n    float *temperature;\n};\n\n/* VARIABLES */\n// for streamline configuration\nstruct SenseConfig streamline_config = {\n    .sample_rate = 1,          // Sample rate in Hz. For local printout + mqtt, at most 25Hz; for only mqtt, at most 200Hz.\n    .temperature_sense = true, // Whether to sense temperature\n    .printout = true,          // Only available for sampling rate &lt;= 100Hz\n    .mqtt_pub = true           // Only available for sampling rate &lt;= 100Hz\n};\n\n// for sensing configuration\nstruct SenseConfig sense_config = {\n    .sample_rate = 500,   // Sample rate in Hz, only can be (1, 2, 5, 10, 20, 25, 50, 100, 200, 500) for FreeRTOS based sensing. Note can not be 1000Hz (no time to feed the watchdog).\n    .sample_duration = 1, // Sample duration in seconds\n    .printout = true      // Only available for sampling rate &lt;= 100Hz\n};\n\n// for data structure\nstruct DataStruct data_struct = {\n    .sample_rate = 0,     // Sample rate in Hz\n    .sample_duration = 0, // Sample duration in seconds\n    .sensor_temperature = 0.0,\n    .start_time_stamp = 0,\n    .acc_data = NULL};\n\n/* FUNCTION PROTOTYPES */\n/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters)\n{\n\n    // streamline variables\n    float acc_x, acc_y, acc_z, temperature;\n    TinyTimeMark_t time_stamp;\n\n    // MQTT publish buffer\n    char streamline_buff[256];\n\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n\n    if (config-&gt;sample_rate &gt; 100 &amp;&amp; config-&gt;printout)\n    {\n        ESP_LOGW(TAG, \"Printout is disabled for sample rate &gt; 100Hz.\");\n        config-&gt;printout = false;\n    }\n\n    while (1)\n    {\n        // get the time stamp\n        time_stamp = tiny_get_running_time();\n\n        // get accelerometer data\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        acc_x = acce.acce_x;\n        acc_y = acce.acce_y;\n        acc_z = acce.acce_z;\n\n        // get temperature\n        mpu6050_get_temp(mpu6050, &amp;temp);\n        temperature = temp.temp;\n\n        // sprintf\n        if (config-&gt;printout || config-&gt;mqtt_pub)\n        {\n            snprintf(streamline_buff, sizeof(streamline_buff), \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Sensor Temperature: %4.2f \u00b0C\", time_stamp, acc_x, acc_y, acc_z, temperature);\n        }\n\n        // // print out the data\n        if (config-&gt;printout)\n        {\n            ESP_LOGI(TAG, \"%s\", streamline_buff);\n        }\n\n        // MQTT publish\n        if (config-&gt;mqtt_pub)\n        {\n            esp_mqtt_client_publish(s_mqtt_client, MQTT_PUBLIC_TOPIC, streamline_buff, strlen(streamline_buff), 0, 0); // for streamline, data quality is not expected to be high, so QoS = 0; data retaintion is also not required, so 0.\n        }\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n    ESP_LOGI(TAG, \"Streamline terminated. Task will delete itself.\");\n    vTaskDelete(NULL);\n}\n\n/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters)\n{\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n    int total_samples = config-&gt;sample_rate * config-&gt;sample_duration;\n\n    // Fill global data_struct\n    data_struct.sample_rate = config-&gt;sample_rate;\n    data_struct.sample_duration = config-&gt;sample_duration;\n    mpu6050_get_temp(mpu6050, &amp;temp);\n    data_struct.sensor_temperature = temp.temp;\n    data_struct.start_time_stamp = tiny_get_running_time();\n\n    // Allocate memory\n    data_struct.acc_data = malloc(sizeof(float) * 3 * total_samples);\n    data_struct.temperature = malloc(sizeof(float) * total_samples);\n    data_struct.time_stamp = malloc(sizeof(TinyTimeMark_t) * total_samples);\n\n    if (data_struct.acc_data == NULL || data_struct.temperature == NULL || data_struct.time_stamp == NULL)\n    {\n        ESP_LOGE(TAG, \"Failed to allocate memory for sensing data.\");\n        if (data_struct.acc_data)\n            free(data_struct.acc_data);\n        if (data_struct.temperature)\n            free(data_struct.temperature);\n        if (data_struct.time_stamp)\n            free(data_struct.time_stamp);\n        vTaskDelete(NULL);\n    }\n\n    ESP_LOGI(TAG, \"Sampling started: %d Hz for %d seconds (%d samples)\",\n             config-&gt;sample_rate, config-&gt;sample_duration, total_samples);\n\n    for (int i = 0; i &lt; total_samples; i++)\n    {\n        TinyTimeMark_t now = tiny_get_running_time();\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        mpu6050_get_temp(mpu6050, &amp;temp);\n\n        // Store data\n        data_struct.time_stamp[i] = now;\n        data_struct.acc_data[i * 3 + 0] = acce.acce_x;\n        data_struct.acc_data[i * 3 + 1] = acce.acce_y;\n        data_struct.acc_data[i * 3 + 2] = acce.acce_z;\n        data_struct.temperature[i] = temp.temp;\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n\n    ESP_LOGI(TAG, \"Sampling complete.\");\n\n    // Print metadata\n    ESP_LOGI(TAG, \"-----------------------------\");\n    ESP_LOGI(TAG, \"Sensor Temperature : %.2f \u00b0C\", data_struct.sensor_temperature);\n    ESP_LOGI(TAG, \"Start Time Stamp   : %ld\", (long)data_struct.start_time_stamp);\n    ESP_LOGI(TAG, \"Sample Rate        : %d Hz\", data_struct.sample_rate);\n    ESP_LOGI(TAG, \"Sample Duration    : %d sec\", data_struct.sample_duration);\n    ESP_LOGI(TAG, \"Total Samples      : %d\", total_samples);\n    ESP_LOGI(TAG, \"Data Size          : %.2f KB\",\n             (sizeof(float) * 4 + sizeof(TinyTimeMark_t)) * total_samples / 1024.0f);\n    ESP_LOGI(TAG, \"-----------------------------\");\n\n    // Print collected data if enabled\n    if (config-&gt;printout)\n    {\n        for (int i = 0; i &lt; total_samples; i++)\n        {\n            ESP_LOGI(TAG, \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Temperature: %.2f \u00b0C\",\n                     (long)data_struct.time_stamp[i],\n                     data_struct.acc_data[i * 3 + 0],\n                     data_struct.acc_data[i * 3 + 1],\n                     data_struct.acc_data[i * 3 + 2],\n                     data_struct.temperature[i]);\n\n            // Release CPU for a short time to avoid blocking\n            if ((i % 10) == 0)\n            {\n                vTaskDelay(pdMS_TO_TICKS(10));\n            }\n        }\n    }\n\n    // Free allocated memory\n    if (data_struct.acc_data)\n    {\n        free(data_struct.acc_data);\n        data_struct.acc_data = NULL;\n    }\n    if (data_struct.temperature)\n    {\n        free(data_struct.temperature);\n        data_struct.temperature = NULL;\n    }\n    if (data_struct.time_stamp)\n    {\n        free(data_struct.time_stamp);\n        data_struct.time_stamp = NULL;\n    }\n\n    vTaskDelete(NULL);\n}\n</code></pre>"},{"location":"MEASUREMENT/log/","title":"DEV LOG","text":"<p>2025-04-03</p> <ul> <li>Sampling configuration structure</li> <li>Sampling data structure</li> <li>Real-time sampling function / regular sampling function</li> <li>Sampling frequency upper limit test: real-time (25Hz-local output + MQTT; 200Hz-only MQTT); regular (500Hz)</li> <li>Server-side visualization program</li> <li>Server-side data storage</li> </ul>"},{"location":"MEASUREMENT/measurement/","title":"MEASUREMENT","text":"<p>Measurement</p> <p>High quality measurement/sampling is the basis of data analysis, and TinySHM fully considers this in its design. We have implemented a variety of measurement/sampling methods in TinySHM, and users can choose according to their needs.</p> <p>Warning</p> <p>Currently, development is based on ESP32, and migration to platforms like STM32 will require some modifications to the adaptation layer.</p>"},{"location":"MEASUREMENT/notes/","title":"NOTES","text":""},{"location":"MEASUREMENT/notes/#dependencies","title":"DEPENDENCIES","text":"<p>SYSTEM</p> <pre><code>#include \"esp_system.h\" // ESP32 System\n#include \"esp_log.h\"    // ESP32 Logging\n</code></pre> <p>RTOS</p> <pre><code>#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/event_groups.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/timers.h\"\n#include \"freertos/semphr.h\"\n</code></pre> <p>BSP</p> <pre><code>#include \"driver/gptimer.h\"\n#include \"led.h\"\n#include \"lcd.h\"\n#include \"tim.h\"\n#include \"esp_rtc.h\"\n#include \"spi_sdcard.h\"\n#include \"wifi_wpa2_enterprise.h\"\n#include \"mqtt.h\"\n#include \"mpu6050.h\"\n</code></pre> <p>TinyAuton/TinySHM</p> <pre><code>#include \"TinyAdapter.h\"\n</code></pre>"},{"location":"MEASUREMENT/notes/#sampling-configuration-struct","title":"SAMPLING CONFIGURATION STRUCT","text":"<p>Definition</p> <pre><code>struct SenseConfig\n{\n    int sample_rate;\n    int sample_duration;\n    bool temperature_sense; // whether to sense temperature\n    bool printout;          // not recommened for high sample rate as it will slow down the process\n    bool mqtt_pub;          // not recommened for high sample rate as it will slow down the process\n};\n</code></pre> <p>Usage - Streamline</p> <pre><code>// for streamline configuration\nstruct SenseConfig streamline_config = {\n    .sample_rate = 1,          // Sample rate in Hz. For local printout + mqtt, at most 25Hz; for only mqtt, at most 200Hz.\n    .temperature_sense = true, // Whether to sense temperature\n    .printout = true,          // Only available for sampling rate &lt;= 100Hz\n    .mqtt_pub = true           // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre> <p>Usage - Normal</p> <pre><code>// for sensing configuration\nstruct SenseConfig sense_config = {\n    .sample_rate = 500,   // Sample rate in Hz, only can be (1, 2, 5, 10, 20, 25, 50, 100, 200, 500) for FreeRTOS based sensing. Note can not be 1000Hz (no time to feed the watchdog).\n    .sample_duration = 1, // Sample duration in seconds\n    .printout = true      // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre>"},{"location":"MEASUREMENT/notes/#sampling-data-struct","title":"SAMPLING DATA STRUCT","text":"<pre><code>struct DataStruct\n{\n    int sample_rate;\n    int sample_duration;\n    float sensor_temperature;\n    TinyTimeMark_t start_time_stamp;\n    TinyTimeMark_t *time_stamp;\n    float *acc_data;\n    float *temperature;\n};\n</code></pre> <p>usage</p> <pre><code>// for data structure\nstruct DataStruct data_struct = {\n    .sample_rate = 0,     // Sample rate in Hz\n    .sample_duration = 0, // Sample duration in seconds\n    .sensor_temperature = 0.0,\n    .start_time_stamp = 0,\n    .acc_data = NULL}; \n</code></pre>"},{"location":"MEASUREMENT/notes/#sampling-principle","title":"SAMPLING PRINCIPLE","text":"<ul> <li>FreeRTOS based sampling</li> <li>Timer &amp; Interrupt based sampling (to be developed)</li> </ul>"},{"location":"MEASUREMENT/notes/#sampling-modes-and-tasks","title":"SAMPLING MODES AND TASKS","text":"<p>Currently, there are two sampling modes: - Streamline mode - Normal mode</p>"},{"location":"MEASUREMENT/notes/#streamline-sampling","title":"Streamline Sampling","text":"<p>Definition</p> <pre><code>/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters)\n{\n\n    // streamline variables\n    float acc_x, acc_y, acc_z, temperature;\n    TinyTimeMark_t time_stamp;\n\n    // MQTT publish buffer\n    char streamline_buff[256];\n\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n\n    if (config-&gt;sample_rate &gt; 100 &amp;&amp; config-&gt;printout)\n    {\n        ESP_LOGW(TAG, \"Printout is disabled for sample rate &gt; 100Hz.\");\n        config-&gt;printout = false;\n    }\n\n    while (1)\n    {\n        // get the time stamp\n        time_stamp = tiny_get_running_time();\n\n        // get accelerometer data\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        acc_x = acce.acce_x;\n        acc_y = acce.acce_y;\n        acc_z = acce.acce_z;\n\n        // get temperature\n        mpu6050_get_temp(mpu6050, &amp;temp);\n        temperature = temp.temp;\n\n        // sprintf\n        if (config-&gt;printout || config-&gt;mqtt_pub)\n        {\n            snprintf(streamline_buff, sizeof(streamline_buff), \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Sensor Temperature: %4.2f \u00b0C\", time_stamp, acc_x, acc_y, acc_z, temperature);\n        }\n\n        // // print out the data\n        if (config-&gt;printout)\n        {\n            ESP_LOGI(TAG, \"%s\", streamline_buff);\n        }\n\n        // MQTT publish\n        if (config-&gt;mqtt_pub)\n        {\n            esp_mqtt_client_publish(s_mqtt_client, MQTT_PUBLIC_TOPIC, streamline_buff, strlen(streamline_buff), 0, 0); // for streamline, data quality is not expected to be high, so QoS = 0; data retaintion is also not required, so 0.\n        }\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n    ESP_LOGI(TAG, \"Streamline terminated. Task will delete itself.\");\n    vTaskDelete(NULL);\n}\n</code></pre> <p>Usage</p> <pre><code>xTaskCreate(acc_streamline_task, \"Accel_Streamline_Task\", 4096, &amp;streamline_config, 5, NULL);\n</code></pre>"},{"location":"MEASUREMENT/notes/#normal-sampling","title":"Normal Sampling","text":"<p>Definition</p> <pre><code>/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters)\n{\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n    int total_samples = config-&gt;sample_rate * config-&gt;sample_duration;\n\n    // Fill global data_struct\n    data_struct.sample_rate = config-&gt;sample_rate;\n    data_struct.sample_duration = config-&gt;sample_duration;\n    mpu6050_get_temp(mpu6050, &amp;temp);\n    data_struct.sensor_temperature = temp.temp;\n    data_struct.start_time_stamp = tiny_get_running_time();\n\n    // Allocate memory\n    data_struct.acc_data = malloc(sizeof(float) * 3 * total_samples);\n    data_struct.temperature = malloc(sizeof(float) * total_samples);\n    data_struct.time_stamp = malloc(sizeof(TinyTimeMark_t) * total_samples);\n\n    if (data_struct.acc_data == NULL || data_struct.temperature == NULL || data_struct.time_stamp == NULL)\n    {\n        ESP_LOGE(TAG, \"Failed to allocate memory for sensing data.\");\n        if (data_struct.acc_data)\n            free(data_struct.acc_data);\n        if (data_struct.temperature)\n            free(data_struct.temperature);\n        if (data_struct.time_stamp)\n            free(data_struct.time_stamp);\n        vTaskDelete(NULL);\n    }\n\n    ESP_LOGI(TAG, \"Sampling started: %d Hz for %d seconds (%d samples)\",\n             config-&gt;sample_rate, config-&gt;sample_duration, total_samples);\n\n    for (int i = 0; i &lt; total_samples; i++)\n    {\n        TinyTimeMark_t now = tiny_get_running_time();\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        mpu6050_get_temp(mpu6050, &amp;temp);\n\n        // Store data\n        data_struct.time_stamp[i] = now;\n        data_struct.acc_data[i * 3 + 0] = acce.acce_x;\n        data_struct.acc_data[i * 3 + 1] = acce.acce_y;\n        data_struct.acc_data[i * 3 + 2] = acce.acce_z;\n        data_struct.temperature[i] = temp.temp;\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n\n    ESP_LOGI(TAG, \"Sampling complete.\");\n\n    // Print metadata\n    ESP_LOGI(TAG, \"-----------------------------\");\n    ESP_LOGI(TAG, \"Sensor Temperature : %.2f \u00b0C\", data_struct.sensor_temperature);\n    ESP_LOGI(TAG, \"Start Time Stamp   : %ld\", (long)data_struct.start_time_stamp);\n    ESP_LOGI(TAG, \"Sample Rate        : %d Hz\", data_struct.sample_rate);\n    ESP_LOGI(TAG, \"Sample Duration    : %d sec\", data_struct.sample_duration);\n    ESP_LOGI(TAG, \"Total Samples      : %d\", total_samples);\n    ESP_LOGI(TAG, \"Data Size          : %.2f KB\",\n             (sizeof(float) * 4 + sizeof(TinyTimeMark_t)) * total_samples / 1024.0f);\n    ESP_LOGI(TAG, \"-----------------------------\");\n\n    // Print collected data if enabled\n    if (config-&gt;printout)\n    {\n        for (int i = 0; i &lt; total_samples; i++)\n        {\n            ESP_LOGI(TAG, \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Temperature: %.2f \u00b0C\",\n                     (long)data_struct.time_stamp[i],\n                     data_struct.acc_data[i * 3 + 0],\n                     data_struct.acc_data[i * 3 + 1],\n                     data_struct.acc_data[i * 3 + 2],\n                     data_struct.temperature[i]);\n\n            // Release CPU for a short time to avoid blocking\n            if ((i % 10) == 0)\n            {\n                vTaskDelay(pdMS_TO_TICKS(10));\n            }\n        }\n    }\n\n    // Free allocated memory\n    if (data_struct.acc_data)\n    {\n        free(data_struct.acc_data);\n        data_struct.acc_data = NULL;\n    }\n    if (data_struct.temperature)\n    {\n        free(data_struct.temperature);\n        data_struct.temperature = NULL;\n    }\n    if (data_struct.time_stamp)\n    {\n        free(data_struct.time_stamp);\n        data_struct.time_stamp = NULL;\n    }\n\n    vTaskDelete(NULL);\n}\n</code></pre> <p>Usage</p> <pre><code>xTaskCreate(acc_sense_task, \"Accel_Sense_Task\", 8192, &amp;sense_config, 5, NULL);\n</code></pre>"},{"location":"MEASUREMENT/notes/#to-be-developed","title":"TO BE DEVELOPED","text":"<ul> <li>Standard time stamp</li> <li>Calibration</li> <li>Timer &amp; Interrupt based sampling</li> <li>DMA</li> <li>ADC + Analog Sensor</li> <li>Data post-processing</li> <li>Batch data MQTT upload</li> <li>Real-time processing function development</li> </ul>"},{"location":"RELEASES/releases/","title":"RELEASES","text":""},{"location":"RELEASES/releases/#dnesp32s3m-stable","title":"DNESP32S3M-STABLE","text":"<p>Stable version</p>"},{"location":"RELEASES/releases/#dnesp32s3m-latest","title":"DNESP32S3M-LATEST","text":"<p>Latest feature version</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"zh/","title":"TinySHM\uff1a\u7528\u4e8e\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u7684\u5206\u5e03\u5f0f\u667a\u80fd\u6846\u67b6","text":""},{"location":"zh/#_1","title":"\u5173\u4e8e\u672c\u9879\u76ee","text":"<p>\u8be5\u9879\u76ee\u65e8\u5728\u5f00\u53d1\u4e00\u4e2a\u8d4b\u80fd\u6846\u67b6\uff0c\u4f7fMCU\u7ea7\u522b\u7684\u7269\u8054\u7f51\u8bbe\u5907\u5177\u5907\u5206\u5e03\u5f0f\u8ba1\u7b97\u548c\u667a\u80fd\u80fd\u529b\uff0c\u4ece\u800c\u63d0\u5347\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u5e94\u7528\u7684\u6548\u679c\u3002\u5982\u679c\u4f60\u5bf9\u8fd9\u4e2a\u9879\u76ee\u611f\u5174\u8da3\uff0c\u8bf7\u7ed9\u4e2a\u661f\u5e76\u4fdd\u6301\u5173\u6ce8\u3002</p> <p>TinySHM</p> <p>\"TinySHM\" \u662f \"Tiny\" \u548c \"SHM\" \u7684\u7ec4\u5408\u3002\"Tiny\" \u610f\u5473\u7740\u4ee3\u7801\u88ab\u8bbe\u8ba1\u4e3a\u8fd0\u884c\u5728 MCU \u8bbe\u5907\u4e0a\uff0c\u800c \"SHM\" \u662f \"Structural Health Monitoring\" \u7684\u7f29\u5199\u3002</p>"},{"location":"zh/#_2","title":"\u76ee\u6807\u786c\u4ef6","text":"<ul> <li>MCU \u8bbe\u5907\uff08\u4ee5 ESP32 \u4e3a\u4e3b\u8981\u76ee\u6807\uff09</li> </ul>"},{"location":"zh/#_3","title":"\u8303\u56f4","text":"<ul> <li>\u57fa\u672c\u6570\u5b66\u8fd0\u7b97</li> <li>\u6570\u5b57\u4fe1\u53f7\u5904\u7406</li> <li>TinyML / \u8fb9\u7f18\u4eba\u5de5\u667a\u80fd</li> <li>\u6d4b\u91cf</li> <li>\u7cfb\u7edf\u8bc6\u522b</li> <li>\u635f\u4f24\u76d1\u6d4b\u3001\u5b9a\u4f4d\u3001\u8bc4\u4f30</li> </ul>"},{"location":"zh/#_4","title":"TinySHM\uff1a\u7528\u4e8e\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u7684\u5206\u5e03\u5f0f\u667a\u80fd\u6846\u67b6","text":""},{"location":"zh/ABOUT/about/","title":"TinySHM\uff1a\u7528\u4e8e\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u7684\u5206\u5e03\u5f0f\u667a\u80fd\u6846\u67b6","text":""},{"location":"zh/ABOUT/about/#_1","title":"\u5173\u4e8e\u672c\u9879\u76ee","text":"<p>\u8be5\u9879\u76ee\u65e8\u5728\u5f00\u53d1\u4e00\u4e2a\u8d4b\u80fd\u6846\u67b6\uff0c\u4f7fMCU\u7ea7\u522b\u7684\u7269\u8054\u7f51\u8bbe\u5907\u5177\u5907\u5206\u5e03\u5f0f\u8ba1\u7b97\u548c\u667a\u80fd\u80fd\u529b\uff0c\u4ece\u800c\u63d0\u5347\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u5e94\u7528\u7684\u6548\u679c\u3002\u5982\u679c\u4f60\u5bf9\u8fd9\u4e2a\u9879\u76ee\u611f\u5174\u8da3\uff0c\u8bf7\u7ed9\u4e2a\u661f\u5e76\u4fdd\u6301\u5173\u6ce8\u3002</p> <p>TinySHM</p> <p>\"TinySHM\" \u662f \"Tiny\" \u548c \"SHM\" \u7684\u7ec4\u5408\u3002\"Tiny\" \u610f\u5473\u7740\u4ee3\u7801\u88ab\u8bbe\u8ba1\u4e3a\u8fd0\u884c\u5728 MCU \u8bbe\u5907\u4e0a\uff0c\u800c \"SHM\" \u662f \"Structural Health Monitoring\" \u7684\u7f29\u5199\u3002</p>"},{"location":"zh/ABOUT/about/#_2","title":"\u76ee\u6807\u786c\u4ef6","text":"<ul> <li>MCU \u8bbe\u5907\uff08\u4ee5 ESP32 \u4e3a\u4e3b\u8981\u76ee\u6807\uff09</li> </ul>"},{"location":"zh/ABOUT/about/#_3","title":"\u8303\u56f4","text":"<ul> <li>\u57fa\u672c\u6570\u5b66\u8fd0\u7b97</li> <li>\u6570\u5b57\u4fe1\u53f7\u5904\u7406</li> <li>TinyML / \u8fb9\u7f18\u4eba\u5de5\u667a\u80fd</li> <li>\u6d4b\u91cf</li> <li>\u7cfb\u7edf\u8bc6\u522b</li> <li>\u635f\u4f24\u76d1\u6d4b\u3001\u5b9a\u4f4d\u3001\u8bc4\u4f30</li> </ul>"},{"location":"zh/ABOUT/about/#_4","title":"TinySHM\uff1a\u7528\u4e8e\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u7684\u5206\u5e03\u5f0f\u667a\u80fd\u6846\u67b6","text":""},{"location":"zh/ADAPTATION/adaptation/","title":"\u9002\u914d\u5c42","text":"<p>\u5173\u4e8e\u9002\u914d\u5c42</p> <p>\u9002\u914d\u5c42\u662f\u4e00\u4e2a\u4ecb\u4e8eMCU\u5e73\u53f0\u4e0eTinySHM\u4e4b\u95f4\u7684\u7f13\u51b2\u5c42\uff0c\u5176\u6838\u5fc3\u4f5c\u7528\u662f\u5c06\u5e73\u53f0\u7279\u6709\u7684\u90e8\u5206\u4e0eTinySHM\u4e2d\u5173\u4e8e\u8ba1\u7b97\u4e0e\u667a\u80fd\u7684\u90e8\u5206\u8fdb\u884c\u89e3\u8026\uff0c\u4ece\u800c\u65b9\u4fbfTinySHM\u7684\u8de8\u5e73\u53f0\u79fb\u690d\u4e0e\u5e94\u7528\u3002</p> <p>Warning</p> <p>\u76ee\u524d\u5f00\u53d1\u4ee5ESP32\u4e3a\u57fa\u7840\uff0c\u5411STM32\u7b49\u5e73\u53f0\u7684\u8fc1\u79fb\u9700\u8981\u5bf9\u9002\u914d\u5c42\u8fdb\u884c\u4e00\u5b9a\u7684\u4fee\u6539\u3002</p>"},{"location":"zh/ADAPTATION/adaptation/#esp32","title":"ESP32\u5b98\u65b9\u5e93\u7684\u652f\u6301","text":"<ul> <li> <p> ESP-DSP</p> <p>  \u5728\u7ebf\u6587\u6863 </p> </li> <li> <p> ESP-DL</p> <p>  Online Doc </p> </li> </ul>"},{"location":"zh/ADAPTATION/code/","title":"\u4ee3\u7801","text":"<p>\u6ce8\u610f</p> <p>\u4ee5\u4e0b\u4ee3\u7801\u5e94\u4ee5\u53d1\u5e03\u4ee3\u7801\u4e2d\u7684\u4ee3\u7801\u4e3a\u51c6\uff0c\u53ef\u80fd\u4f1a\u6709\u66f4\u65b0\u3002</p>"},{"location":"zh/ADAPTATION/log/","title":"\u5f00\u53d1\u65e5\u5fd7","text":"<p>2025-04-08</p> <ul> <li>\u8fd0\u884c\u65f6\u95f4\u67e5\u8be2\u51fd\u6570 tiny_get_running_time() </li> </ul>"},{"location":"zh/ADAPTATION/notes/","title":"\u8bf4\u660e","text":""},{"location":"zh/ADAPTATION/notes/#_2","title":"\u4f9d\u8d56","text":"<p>FreeRTOS</p> <pre><code>#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n</code></pre> <p>log</p> <pre><code>#include \"esp_log.h\"\n</code></pre> <p>timer</p> <pre><code>#include \"esp_timer.h\"\n</code></pre>"},{"location":"zh/ADAPTATION/notes/#_3","title":"\u8fd0\u884c\u65f6\u95f4\u67e5\u8be2","text":"<p>\u9996\u5148\u57fa\u4e8eESP32\u5e73\u53f0\u7684\u6570\u636e\u7c7b\u578b\u5b9a\u4e49\u4e86\u65b0\u7684\u6570\u636e\u7c7b\u578b</p> <pre><code>typedef TickType_t TinyTimeMark_t;\n</code></pre> <p>\u7136\u540e\u5728\u9002\u914d\u5c42\u4e2d\u5b9a\u4e49\u4e86\u4e00\u4e2a\u51fd\u6570\u7528\u4e8e\u83b7\u53d6\u5f53\u524d\u7684\u7cfb\u7edf\u81ea\u542f\u52a8\u540e\u7684\u8fd0\u884c\u65f6\u95f4\u6233\uff0c\u5355\u4f4d\u4e3a\u5fae\u79d2</p> <pre><code>TinyTimeMark_t tiny_get_running_time(void)\n{\n    return esp_timer_get_time();\n}\n</code></pre>"},{"location":"zh/AI/ai/","title":"\u4eba\u5de5\u667a\u80fd","text":""},{"location":"zh/ARCHITECTURE/architecture/","title":"\u67b6\u6784","text":""},{"location":"zh/ARCHITECTURE/architecture/#_2","title":"\u5206\u5c42\u67b6\u6784","text":"<pre><code>+------------------------------+\n| AI                           | &lt;-- \u57fa\u4e8e\u4f4e\u7ea7\u51fd\u6570\u7684\u8fb9\u7f18\u8bbe\u5907 AI/ML \u51fd\u6570\n+------------------------------+\n| DSP                          | &lt;-- \u6570\u5b57\u4fe1\u53f7\u5904\u7406\u51fd\u6570\n+------------------------------+\n| Math Operations              | &lt;-- \u5404\u79cd\u5e94\u7528\u7684\u5e38\u7528\u6570\u5b66\u51fd\u6570\n+------------------------------+\n| Adaptation Layer             | &lt;-- \u7528\u5e73\u53f0\u4f18\u5316/\u7279\u5b9a\u51fd\u6570\u66ff\u6362\u6807\u51c6 C \u4e2d\u7684\u51fd\u6570\n+------------------------------+\n</code></pre>"},{"location":"zh/ARCHITECTURE/architecture/#_3","title":"\u4ee3\u7801\u7ec4\u7ec7","text":"<pre><code>+------------------------------+\n| \u5e94\u7528\u5c42                        |\n|   - measurement              | &lt;-- \u6d4b\u91cf\n|   - system_identification    | &lt;-- \u7cfb\u7edf\u8bc6\u522b\n|   - damage detection         | &lt;-- \u635f\u4f24\u68c0\u6d4b,\u5b9a\u4f4d\u548c\u8bc4\u4f30\n+------------------------------+\n| \u4e2d\u95f4\u4ef6                        |\n|   - TinyAdapter              | &lt;-- \u5e73\u53f0\u5e95\u5c42\u4f18\u5316\n|   - TinyMath                 | &lt;-- \u5e38\u7528\u6570\u5b66\u51fd\u6570\n|   - TinyDSP                  | &lt;-- DSP \u51fd\u6570\n|   - TinyAI                   | &lt;-- AI \u51fd\u6570\n+------------------------------+\n| \u9a71\u52a8\u5c42                        |\n+------------------------------+\n| \u786c\u4ef6\u5c42                        |\n+------------------------------+\n</code></pre>"},{"location":"zh/DEVKITS/devkits/","title":"\u5f00\u53d1\u8f7d\u4f53","text":""},{"location":"zh/DEVKITS/devkits/#mcu","title":"\u7528\u4e8e\u5f00\u53d1\u7684MCU\u786c\u4ef6","text":"<ul> <li>Alientek \u7684 DNESP32S3M\uff08ESP32-S3\uff09</li> </ul>"},{"location":"zh/DEVKITS/devkits/#_2","title":"\u5f00\u53d1\u677f\u8bbe\u7f6e\u6307\u5357","text":"<ul> <li> <p> NexNode</p> <p>  \u4ee3\u7801 </p> <p>  \u6587\u6863 </p> </li> </ul>"},{"location":"zh/DSP/dsp/","title":"\u6570\u5b57\u4fe1\u53f7\u5904\u7406","text":""},{"location":"zh/MATH/math/","title":"\u6570\u5b66\u8fd0\u7b97","text":""},{"location":"zh/MEASUREMENT/code/","title":"\u4ee3\u7801","text":"<p>\u6ce8\u610f</p> <p>\u4ee5\u4e0b\u4ee3\u7801\u5e94\u4ee5\u53d1\u5e03\u4ee3\u7801\u4e2d\u7684\u4ee3\u7801\u4e3a\u51c6\uff0c\u53ef\u80fd\u4f1a\u6709\u66f4\u65b0\u3002</p>"},{"location":"zh/MEASUREMENT/log/","title":"\u5f00\u53d1\u65e5\u5fd7","text":"<p>2025-04-03</p> <ul> <li>\u91c7\u6837\u914d\u7f6e\u7ed3\u6784\u4f53</li> <li>\u91c7\u6837\u6570\u636e\u7ed3\u6784\u4f53</li> <li>\u5b9e\u65f6\u91c7\u6837\u51fd\u6570/\u5e38\u89c4\u91c7\u6837\u51fd\u6570</li> <li>\u91c7\u6837\u9891\u7387\u9891\u7387\u4e0a\u9650\u6d4b\u8bd5\uff1a\u5b9e\u65f6\uff0825Hz-\u672c\u5730\u8f93\u51fa+MQTT;200Hz-\u4ec5MQTT\uff09\uff1b\u5e38\u89c4 \uff08500Hz\uff09</li> <li>\u670d\u52a1\u7aef\u53ef\u89c6\u5316\u7a0b\u5e8f</li> <li>\u670d\u52a1\u7aef\u6570\u636e\u5b58\u50a8</li> </ul>"},{"location":"zh/MEASUREMENT/measurement/","title":"\u6d4b\u91cf","text":"<p>\u5173\u4e8e\u6d4b\u91cf</p> <p>\u9ad8\u8d28\u91cf\u6d4b\u91cf/\u91c7\u6837\u662f\u6570\u636e\u5206\u6790\u7684\u57fa\u7840\uff0cTinySHM\u5728\u8bbe\u8ba1\u65f6\u5145\u5206\u8003\u8651\u4e86\u8fd9\u4e00\u70b9\u3002\u6211\u4eec\u5728TinySHM\u4e2d\u5b9e\u73b0\u4e86\u591a\u79cd\u6d4b\u91cf/\u91c7\u6837\u65b9\u6cd5\uff0c\u7528\u6237\u53ef\u4ee5\u6839\u636e\u81ea\u5df1\u7684\u9700\u6c42\u8fdb\u884c\u9009\u62e9\u3002</p> <p>Warning</p> <p>\u76ee\u524d\u5f00\u53d1\u4ee5ESP32\u4e3a\u57fa\u7840\uff0c\u5411STM32\u7b49\u5e73\u53f0\u7684\u8fc1\u79fb\u9700\u8981\u5bf9\u9002\u914d\u5c42\u8fdb\u884c\u4e00\u5b9a\u7684\u4fee\u6539\u3002</p>"},{"location":"zh/MEASUREMENT/notes/","title":"\u8bf4\u660e","text":""},{"location":"zh/MEASUREMENT/notes/#_2","title":"\u4f9d\u8d56","text":"<p>SYSTEM</p> <pre><code>#include \"esp_system.h\" // ESP32 System\n#include \"esp_log.h\"    // ESP32 Logging\n</code></pre> <p>RTOS</p> <pre><code>#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/event_groups.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/timers.h\"\n#include \"freertos/semphr.h\"\n</code></pre> <p>BSP</p> <pre><code>#include \"driver/gptimer.h\"\n#include \"led.h\"\n#include \"lcd.h\"\n#include \"tim.h\"\n#include \"esp_rtc.h\"\n#include \"spi_sdcard.h\"\n#include \"wifi_wpa2_enterprise.h\"\n#include \"mqtt.h\"\n#include \"mpu6050.h\"\n</code></pre> <p>TinyAuton/TinySHM</p> <pre><code>#include \"TinyAdapter.h\"\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_3","title":"\u91c7\u6837\u914d\u7f6e\u7ed3\u6784\u4f53","text":"<p>\u5b9a\u4e49</p> <pre><code>struct SenseConfig\n{\n    int sample_rate;\n    int sample_duration;\n    bool temperature_sense; // whether to sense temperature\n    bool printout;          // not recommened for high sample rate as it will slow down the process\n    bool mqtt_pub;          // not recommened for high sample rate as it will slow down the process\n};\n</code></pre> <p>\u4f7f\u7528 - \u5b9e\u65f6</p> <pre><code>// for streamline configuration\nstruct SenseConfig streamline_config = {\n    .sample_rate = 1,          // Sample rate in Hz. For local printout + mqtt, at most 25Hz; for only mqtt, at most 200Hz.\n    .temperature_sense = true, // Whether to sense temperature\n    .printout = true,          // Only available for sampling rate &lt;= 100Hz\n    .mqtt_pub = true           // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre> <p>\u4f7f\u7528 - \u5e38\u89c4\u91c7\u6837</p> <pre><code>// for sensing configuration\nstruct SenseConfig sense_config = {\n    .sample_rate = 500,   // Sample rate in Hz, only can be (1, 2, 5, 10, 20, 25, 50, 100, 200, 500) for FreeRTOS based sensing. Note can not be 1000Hz (no time to feed the watchdog).\n    .sample_duration = 1, // Sample duration in seconds\n    .printout = true      // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_4","title":"\u91c7\u6837\u6570\u636e\u7ed3\u6784\u4f53","text":"<pre><code>struct DataStruct\n{\n    int sample_rate;\n    int sample_duration;\n    float sensor_temperature;\n    TinyTimeMark_t start_time_stamp;\n    TinyTimeMark_t *time_stamp;\n    float *acc_data;\n    float *temperature;\n};\n</code></pre> <p>\u4f7f\u7528</p> <pre><code>// for data structure\nstruct DataStruct data_struct = {\n    .sample_rate = 0,     // Sample rate in Hz\n    .sample_duration = 0, // Sample duration in seconds\n    .sensor_temperature = 0.0,\n    .start_time_stamp = 0,\n    .acc_data = NULL}; \n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_5","title":"\u91c7\u6837\u539f\u7406","text":"<p>\u76ee\u524d\u91c7\u6837**\u57fa\u4e8eFreeRTOS\u5faa\u73af**\u800c\u975e\u57fa\u4e8e**\u5b9a\u65f6\u5668\u4e2d\u65ad**\uff0c\u5b9e\u73b0\u7b80\u5355\uff0c\u672a\u6765\u6216\u8bb8\u4f1a\u6dfb\u52a0\u5b9a\u65f6\u5668\u4e2d\u65ad\u91c7\u6837\u7684\u65b9\u5f0f\u3002</p>"},{"location":"zh/MEASUREMENT/notes/#_6","title":"\u91c7\u6837\u6a21\u5f0f\u4e0e\u91c7\u6837\u4efb\u52a1","text":"<p>\u76ee\u524d\u5171\u6709\u4e24\u79cd\u91c7\u6837\u6a21\u5f0f\uff1a - \u5b9e\u65f6\u91c7\u6837 - \u5e38\u89c4\u91c7\u6837</p>"},{"location":"zh/MEASUREMENT/notes/#_7","title":"\u5b9e\u65f6\u91c7\u6837","text":"<p>\u91c7\u6837\u4efb\u52a1\u5b9a\u4e49</p> <pre><code>/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters)\n{\n\n    // streamline variables\n    float acc_x, acc_y, acc_z, temperature;\n    TinyTimeMark_t time_stamp;\n\n    // MQTT publish buffer\n    char streamline_buff[256];\n\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n\n    if (config-&gt;sample_rate &gt; 100 &amp;&amp; config-&gt;printout)\n    {\n        ESP_LOGW(TAG, \"Printout is disabled for sample rate &gt; 100Hz.\");\n        config-&gt;printout = false;\n    }\n\n    while (1)\n    {\n        // get the time stamp\n        time_stamp = tiny_get_running_time();\n\n        // get accelerometer data\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        acc_x = acce.acce_x;\n        acc_y = acce.acce_y;\n        acc_z = acce.acce_z;\n\n        // get temperature\n        mpu6050_get_temp(mpu6050, &amp;temp);\n        temperature = temp.temp;\n\n        // sprintf\n        if (config-&gt;printout || config-&gt;mqtt_pub)\n        {\n            snprintf(streamline_buff, sizeof(streamline_buff), \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Sensor Temperature: %4.2f \u00b0C\", time_stamp, acc_x, acc_y, acc_z, temperature);\n        }\n\n        // // print out the data\n        if (config-&gt;printout)\n        {\n            ESP_LOGI(TAG, \"%s\", streamline_buff);\n        }\n\n        // MQTT publish\n        if (config-&gt;mqtt_pub)\n        {\n            esp_mqtt_client_publish(s_mqtt_client, MQTT_PUBLIC_TOPIC, streamline_buff, strlen(streamline_buff), 0, 0); // for streamline, data quality is not expected to be high, so QoS = 0; data retaintion is also not required, so 0.\n        }\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n    ESP_LOGI(TAG, \"Streamline terminated. Task will delete itself.\");\n    vTaskDelete(NULL);\n}\n</code></pre> <p>\u91c7\u6837\u4efb\u52a1\u4f7f\u7528: \u5728\u5e94\u7528\u7a0b\u5e8f\u90e8\u5206\u521b\u5efa\u4efb\u52a1\u5373\u53ef</p> <pre><code>xTaskCreate(acc_streamline_task, \"Accel_Streamline_Task\", 4096, &amp;streamline_config, 5, NULL);\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_8","title":"\u5e38\u89c4\u91c7\u6837","text":"<p>\u91c7\u6837\u4efb\u52a1\u5b9a\u4e49</p> <pre><code>/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters)\n{\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n    int total_samples = config-&gt;sample_rate * config-&gt;sample_duration;\n\n    // Fill global data_struct\n    data_struct.sample_rate = config-&gt;sample_rate;\n    data_struct.sample_duration = config-&gt;sample_duration;\n    mpu6050_get_temp(mpu6050, &amp;temp);\n    data_struct.sensor_temperature = temp.temp;\n    data_struct.start_time_stamp = tiny_get_running_time();\n\n    // Allocate memory\n    data_struct.acc_data = malloc(sizeof(float) * 3 * total_samples);\n    data_struct.temperature = malloc(sizeof(float) * total_samples);\n    data_struct.time_stamp = malloc(sizeof(TinyTimeMark_t) * total_samples);\n\n    if (data_struct.acc_data == NULL || data_struct.temperature == NULL || data_struct.time_stamp == NULL)\n    {\n        ESP_LOGE(TAG, \"Failed to allocate memory for sensing data.\");\n        if (data_struct.acc_data)\n            free(data_struct.acc_data);\n        if (data_struct.temperature)\n            free(data_struct.temperature);\n        if (data_struct.time_stamp)\n            free(data_struct.time_stamp);\n        vTaskDelete(NULL);\n    }\n\n    ESP_LOGI(TAG, \"Sampling started: %d Hz for %d seconds (%d samples)\",\n             config-&gt;sample_rate, config-&gt;sample_duration, total_samples);\n\n    for (int i = 0; i &lt; total_samples; i++)\n    {\n        TinyTimeMark_t now = tiny_get_running_time();\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        mpu6050_get_temp(mpu6050, &amp;temp);\n\n        // Store data\n        data_struct.time_stamp[i] = now;\n        data_struct.acc_data[i * 3 + 0] = acce.acce_x;\n        data_struct.acc_data[i * 3 + 1] = acce.acce_y;\n        data_struct.acc_data[i * 3 + 2] = acce.acce_z;\n        data_struct.temperature[i] = temp.temp;\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n\n    ESP_LOGI(TAG, \"Sampling complete.\");\n\n    // Print metadata\n    ESP_LOGI(TAG, \"-----------------------------\");\n    ESP_LOGI(TAG, \"Sensor Temperature : %.2f \u00b0C\", data_struct.sensor_temperature);\n    ESP_LOGI(TAG, \"Start Time Stamp   : %ld\", (long)data_struct.start_time_stamp);\n    ESP_LOGI(TAG, \"Sample Rate        : %d Hz\", data_struct.sample_rate);\n    ESP_LOGI(TAG, \"Sample Duration    : %d sec\", data_struct.sample_duration);\n    ESP_LOGI(TAG, \"Total Samples      : %d\", total_samples);\n    ESP_LOGI(TAG, \"Data Size          : %.2f KB\",\n             (sizeof(float) * 4 + sizeof(TinyTimeMark_t)) * total_samples / 1024.0f);\n    ESP_LOGI(TAG, \"-----------------------------\");\n\n    // Print collected data if enabled\n    if (config-&gt;printout)\n    {\n        for (int i = 0; i &lt; total_samples; i++)\n        {\n            ESP_LOGI(TAG, \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Temperature: %.2f \u00b0C\",\n                     (long)data_struct.time_stamp[i],\n                     data_struct.acc_data[i * 3 + 0],\n                     data_struct.acc_data[i * 3 + 1],\n                     data_struct.acc_data[i * 3 + 2],\n                     data_struct.temperature[i]);\n\n            // Release CPU for a short time to avoid blocking\n            if ((i % 10) == 0)\n            {\n                vTaskDelay(pdMS_TO_TICKS(10));\n            }\n        }\n    }\n\n    // Free allocated memory\n    if (data_struct.acc_data)\n    {\n        free(data_struct.acc_data);\n        data_struct.acc_data = NULL;\n    }\n    if (data_struct.temperature)\n    {\n        free(data_struct.temperature);\n        data_struct.temperature = NULL;\n    }\n    if (data_struct.time_stamp)\n    {\n        free(data_struct.time_stamp);\n        data_struct.time_stamp = NULL;\n    }\n\n    vTaskDelete(NULL);\n}\n</code></pre> <p>\u91c7\u6837\u4efb\u52a1\u4f7f\u7528: \u5728\u5e94\u7528\u7a0b\u5e8f\u90e8\u5206\u521b\u5efa\u4efb\u52a1\u5373\u53ef</p> <pre><code>xTaskCreate(acc_sense_task, \"Accel_Sense_Task\", 8192, &amp;sense_config, 5, NULL);\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_9","title":"\u5f85\u5f00\u53d1","text":"<ul> <li>\u6807\u51c6\u65f6\u95f4\u6233</li> <li>\u6821\u51c6</li> <li>\u5b9a\u65f6\u5668+\u4e2d\u65ad</li> <li>DMA</li> <li>ADC+\u6a21\u62df</li> <li>\u6570\u636e\u540e\u5904\u7406</li> <li>\u6279\u91cf\u6570\u636eMQTT\u4e0a\u4f20</li> <li>\u5b9e\u65f6\u5904\u7406\u529f\u80fd\u5f00\u53d1</li> </ul>"},{"location":"zh/RELEASES/releases/","title":"\u53d1\u5e03","text":""},{"location":"zh/RELEASES/releases/#dnesp32s3m-stable","title":"DNESP32S3M-STABLE","text":"<p>\u7a33\u5b9a\u7248</p>"},{"location":"zh/RELEASES/releases/#dnesp32s3m-latest","title":"DNESP32S3M-LATEST","text":"<p>\u6700\u65b0\u529f\u80fd\u7248</p>"}]}