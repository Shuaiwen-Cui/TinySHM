{"config":{"lang":["en","zh"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TinySHM: Microcontroller-oriented Distributed Intelligence Enabling Framework for Structural Health Monitoring","text":""},{"location":"#about-this-project","title":"ABOUT THIS PROJECT","text":"<p>This project aims to develop an empowering framework that equips MCU-level IoT devices with distributed computing and intelligence capabilities to facilitate structural health monitoring applications. If you think this project is interesting, please give it a star and stay tuned.</p> <p>TinySHM</p> <p>\"TinySHM\" is a combination of \"Tiny\" and \"SHM\". \"Tiny\" means the codes are designed to run on MCU devices, while \"SHM\" stands for \"Structural Health Monitoring\".</p>"},{"location":"#target-hardware","title":"TARGET HARDWARE","text":"<ul> <li>MCU devices (ESP32 as the main target)</li> </ul>"},{"location":"#scope","title":"SCOPE","text":"<ul> <li>Platform adaptation and various tools (time, communication, etc.)</li> <li>Basic Math Operations</li> <li>Digital Signal Processing</li> <li>TinyML / Edge AI</li> <li>Measurement</li> <li>System Identification</li> <li>Damage Monitoring, Localization, and Assessment</li> </ul>"},{"location":"ABOUT/about/","title":"TinySHM: Microcontroller-oriented Distributed Intelligence Enabling Framework for Structural Health Monitoring","text":""},{"location":"ABOUT/about/#project-overview","title":"PROJECT OVERVIEW","text":"<p>This project aims to develop an empowering framework that equips MCU-level IoT devices with distributed computing and intelligence capabilities to facilitate structural health monitoring applications. If you think this project is interesting, please give it a star and stay tuned.</p> <p>TinySHM</p> <p>\"TinySHM\" is a combination of \"Tiny\" and \"SHM\". \"Tiny\" means the codes are designed to run on MCU devices, while \"SHM\" stands for \"Structural Health Monitoring\".</p>"},{"location":"ABOUT/about/#target-hardware","title":"TARGET HARDWARE","text":"<ul> <li>MCU devices (currently targeting ESP32 as the main platform)</li> </ul>"},{"location":"ABOUT/about/#scope","title":"SCOPE","text":"<ul> <li>Platform adaptation and various tools (time, communication, etc.)</li> <li>Basic Math Operations</li> <li>Digital Signal Processing</li> <li>TinyML / Edge AI</li> <li>Measurement</li> <li>System Identification</li> <li>Damage Monitoring, Localization, and Assessment</li> </ul>"},{"location":"ABOUT/about/#host-devkits","title":"HOST DEVKITS","text":"<p>Tip</p> <p>The following hardwares are for demonstration purposes only. This project is not limited to these and can be ported to other types of hardwares.</p> <ul> <li>DNESP32S3M from Alientek (ESP32-S3)</li> </ul> <p></p> <p></p> <ul> <li> <p> NexNode</p> <p>  Repo </p> <p>  Online Doc </p> </li> </ul>"},{"location":"ABOUT/about/#project-architecture","title":"PROJECT ARCHITECTURE","text":"<pre><code>+------------------------------+\n| APPLICATION                  |\n|   - measurement              | &lt;-- measurement / sensing\n|   - system_identification    | &lt;-- system identification\n|   - damage_detection         | &lt;-- damage detection, localization, and assessment\n+------------------------------+\n| MIDDLEWARE                   |\n|   - TinyToolbox              | &lt;-- Platform-specific Low-level Optimization + Various Utilities\n|   - TinyMath                 | &lt;-- Common Math Functions\n|   - TinyDSP                  | &lt;-- DSP Functions\n|   - TinyAI                   | &lt;-- AI Functions\n+------------------------------+\n| DRIVERS                      |\n+------------------------------+\n| HARDWARE                     |\n+------------------------------+\n</code></pre>"},{"location":"AI/ai/","title":"ARTIFICIAL INTELLIGENCE","text":"<ul> <li> <p> ESP-DL</p> <p>  Online Doc </p> </li> </ul>"},{"location":"DSP/dsp/","title":"DIGITAL SIGNAL PROCESSING","text":""},{"location":"MATH/math/","title":"MATH OPERATIONS","text":"<p>Note</p> <p>This component is designed for mathematical operations. It is a lightweight library that provides basic mathematical functions to facilitate onboard computation and AI model inference. The library is designed to be lightweight and efficient, making it suitable for edge computing applications.</p> <p>Note</p> <p>This component is a wrapper and extension of the official ESP32 digital signal processing library ESP-DSP, providing higher-level API interfaces. In simple terms, the TinyMath library corresponds to the Math, Matrix, and DotProduct modules in ESP-DSP, while the other modules in ESP-DSP correspond to the TinyDSP library.</p>"},{"location":"MATH/math/#component-dependencies","title":"COMPONENT DEPENDENCIES","text":"<pre><code>set(src_dirs\n    .\n    vec\n    mat\n)\n\nset(include_dirs\n    .\n    include\n    vec\n    mat\n)\n\nset(requires\n    tiny_toolbox\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"MATH/math/#architecture-and-directory","title":"ARCHITECTURE AND DIRECTORY","text":""},{"location":"MATH/math/#dependency-diagram","title":"Dependency Diagram","text":""},{"location":"MATH/math/#code-tree","title":"Code Tree","text":"<pre><code>TinyMath\n    \u251c\u2500\u2500 CMakeLists.txt\n    \u251c\u2500\u2500 include\n    |   \u251c\u2500\u2500 tiny_error_type.h // error type header file\n    |   \u251c\u2500\u2500 tiny_constant.h // constant header file\n    |   \u251c\u2500\u2500 tiny_math_config.h // configuration header file\n    |   \u2514\u2500\u2500 tiny_math.h // main header file, include this file where you want to use the library\n    \u251c\u2500\u2500 vec\n    |   \u251c\u2500\u2500 tiny_vec.h // vector header file\n    |   \u251c\u2500\u2500 tiny_vec.c // vector source file\n    |   \u251c\u2500\u2500 tiny_vec_test.c // vector test file\n    |   \u2514\u2500\u2500 tiny_vec_test.h // vector test header file\n    \u251c\u2500\u2500 mat\n    |   \u251c\u2500\u2500 tiny_mat.h // matrix header file - c\n    |   \u251c\u2500\u2500 tiny_mat.c // matrix source file - c\n    |   \u251c\u2500\u2500 tiny_mat_test.c // matrix test file - c \n    |   \u251c\u2500\u2500 tiny_mat_test.h // matrix test header file - c\n    |   \u251c\u2500\u2500 tiny_matrix.hpp // matrix header file - cpp\n    |   \u251c\u2500\u2500 tiny_matrix.cpp // matrix source file - cpp\n    |   \u251c\u2500\u2500 tiny_matrix_test.cpp // matrix test file - cpp\n    |   \u2514\u2500\u2500 tiny_matrix_test.hpp // matrix test header file - cpp\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"MATH/ESP-DSP/esp-dsp/","title":"ESP-DSP","text":"<ul> <li> <p> ESP-DSP</p> <p>An Espressif DSP Library (esp-dsp) it\u2019s library of functions, modules and components that provides possibility to use Espressif\u2019s CPUs as DSPs in efficient way.</p> <p>  Online Doc </p> </li> </ul>"},{"location":"MATH/ESP-DSP/esp-dsp/#function-naming","title":"Function Naming","text":"<p>Naming conventions for the Library functions are similar for all covered domains. You can distinguish signal processing functions by the dsps prefix, while image and video processing functions have dspi prefix, and functions that are specific for operations on small matrices have dspm prefix in their names. Function names in Library have the following general format:</p> <pre><code>dsp&lt;data-domain&gt;_&lt;name&gt;_&lt;datatype1&gt;&lt;datatype_ext&gt;_&lt;datatype2&gt;&lt;datatype_ext&gt;[_&lt;descriptor&gt;]&lt;_impl&gt;(&lt;parameters&gt;);\n</code></pre> <p>Where:</p> <ul> <li> <p><code>&lt;data-domain&gt;</code> is the domain of the function, e.g. <code>s</code> for signal processing, <code>i</code> for image processing, <code>v</code> for video processing, and <code>m</code> for small matrix operations.</p> </li> <li> <p><code>&lt;name&gt;</code> is the name of the function.</p> </li> <li> <p><code>&lt;datatype1&gt;</code> is the type of the first input parameter.</p> </li> <li> <p><code>&lt;datatype_ext&gt;</code> is the type of the first input parameter extended with a suffix that indicates the type of the data, e.g. <code>f</code> for float, <code>i</code> for integer, <code>c</code> for complex, etc.</p> </li> <li> <p><code>&lt;datatype2&gt;</code> is the type of the second input parameter.</p> </li> <li> <p><code>&lt;descriptor&gt;</code> is an optional descriptor that provides additional information about the function.</p> </li> <li> <p><code>&lt;impl&gt;</code> is an optional implementation descriptor that provides additional information about the implementation of the function.</p> </li> <li> <p><code>&lt;parameters&gt;</code> are the parameters of the function.</p> </li> </ul>"},{"location":"MATH/ESP-DSP/esp-dsp/#data-domain","title":"Data Domain","text":"<p>The data-domain is a single character that expresses the subset of functionality to which a given function belongs. The Library designed to supports the following data-domains:</p> <ul> <li> <p>s - for signals (expected data type is a 1D signal)</p> </li> <li> <p>i - for images and video (expected data type is a 2D image)</p> </li> <li> <p>m - for matrices (expected data type is a matrix)</p> </li> <li> <p>r - for realistic rendering functionality and 3D data processing (expected data type depends on supported rendering techniques)</p> </li> <li> <p>q - for signals of fixed length</p> </li> </ul> <p>For example, function names that begin with dspi signify that respective functions are used for image or video processing.</p>"},{"location":"MATH/ESP-DSP/esp-dsp/#name","title":"Name","text":"<p>The name is an abbreviation for the core operation that the function really does, for example Add, Sqrt, followed in some cases by a function-specific modifier: = [_modifier]</p> <p>This modifier, if present, denotes a slight modification or variation of the given function.</p>"},{"location":"MATH/ESP-DSP/esp-dsp/#data-types","title":"Data Types","text":"<p>The library supports two main data types \u2013 int16 for fixed point arithmetic and float for floating point arithmetic. The datatype described as:</p>"},{"location":"MATH/ESP-DSP/esp-dsp/#data-type-suffices","title":"Data type suffices:","text":"<ul> <li> <p>s - signed</p> </li> <li> <p>u - unsigned</p> </li> <li> <p>f - float</p> </li> </ul>"},{"location":"MATH/ESP-DSP/esp-dsp/#data-type-extensions","title":"Data type extensions:","text":"<ul> <li>c - complex</li> </ul>"},{"location":"MATH/ESP-DSP/esp-dsp/#data-type-bits-resolution","title":"Data type Bits resolution:","text":"<ul> <li> <p>16</p> </li> <li> <p>32</p> </li> </ul> <p>For example: dsps_mac_sc16 defines that mac operation with 1d array will be made with 16 bit signed complex data.</p>"},{"location":"MATH/ESP-DSP/esp-dsp/#implementation-type","title":"Implementation Type","text":"<p>Each function could be implemented different for different platform and could use different style and resources. That\u2019s why every implemented function will have name extension &lt;_impl&gt; that will define which kind of implementation it is. User can use universal function without extension.</p>"},{"location":"MATH/ESP-DSP/esp-dsp/#implementation-extensions","title":"Implementation extensions:","text":"<p>By default all functions could be used without extensions. The option that select optimized/ansi can be chosen in menuconfig.</p> <p>Inside library the extensions means:</p> <ul> <li> <p>_ansi - a universal function where body of function implemented on ANSI C. This implementation not includes any hardware optimization</p> </li> <li> <p>_ae32 - written on ESP32 assembler and optimized for ESP32</p> </li> <li> <p>_aes3 - written on ESP32S3 assembler and optimized for ESP32S3</p> </li> <li> <p>_arp4 - written on ESP32P4 assembler and optimized for ESP32P4</p> </li> <li> <p>_platform - header file with definitions of available CPUs instructions for different functions</p> </li> <li> <p>others- depends on amount of supported CPUs. This list will be extended in future</p> </li> </ul>"},{"location":"MATH/ESP-DSP/examples/","title":"ESP-DSP EXAMPLES","text":""},{"location":"MATH/ESP-DSP/examples/#list-of-esp-dsp-examples","title":"List of esp-dsp Examples","text":"<p>Signal processing APIs use dsps prefix. The following modules are available:</p> <ul> <li> <p>Basic math - the example shows how to use basic vector math operations</p> </li> <li> <p>Dot-product - the example demonstrates how to use dot product functions</p> </li> <li> <p>FFT - the example demonstrates how to use FFT functionality</p> </li> <li> <p>FFT Window - the example demonstrates how to use Window and FFT functionality</p> </li> <li> <p>FFT 4 Real - the example demonstrates how to use FFT functionality for real input signals</p> </li> <li> <p>IIR - the example demonstrates how to use IIR filters functionality</p> </li> <li> <p>FIR - the example demonstrates how to use FIR filter functionality</p> </li> <li> <p>Kalman Filter - Extended Kalman Filter (EKF) example</p> </li> <li> <p>Matrix - example demonstrates how to use Mat class functionality</p> </li> </ul>"},{"location":"MATH/ESP-DSP/examples/#basic-math","title":"Basic math","text":"<p>This example demonstrates how to use basic math functions from esp-dsp library. The example does the following steps:</p> <ul> <li> <p>Initialize the library</p> </li> <li> <p>Initialize input signals with 1024 samples</p> </li> <li> <p>Apply window to input signal by standard C loop.</p> </li> <li> <p>Calculate FFT for 1024 complex samples and show the result</p> </li> <li> <p>Show results on the plots</p> </li> <li> <p>Apply window to input signal by basic math functions dsps_mul_f32 and dsps_mulc_f32.</p> </li> <li> <p>Calculate FFT for 1024 complex samples</p> </li> <li> <p>Show results on the plots</p> </li> </ul> <p>For more details please look to the examples/basic_math/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#dot-product","title":"Dot-product","text":"<p>The example demonstrates how to use dotprod dsps_dotprod_f32 from esp-dsp library. Example does the following steps:</p> <ul> <li> <p>Initialize the input arrays</p> </li> <li> <p>Calculate dot product of two arrays</p> </li> <li> <p>Compare results and calculate execution time in cycles.</p> </li> </ul> <p>For more details please look to the examples/dotprod/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#fft","title":"FFT","text":"<p>This example demonstrates how to use FFT functionality from esp-dsp library. Example does the following steps:</p> <ul> <li> <p>Initialize the library</p> </li> <li> <p>Initialize input signals with 1024 samples: one 0 dB, second with -20 dB</p> </li> <li> <p>Combine two signals as one complex input signal and apply window to input signals paar.</p> </li> <li> <p>Calculate FFT for 1024 complex samples</p> </li> <li> <p>Apply bit reverse operation for output complex vector</p> </li> <li> <p>Split one complex FFT output spectrum to two real signal spectrums</p> </li> <li> <p>Show results on the plots</p> </li> <li> <p>Show execution time of FFT</p> </li> </ul> <p>For more details please look to the examples/fft/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#fft-window","title":"FFT Window","text":"<p>This example demonstrates how to use Window and FFT functionality from esp-dsp library. Example does the following steps:</p> <ul> <li> <p>Initialize the library</p> </li> <li> <p>Initialize input signals with 1024 samples</p> </li> <li> <p>Apply window to input signal.</p> </li> <li> <p>Calculate FFT for 1024 complex samples</p> </li> <li> <p>Apply bit reverse operation for output complex vector</p> </li> <li> <p>Split one complex FFT output spectrum to two real signal spectrums</p> </li> <li> <p>Show results on the plots</p> </li> </ul> <p>For more details please look to the examples/fft_window/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#fft-4-real","title":"FFT 4 Real","text":"<p>This example demonstrates how to use FFT functionality from esp-dsp library. Example does the following steps:</p> <ul> <li> <p>Initialize the library</p> </li> <li> <p>Initialize input signals with 1024 samples: one 0 dB, second with -20 dB</p> </li> <li> <p>Calculate FFT Radix-2 for 1024 complex samples</p> </li> <li> <p>Calculate FFT Radix-4 for 1024 complex samples</p> </li> <li> <p>Apply bit reverse operation for output complex vectors</p> </li> <li> <p>Show results on the plots</p> </li> <li> <p>Show execution time of FFTs</p> </li> </ul> <p>For more details please look to the examples/fft4real/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#iir","title":"IIR","text":"<p>This example demonstrates how to use IIR filters functionality from esp-dsp library. Example does the following steps:</p> <ul> <li> <p>Initialize the library</p> </li> <li> <p>Initialize input signal</p> </li> <li> <p>Show LPF filter with Q factor 1</p> <ul> <li> <p>Calculate iir filter coefficients</p> </li> <li> <p>Filter the input test signal (delta function)</p> </li> <li> <p>Shows impulse response on the plot</p> </li> <li> <p>Shows frequency response on the plot</p> </li> </ul> </li> <li> <p>Calculate execution performance</p> </li> <li> <p>The same for LPF filter with Q factor 10</p> </li> </ul> <p>For more details please look to the examples/fir/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#fir","title":"FIR","text":"<p>This example demonstrates how to use FIR filter functionality from esp-dsp library. Example does the following steps:</p> <ul> <li> <p>Initialize the FFT library</p> </li> <li> <p>Initialize input signal</p> </li> <li> <p>Show input signal</p> </li> <li> <p>Show filtered signal</p> </li> </ul> <p>For more details please look to the examples/fir/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#kalman-filter","title":"Kalman Filter","text":"<p>This example emulate system with IMU sensors and show how to use Extended Kalman Filter (EKF), with 13 values states vector, to estimate gyroscope errors and calculate system attitude. Also, this example show how to use esp-dsp library to operate with matrices and vectors.</p> <p>In real system, the emulated sensors values should be replace by the real sensors values. Then, in real system, a calibration phase should be implemented and after the calibration phase the state vector X and covariance matrix P should be saved and restored next time, when filter called. It will save time for initial phase.</p> <p>For more details please look to the examples/kalman/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#matrix","title":"Matrix","text":"<p>This example demonstrates how to use Mat class functionality from esp-dsp library. Example does the following steps:</p> <ul> <li> <p>Initialize a matrix A and matirx x</p> </li> <li> <p>Calculate matrix b: b = A*x</p> </li> <li> <p>Find roots x1: A*x1 = b, with different methods</p> </li> <li> <p>Print result</p> </li> </ul>"},{"location":"MATH/HEADER-FILE/tiny_constants/","title":"CONSTANTS","text":"<p>Info</p> <p>This file contains the definition of some constants, which are used for upper-level calculations and applications. The documentation update speed is slow and may not be consistent with the actual code. Please refer to the code for accuracy.</p> <pre><code>/**\n * @file tiny_constants.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file contains the constants used in the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n */\n\n#ifndef __TINY_CONSTANTS_H__\n#define __TINY_CONSTANTS_H__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n// =======================================\n//  Logical Constants\n// =======================================\n#ifndef TRUE\n#define TRUE 1\n#endif\n\n#ifndef FALSE\n#define FALSE 0\n#endif\n\n#ifndef NULL\n#define NULL ((void *)0)\n#endif\n\n// =======================================\n//  Math Constants (float/double safe)\n// =======================================\n#define TINY_PI 3.14159265358979323846f\n#define TINY_TWO_PI 6.28318530717958647692f\n#define TINY_HALF_PI 1.57079632679489661923f\n#define TINY_E 2.71828182845904523536f\n#define TINY_SQRT2 1.41421356237309504880f\n#define TINY_INV_SQRT2 0.70710678118654752440f\n\n#define TINY_DEG2RAD(x) ((x) * TINY_PI / 180.0f)\n#define TINY_RAD2DEG(x) ((x) * 180.0f / TINY_PI)\n\n// =======================================\n//  Bitmask &amp; Bit Manipulation\n// =======================================\n\n// Bitwise operations\n#define TINY_BIT(n) (1U &lt;&lt; (n)) // e.g. TINY_BIT(3) = 0b00001000\n#define TINY_BIT_SET(x, n) ((x) |= TINY_BIT(n))\n#define TINY_BIT_CLEAR(x, n) ((x) &amp;= ~TINY_BIT(n))\n#define TINY_BIT_TOGGLE(x, n) ((x) ^= TINY_BIT(n))\n#define TINY_BIT_CHECK(x, n) (((x) &gt;&gt; (n)) &amp; 0x1U)\n\n// Common bit masks\n#define TINY_MASK_4BIT 0x0FU\n#define TINY_MASK_8BIT 0xFFU\n#define TINY_MASK_16BIT 0xFFFFU\n#define TINY_MASK_32BIT 0xFFFFFFFFU\n\n// =======================================\n//  Fixed-Point Scaling Factors\n// =======================================\n#define TINY_Q7_SCALE 128          // 2^7\n#define TINY_Q15_SCALE 32768       // 2^15\n#define TINY_Q31_SCALE 2147483648U // 2^31\n\n// =======================================\n//  User-Defined Constants (Optional)\n// =======================================\n#define TINY_MATH_MIN_DENOMINATOR 1e-6f // Minimum denominator for safe division\n#define TINY_MATH_MIN_POSITIVE_INPUT_F32 1e-12f // Minimum positive input for float operations\n\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_CONSTANTS_H__ */\n</code></pre>"},{"location":"MATH/HEADER-FILE/tiny_error_type/","title":"ERROR TYPES DEFINITION","text":"<p>Info</p> <p>This file defines some common error types in calculations to assist in determining the cause of errors. The documentation update speed is slow and may not match the actual code, please refer to the code for accuracy.</p> <pre><code>/**\n * @file tiny_error_type.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief The configuration file for the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_ERROR_TYPE__\n#define __TINY_ERROR_TYPE__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* TYPE DEFINITIONS */\ntypedef int tiny_error_t; // Error type for the tiny_math middleware\n\n/* MACROS */\n/* Definitions for error constants. */\n#define TINY_OK          0       /*!&lt; tiny_err_t value indicating success (no error) */\n#define TINY_FAIL        -1      /*!&lt; Generic tiny_err_t code indicating failure */\n\n#define TINY_ERR_NO_MEM              0x101   /*!&lt; Out of memory */\n#define TINY_ERR_INVALID_ARG         0x102   /*!&lt; Invalid argument */\n#define TINY_ERR_INVALID_STATE       0x103   /*!&lt; Invalid state */\n#define TINY_ERR_INVALID_SIZE        0x104   /*!&lt; Invalid size */\n#define TINY_ERR_NOT_FOUND           0x105   /*!&lt; Requested resource not found */\n#define TINY_ERR_NOT_SUPPORTED       0x106   /*!&lt; Operation or feature not supported */\n#define TINY_ERR_TIMEOUT             0x107   /*!&lt; Operation timed out */\n#define TINY_ERR_INVALID_RESPONSE    0x108   /*!&lt; Received response was invalid */\n#define TINY_ERR_INVALID_CRC         0x109   /*!&lt; CRC or checksum was invalid */\n#define TINY_ERR_INVALID_VERSION     0x10A   /*!&lt; Version was invalid */\n#define TINY_ERR_INVALID_MAC         0x10B   /*!&lt; MAC address was invalid */\n#define TINY_ERR_NOT_FINISHED        0x10C   /*!&lt; Operation has not fully completed */\n#define TINY_ERR_NOT_ALLOWED         0x10D   /*!&lt; Operation is not allowed */\n\n#define TINY_ERR_WIFI_BASE           0x3000  /*!&lt; Starting number of WiFi error codes */\n#define TINY_ERR_MESH_BASE           0x4000  /*!&lt; Starting number of MESH error codes */\n#define TINY_ERR_FLASH_BASE          0x6000  /*!&lt; Starting number of flash error codes */\n#define TINY_ERR_HW_CRYPTO_BASE      0xc000  /*!&lt; Starting number of HW cryptography module error codes */\n#define TINY_ERR_MEMPROT_BASE        0xd000  /*!&lt; Starting number of Memory Protection API error codes */\n\n#define TINY_ERR_MATH_BASE                0x70000\n#define TINY_ERR_MATH_INVALID_LENGTH      (TINY_ERR_MATH_BASE + 1)\n#define TINY_ERR_MATH_INVALID_PARAM       (TINY_ERR_MATH_BASE + 2)\n#define TINY_ERR_MATH_PARAM_OUTOFRANGE    (TINY_ERR_MATH_BASE + 3)\n#define TINY_ERR_MATH_UNINITIALIZED       (TINY_ERR_MATH_BASE + 4)\n#define TINY_ERR_MATH_REINITIALIZED       (TINY_ERR_MATH_BASE + 5)\n#define TINY_ERR_MATH_ARRAY_NOT_ALIGNED   (TINY_ERR_MATH_BASE + 6)\n#define TINY_ERR_MATH_NULL_POINTER        (TINY_ERR_MATH_BASE + 7)\n#define TINY_ERR_MATH_ZERO_DIVISION       (TINY_ERR_MATH_BASE + 8)\n#define TINY_ERR_MATH_NEGATIVE_SQRT        (TINY_ERR_MATH_BASE + 9)\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_ERROR_TYPE__ */\n</code></pre>"},{"location":"MATH/HEADER-FILE/tiny_math/","title":"TinyMath HEADER FILE","text":"<p>Info</p> <p>This is the main header file of the TinyMath library. It includes all necessary header files and provides a unified interface to use the functions of the library. After completing the porting of this library in the project, you can insert this header file where you want to use the relevant functions to use all functions in the library. The documentation update speed is slow and may not be consistent with the actual code, please refer to the actual code.</p> <pre><code>/**\n * @file tiny_math.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the tiny_math middleware.\n * @version 1.0\n * @date 2025-03-26\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_MATH__\n#define __TINY_MATH__\n\n/* DEPENDENCIES */\n\n// this layer\n#include \"tiny_math_config.h\"\n\n/* SUBMODULES */\n\n// vector operations\n#include \"tiny_vec.h\"\n\n// matrix operations\n#include \"tiny_mat.h\"\n\n// advanced matrix operations\n#ifdef __cplusplus\n\n#include \"tiny_matrix.hpp\"\n\n#endif\n\n/* TEST */ // NOTE: test files are platform specific and should not be included in the library\n\n// vector operations\n#include \"tiny_vec_test.h\"\n\n// matrix operations\n#include \"tiny_mat_test.h\"\n\n// advanced matrix operations\n#ifdef __cplusplus\n\n#include \"tiny_matrix_test.hpp\"\n\n#endif\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_MATH__ */\n</code></pre>"},{"location":"MATH/HEADER-FILE/tiny_math_config/","title":"TinyMath CONFIGURATION","text":"<p>Info</p> <p>This header file serves to configure the entire TinyMath module, and each submodule includes this header file. It defines the configuration options and macros for TinyMath, allowing users to customize settings as needed. By modifying the configuration options in this header file, users can easily adjust the behavior and functionality of TinyMath to meet specific requirements. The documentation may be updated slowly and may not match the actual code, so please refer to the code for accuracy.</p> <p>Tip</p> <p>This component includes macro definitions for selecting platforms, allowing users to choose different platforms for compilation as needed. By switching to the corresponding platform macro, users can leverage platform acceleration features to enhance performance. For example, for the ESP32 platform, TinyMath will automatically select the ESP32 DSP library for compilation, achieving more efficient mathematical operations.</p> <pre><code>/**\n * @file tiny_math_config.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief The configuration file for the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-14\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_MATH_CONFIG__\n#define __TINY_MATH_CONFIG__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* DEPENDENCIES */\n\n// ANSI C\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdint.h&gt;\n\n// lower level\n#include \"tiny_toolbox.h\"\n\n// this level\n#include \"tiny_error_type.h\"\n#include \"tiny_constants.h\"\n\n/* PLATFORM SELECTION */\n\n// available platforms\n#define MCU_PLATFORM_GENERIC     0\n#define MCU_PLATFORM_ESP32       1 // here, we utilize the ESP built-in DSP library, it will automatically select the optimized version\n#define MCU_PLATFORM_STM32       2\n#define MCU_PLATFORM_RISCV       3\n\n// choose one platform\n#define MCU_PLATFORM_SELECTED    MCU_PLATFORM_ESP32\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_MATH_CONFIG__ */\n</code></pre>"},{"location":"MATH/MATRIX/tiny-mat-api/","title":"MATRIX OPERATIONS - TINY_MAT","text":"<p>About tiny_mat library</p> <p>tiny_mat is a C implementation of a matrix library that provides basic matrix operation functions. It supports operations such as addition, subtraction, and multiplication of floating-point matrices. This library is suitable for embedded systems and real-time applications that require matrix calculations. The library is based on the ANSI C standard, ensuring good portability and performance, while also supporting platform acceleration through configuration files (ESP32).</p> <p>About the usage of tiny_mat library</p> <p>The functionality of tiny_mat is completely covered by tiny_matrix, which means that the functions in tiny_matrix include all the functions of tiny_mat. For simple matrix operations, you can only include the tiny_mat library; for complex matrix operations, it is recommended to use the tiny_matrix library. The tiny_matrix library is a C++ implementation of a matrix library that provides richer functionality and better performance. It supports operations such as addition, subtraction, multiplication, transposition, and inversion of floating-point and integer matrices.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#list-of-functions","title":"LIST OF FUNCTIONS","text":"<pre><code>TinyMath\n    \u251c\u2500\u2500Vector\n    \u2514\u2500\u2500Matrix\n        \u251c\u2500\u2500 tiny_mat (c) &lt;---\n        \u2514\u2500\u2500 tiny_matrix (c++)\n</code></pre> <pre><code>// print matrix\nvoid print_matrix(const char *name, const float *mat, int rows, int cols);\n// print matrix padded (row-major)\nvoid print_matrix_padded(const char *name, const float *mat, int rows, int cols, int step);\n// addition\ntiny_error_t tiny_mat_add_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\ntiny_error_t tiny_mat_addc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n// subtraction\ntiny_error_t tiny_mat_sub_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\ntiny_error_t tiny_mat_subc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n// multiplication\ntiny_error_t tiny_mat_mult_f32(const float *A, const float *B, float *C, int m, int n, int k);\ntiny_error_t tiny_mat_mult_ex_f32(const float *A, const float *B, float *C, int A_rows, int A_cols, int B_cols, int A_padding, int B_padding, int C_padding);\ntiny_error_t tiny_mat_multc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre>"},{"location":"MATH/MATRIX/tiny-mat-api/#utility-functions","title":"UTILITY FUNCTIONS","text":""},{"location":"MATH/MATRIX/tiny-mat-api/#print-matrix","title":"Print Matrix","text":"<p><pre><code>void print_matrix(const char *name, const float *mat, int rows, int cols);\n</code></pre> Function: Print a matrix in row-major order.</p> <p>Parameters:</p> <ul> <li> <p><code>name</code>: Name of the matrix.</p> </li> <li> <p><code>mat</code>: Pointer to the matrix data.</p> </li> <li> <p><code>rows</code>: Number of rows in the matrix.</p> </li> <li> <p><code>cols</code>: Number of columns in the matrix.</p> </li> </ul> <p>Returns: None.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#print-padded-matrix","title":"Print Padded Matrix","text":"<p><pre><code>void print_matrix_padded(const char *name, const float *mat, int rows, int cols, int step);\n</code></pre> Function: Print a matrix in row-major order with padding.</p> <p>Parameters: - <code>name</code>: Name of the matrix.</p> <ul> <li> <p><code>mat</code>: Pointer to the matrix data.</p> </li> <li> <p><code>rows</code>: Number of rows in the matrix.</p> </li> <li> <p><code>cols</code>: Number of columns in the matrix.</p> </li> <li> <p><code>step</code>: Step size for the matrix data.</p> </li> </ul> <p>Returns: None.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#addition","title":"ADDITION","text":""},{"location":"MATH/MATRIX/tiny-mat-api/#matrix-addition","title":"Matrix Addition","text":"<pre><code>tiny_error_t tiny_mat_add_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\n</code></pre> <p>Function: Add two matrices.</p> <p>Parameters:</p> <ul> <li> <p><code>input1</code>: Pointer to the first input matrix.</p> </li> <li> <p><code>input2</code>: Pointer to the second input matrix.</p> </li> <li> <p><code>output</code>: Pointer to the output matrix.</p> </li> <li> <p><code>rows</code>: Number of rows in the matrices.</p> </li> <li> <p><code>cols</code>: Number of columns in the matrices.</p> </li> <li> <p><code>padd1</code>: Padding for the first input matrix.</p> </li> <li> <p><code>padd2</code>: Padding for the second input matrix.</p> </li> <li> <p><code>padd_out</code>: Padding for the output matrix.</p> </li> <li> <p><code>step1</code>: Step size for the first input matrix.</p> </li> <li> <p><code>step2</code>: Step size for the second input matrix.</p> </li> <li> <p><code>step_out</code>: Step size for the output matrix.</p> </li> </ul> <p>Returns: <code>tiny_error_t</code> indicating success or failure.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#matrix-addition-with-constant","title":"Matrix Addition with Constant","text":"<pre><code>tiny_error_t tiny_mat_addc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre> <p>Function: Add a constant to a matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>input</code>: Pointer to the input matrix.</p> </li> <li> <p><code>output</code>: Pointer to the output matrix.</p> </li> <li> <p><code>C</code>: Constant to add.</p> </li> <li> <p><code>rows</code>: Number of rows in the matrix.</p> </li> <li> <p><code>cols</code>: Number of columns in the matrix.</p> </li> <li> <p><code>padd_in</code>: Padding for the input matrix.</p> </li> <li> <p><code>padd_out</code>: Padding for the output matrix.</p> </li> <li> <p><code>step_in</code>: Step size for the input matrix.</p> </li> <li> <p><code>step_out</code>: Step size for the output matrix.</p> </li> </ul> <p>Returns: <code>tiny_error_t</code> indicating success or failure.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#subtraction","title":"SUBTRACTION","text":""},{"location":"MATH/MATRIX/tiny-mat-api/#matrix-subtraction","title":"Matrix Subtraction","text":"<pre><code>tiny_error_t tiny_mat_sub_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\n</code></pre> <p>Function: Subtract two matrices.</p> <p>Parameters:</p> <ul> <li> <p><code>input1</code>: Pointer to the first input matrix.</p> </li> <li> <p><code>input2</code>: Pointer to the second input matrix.</p> </li> <li> <p><code>output</code>: Pointer to the output matrix.</p> </li> <li> <p><code>rows</code>: Number of rows in the matrices.</p> </li> <li> <p><code>cols</code>: Number of columns in the matrices.</p> </li> <li> <p><code>padd1</code>: Padding for the first input matrix.</p> </li> <li> <p><code>padd2</code>: Padding for the second input matrix.</p> </li> <li> <p><code>padd_out</code>: Padding for the output matrix.</p> </li> <li> <p><code>step1</code>: Step size for the first input matrix.</p> </li> <li> <p><code>step2</code>: Step size for the second input matrix.</p> </li> <li> <p><code>step_out</code>: Step size for the output matrix.</p> </li> </ul> <p>Returns: <code>tiny_error_t</code> indicating success or failure.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#matrix-subtraction-with-constant","title":"Matrix Subtraction with Constant","text":"<pre><code>tiny_error_t tiny_mat_subc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre> <p>Function: Subtract a constant from a matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>input</code>: Pointer to the input matrix.</p> </li> <li> <p><code>output</code>: Pointer to the output matrix.</p> </li> <li> <p><code>C</code>: Constant to subtract.</p> </li> <li> <p><code>rows</code>: Number of rows in the matrix.</p> </li> <li> <p><code>cols</code>: Number of columns in the matrix.</p> </li> <li> <p><code>padd_in</code>: Padding for the input matrix.</p> </li> <li> <p><code>padd_out</code>: Padding for the output matrix.</p> </li> <li> <p><code>step_in</code>: Step size for the input matrix.</p> </li> <li> <p><code>step_out</code>: Step size for the output matrix.</p> </li> </ul> <p>Returns: <code>tiny_error_t</code> indicating success or failure.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#multiplication","title":"MULTIPLICATION","text":""},{"location":"MATH/MATRIX/tiny-mat-api/#matrix-multiplication","title":"Matrix Multiplication","text":"<pre><code>tiny_error_t tiny_mat_mult_f32(const float *A, const float *B, float *C, int m, int n, int k);\n</code></pre> <p>Function: Multiply two matrices.</p> <p>Parameters:</p> <ul> <li> <p><code>A</code>: Pointer to the first input matrix.</p> </li> <li> <p><code>B</code>: Pointer to the second input matrix.</p> </li> <li> <p><code>C</code>: Pointer to the output matrix.</p> </li> <li> <p><code>m</code>: Number of rows in the first matrix.</p> </li> <li> <p><code>n</code>: Number of columns in the first matrix (and rows in the second matrix).</p> </li> <li> <p><code>k</code>: Number of columns in the second matrix.</p> </li> </ul> <p>Returns: <code>tiny_error_t</code> indicating success or failure.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#extended-matrix-multiplication","title":"Extended Matrix Multiplication","text":"<pre><code>tiny_error_t tiny_mat_mult_ex_f32(const float *A, const float *B, float *C, int A_rows, int A_cols, int B_cols, int A_padding, int B_padding, int C_padding);\n</code></pre> <p>Function: Multiply two matrices with extended parameters.</p> <p>Parameters:</p> <ul> <li> <p><code>A</code>: Pointer to the first input matrix.</p> </li> <li> <p><code>B</code>: Pointer to the second input matrix.</p> </li> <li> <p><code>C</code>: Pointer to the output matrix.</p> </li> <li> <p><code>A_rows</code>: Number of rows in the first matrix.</p> </li> <li> <p><code>A_cols</code>: Number of columns in the first matrix.</p> </li> <li> <p><code>B_cols</code>: Number of columns in the second matrix.</p> </li> <li> <p><code>A_padding</code>: Padding for the first matrix.</p> </li> <li> <p><code>B_padding</code>: Padding for the second matrix.</p> </li> <li> <p><code>C_padding</code>: Padding for the output matrix.</p> </li> </ul> <p>Returns: <code>tiny_error_t</code> indicating success or failure.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#matrix-multiplication-with-constant","title":"Matrix Multiplication with Constant","text":"<pre><code>tiny_error_t tiny_mat_multc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre> <p>Function: Multiply a matrix by a constant.</p> <p>Parameters:</p> <ul> <li> <p><code>input</code>: Pointer to the input matrix.</p> </li> <li> <p><code>output</code>: Pointer to the output matrix.</p> </li> <li> <p><code>C</code>: Constant to multiply.</p> </li> <li> <p><code>rows</code>: Number of rows in the matrix.</p> </li> <li> <p><code>cols</code>: Number of columns in the matrix.</p> </li> <li> <p><code>padd_in</code>: Padding for the input matrix.</p> </li> <li> <p><code>padd_out</code>: Padding for the output matrix.</p> </li> <li> <p><code>step_in</code>: Step size for the input matrix.</p> </li> <li> <p><code>step_out</code>: Step size for the output matrix.</p> </li> </ul> <p>Returns: <code>tiny_error_t</code> indicating success or failure. ```</p>"},{"location":"MATH/MATRIX/tiny-mat-code/","title":"CODE","text":""},{"location":"MATH/MATRIX/tiny-mat-code/#tiny_math","title":"tiny_mat.h","text":"<pre><code>/**\n * @file tiny_mat.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the submodule mat (basic matrix operations) of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-17\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_MAT__\n#define __TINY_MAT__\n\n/* DEPENDENCIES */\n#include \"tiny_math_config.h\"\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n// ESP32 DSP library\n#include \"dspm_matrix.h\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* FUNCTION PROTOTYPES */\n// print matrix\nvoid print_matrix(const char *name, const float *mat, int rows, int cols);\n// print matrix padded (row-major)\nvoid print_matrix_padded(const char *name, const float *mat, int rows, int cols, int step);\n// addition\ntiny_error_t tiny_mat_add_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\ntiny_error_t tiny_mat_addc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n// subtraction\ntiny_error_t tiny_mat_sub_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\ntiny_error_t tiny_mat_subc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n// multiplication\ntiny_error_t tiny_mat_mult_f32(const float *A, const float *B, float *C, int m, int n, int k);\ntiny_error_t tiny_mat_mult_ex_f32(const float *A, const float *B, float *C, int A_rows, int A_cols, int B_cols, int A_padding, int B_padding, int C_padding);\ntiny_error_t tiny_mat_multc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY__MAT__ */\n</code></pre>"},{"location":"MATH/MATRIX/tiny-mat-code/#tiny_matc","title":"tiny_mat.c","text":"<pre><code>/**\n * @file tiny_mat.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the source file for the submodule mat (basic matrix operations) of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-17\n * @copyright Copyright (c) 2025\n *\n */\n\n/* DEPENDENCIES */\n#include \"tiny_mat.h\"\n\n/* SUPPORTIVE FUNCTIONS */\n\n/**\n * @name print_matrix\n * @brief Prints a matrix to the console.\n * @param name Name of the matrix.\n * @param mat Pointer to the matrix data.\n * @param rows Number of rows in the matrix.\n * @param cols Number of columns in the matrix.\n */\nvoid print_matrix(const char *name, const float *mat, int rows, int cols)\n{\n    printf(\"%s =\\n\\r\", name);\n    for (int i = 0; i &lt; rows; i++)\n    {\n        for (int j = 0; j &lt; cols; j++)\n        {\n            printf(\"%10.6f \", mat[i + j]); // padding not considered\n        }\n        printf(\"\\n\\r\");\n    }\n    printf(\"\\n\\r\");\n}\n\n// print matrix padded\n/**\n * @name print_matrix\n * @brief Prints a matrix to the console.\n * @param name Name of the matrix.\n * @param mat Pointer to the matrix data.\n * @param rows Number of rows in the matrix.\n * @param cols Number of columns in the matrix.\n * @param step Step size (how many elements in a row) for the matrix data. row-major order.\n */\nvoid print_matrix_padded(const char *name, const float *mat, int rows, int cols, int step)\n{\n    printf(\"%s =\\n\\r\", name);\n    for (int i = 0; i &lt; rows; i++)\n    {\n        for (int j = 0; j &lt; cols; j++)\n        {\n            printf(\"%10.6f \", mat[i * step + j]); // padding considered\n        }\n        printf(\"\\n\\r\");\n    }\n    printf(\"\\n\\r\");\n}\n\n/* ADDITION */\n\n// matrix + matrix | float\n\n/**\n * @name tiny_mat_add_f32\n * @brief Adds two matrices of type float32.\n * @param input1 Pointer to the first input matrix.\n * @param input2 Pointer to the second input matrix.\n * @param output Pointer to the output matrix.\n * @param rows Number of rows in the matrices.\n * @param cols Number of columns in the matrices.\n * @param padd1 Number of padding columns in the first input matrix.\n * @param padd2 Number of padding columns in the second input matrix.\n * @param padd_out Number of padding columns in the output matrix.\n * @param step1 Step size for the first input matrix.\n * @param step2 Step size for the second input matrix.\n * @param step_out Step size for the output matrix.\n * @return Returns TINY_OK on success, or an error code on failure.\n * @note This function performs matrix addition with the specified padding and step sizes.\n * @note The function assumes that the input matrices are in row-major order.\n */\ntiny_error_t tiny_mat_add_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out)\n{\n    if (NULL == input1 || NULL == input2 || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (rows &lt;= 0 || cols &lt;= 0 || padd1 &lt; 0 || padd2 &lt; 0 || padd_out &lt; 0 || step1 &lt;= 0 || step2 &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_MATH_INVALID_PARAM;\n    }\n\n    // pad refers to the columns that are not used in the matrix operation\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized matrix addition\n    dspm_add_f32(input1, input2, output, rows, cols, padd1, padd2, padd_out, step1, step2, step_out);\n#else\n    const int ptr_input1_step = cols + padd1;\n    const int ptr_input2_step = cols + padd2;\n    const int ptr_output_step = cols + padd_out;\n    float *ptr_input1 = (float *)input1;\n    float *ptr_input2 = (float *)input2;\n\n    for (int row = 0; row &lt; rows; row++)\n    {\n        for (int col = 0; col &lt; cols; col++)\n        {\n            output[col * step_out] = ptr_input1[col * step1] + ptr_input2[col * step2];\n        }\n        ptr_input1 += ptr_input1_step; // move to the next row of input1\n        ptr_input2 += ptr_input2_step; // move to the next row of input2\n        output += ptr_output_step;     // move to the next row of output\n    }\n#endif\n    return TINY_OK;\n}\n\n// matrix + constant | float\n\n/**\n * @name tiny_mat_addc_f32\n * @brief Adds a constant to each element of a matrix of type float32.\n * @param input Pointer to the input matrix.\n * @param output Pointer to the output matrix.\n * @param C Constant value to be added to each element of the matrix.\n * @param rows Number of rows in the matrices.\n * @param cols Number of columns in the matrices.\n * @param padd_in Number of padding columns in the input matrix.\n * @param padd_out Number of padding columns in the output matrix.\n * @param step_in Step size for the input matrix.\n * @param step_out Step size for the output matrix.\n * @return Returns TINY_OK on success, or an error code on failure.\n * @note This function performs matrix addition with a constant with the specified padding and step sizes.\n * @note The function assumes that the input matrix is in row-major order.\n */\ntiny_error_t tiny_mat_addc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (rows &lt;= 0 || cols &lt;= 0 || padd_in &lt; 0 || padd_out &lt; 0 || step_in &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_MATH_INVALID_PARAM;\n    }\n    // pad refers to the columns that are not used in the matrix operation\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized matrix addition with a constant\n    dspm_addc_f32(input, output, C, rows, cols, padd_in, padd_out, step_in, step_out);\n#else\n    const int ptr_input_step = cols + padd_in;\n    const int ptr_output_step = cols + padd_out;\n    float *ptr_input = (float *)input;\n\n    for (int row = 0; row &lt; rows; row++)\n    {\n        for (int col = 0; col &lt; cols; col++)\n        {\n            output[col * step_out] = ptr_input[col * step_in] + C;\n        }\n        ptr_input += ptr_input_step; // move to the next row of input\n        output += ptr_output_step;   // move to the next row of output\n    }\n#endif\n    return TINY_OK;\n}\n\n/* SUBTRACTION */\n\n// matrix - matrix | float\n\n/**\n * @name tiny_mat_sub_f32\n * @brief Subtracts two matrices of type float32.\n * @param input1 Pointer to the first input matrix.\n * @param input2 Pointer to the second input matrix.\n * @param output Pointer to the output matrix.\n * @param rows Number of rows in the matrices.\n * @param cols Number of columns in the matrices.\n * @param padd1 Number of padding columns in the first input matrix.\n * @param padd2 Number of padding columns in the second input matrix.\n * @param padd_out Number of padding columns in the output matrix.\n * @param step1 Step size for the first input matrix.\n * @param step2 Step size for the second input matrix.\n * @param step_out Step size for the output matrix.\n * @return Returns TINY_OK on success, or an error code on failure.\n * @note This function performs matrix subtraction with the specified padding and step sizes.\n * @note The function assumes that the input matrices are in row-major order.\n */\ntiny_error_t tiny_mat_sub_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out)\n{\n    if (NULL == input1 || NULL == input2 || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (rows &lt;= 0 || cols &lt;= 0 || padd1 &lt; 0 || padd2 &lt; 0 || padd_out &lt; 0 || step1 &lt;= 0 || step2 &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_MATH_INVALID_PARAM;\n    }\n    // pad refers to the columns that are not used in the matrix operation\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized matrix subtraction\n    dspm_sub_f32(input1, input2, output, rows, cols, padd1, padd2, padd_out, step1, step2, step_out);\n#else\n    const int ptr_input1_step = cols + padd1;\n    const int ptr_input2_step = cols + padd2;\n    const int ptr_output_step = cols + padd_out;\n    float *ptr_input1 = (float *)input1;\n    float *ptr_input2 = (float *)input2;\n\n    for (int row = 0; row &lt; rows; row++)\n    {\n        for (int col = 0; col &lt; cols; col++)\n        {\n            output[col * step_out] = ptr_input1[col * step1] - ptr_input2[col * step2];\n        }\n        ptr_input1 += ptr_input1_step; // move to the next row of input1\n        ptr_input2 += ptr_input2_step; // move to the next row of input2\n        output += ptr_output_step;     // move to the next row of output\n    }\n#endif\n    return TINY_OK;\n}\n\n// matrix - constant | float\n\n/**\n * @name tiny_mat_subc_f32\n * @brief Subtracts a constant from each element of a matrix of type float32.\n * @param input Pointer to the input matrix.\n * @param output Pointer to the output matrix.\n * @param C Constant value to be subtracted from each element of the matrix.\n * @param rows Number of rows in the matrices.\n * @param cols Number of columns in the matrices.\n * @param padd_in Number of padding columns in the input matrix.\n * @param padd_out Number of padding columns in the output matrix.\n * @param step_in Step size for the input matrix.\n * @param step_out Step size for the output matrix.\n * @return Returns TINY_OK on success, or an error code on failure.\n * @note This function performs matrix subtraction with a constant with the specified padding and step sizes.\n * @note The function assumes that the input matrix is in row-major order.\n */\ntiny_error_t tiny_mat_subc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (rows &lt;= 0 || cols &lt;= 0 || padd_in &lt; 0 || padd_out &lt; 0 || step_in &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_MATH_INVALID_PARAM;\n    }\n    // pad refers to the columns that are not used in the matrix operation\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized matrix subtraction with a constant\n    dspm_addc_f32(input, output, -C, rows, cols, padd_in, padd_out, step_in, step_out);\n#else\n    const int ptr_input_step = cols + padd_in;\n    const int ptr_output_step = cols + padd_out;\n    float *ptr_input = (float *)input;\n\n    for (int row = 0; row &lt; rows; row++)\n    {\n        for (int col = 0; col &lt; cols; col++)\n        {\n            output[col * step_out] = ptr_input[col * step_in] - C;\n        }\n        ptr_input += ptr_input_step; // move to the next row of input\n        output += ptr_output_step;   // move to the next row of output\n    }\n#endif\n    return TINY_OK;\n}\n\n/* MULTIPLICATION */\n\n// matrix * matrix | float\n\n/**\n * @name tiny_mat_mult_f32\n * @brief Multiplies two matrices of type float32.\n * @param A Pointer to the first input matrix.\n * @param B Pointer to the second input matrix.\n * @param C Pointer to the output matrix.\n * @param m Number of rows in the first matrix.\n * @param n Number of columns in the first matrix and rows in the second matrix.\n * @param k Number of columns in the second matrix.\n * @return Returns TINY_OK on success, or an error code on failure.\n * @note This function performs matrix multiplication with the specified padding and step sizes.\n * @note The function assumes that the input matrices are in row-major order.\n */\ntiny_error_t tiny_mat_mult_f32(const float *A, const float *B, float *C, int m, int n, int k)\n{\n    if (NULL == A || NULL == B || NULL == C)\n        return TINY_ERR_MATH_NULL_POINTER;\n    if (m &lt;= 0 || n &lt;= 0 || k &lt;= 0)\n        return TINY_ERR_MATH_INVALID_PARAM;\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized matrix multiplication\n    dspm_mult_f32(A, B, C, m, n, k);\n#else\n    // C[i][j] = sum_{s=0}^{n-1} A[i][s] * B[s][j]\n    for (int i = 0; i &lt; m; i++)\n    {\n        for (int j = 0; j &lt; k; j++)\n        {\n            C[i * k + j] = 0.0f;\n            for (int s = 0; s &lt; n; s++)\n            {\n                C[i * k + j] += A[i * n + s] * B[s * k + j];\n            }\n        }\n    }\n#endif\n    return TINY_OK;\n}\n\n// matrix * matrix | float with padding and step sizes\n/**\n * @name tiny_mat_mult_ex_f32\n * @brief Multiplies two matrices of type float32 with padding and step sizes.\n * @param A Pointer to the first input matrix.\n * @param B Pointer to the second input matrix.\n * @param C Pointer to the output matrix.\n * @param A_rows Number of rows in the first matrix.\n * @param A_cols Number of columns in the first matrix and rows in the second matrix.\n * @param B_cols Number of columns in the second matrix.\n * @param A_padding Number of padding columns in the first matrix.\n * @param B_padding Number of padding columns in the second matrix.\n * @param C_padding Number of padding columns in the output matrix.\n * @return Returns TINY_OK on success, or an error code on failure.\n * @note This function performs matrix multiplication with the specified padding and step sizes.\n * @note The function assumes that the input matrices are in row-major order.\n */\ntiny_error_t tiny_mat_mult_ex_f32(const float *A, const float *B, float *C, int A_rows, int A_cols, int B_cols, int A_padding, int B_padding, int C_padding)\n{\n    if (NULL == A || NULL == B || NULL == C)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (A_rows &lt;= 0 || A_cols &lt;= 0 || B_cols &lt;= 0)\n    {\n        return TINY_ERR_MATH_INVALID_PARAM;\n    }\n    if (A_padding &lt; 0 || B_padding &lt; 0 || C_padding &lt; 0)\n    {\n        return TINY_ERR_MATH_INVALID_PARAM;\n    }\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized matrix multiplication\n    dspm_mult_ex_f32(A, B, C, A_rows, A_cols, B_cols, A_padding, B_padding, C_padding);\n#else\n    // Matrix A(m,n), m - amount or rows, n - amount of columns\n    // C(m,k) = A(m,n)*B(n,k)\n    // c(i * c_step,j) = sum(a(i * a_step,s)*b(s * b_step,j)) , s=1..n\n    const int A_step = A_cols + A_padding;\n    const int B_step = B_cols + B_padding;\n    const int C_step = B_cols + C_padding;\n\n    for (int i = 0; i &lt; A_rows; i++)\n    {\n        for (int j = 0; j &lt; B_cols; j++)\n        {\n            C[i * C_step + j] = A[i * A_step] * B[j];\n            for (int s = 1; s &lt; A_cols; s++)\n            {\n                C[i * C_step + j] += A[i * A_step + s] * B[s * B_step + j];\n            }\n        }\n    }\n#endif\n    return TINY_OK;\n}\n\n// matrix * constant | float\n/**\n * @name tiny_mat_multc_f32\n * @brief Multiplies a matrix by a constant of type float32.\n * @param input Pointer to the input matrix.\n * @param output Pointer to the output matrix.\n * @param C Constant value to be multiplied with each element of the matrix.\n * @param rows Number of rows in the matrices.\n * @param cols Number of columns in the matrices.\n * @param padd_in Number of padding columns in the input matrix.\n * @param padd_out Number of padding columns in the output matrix.\n * @param step_in Step size for the input matrix.\n * @param step_out Step size for the output matrix.\n * @return Returns TINY_OK on success, or an error code on failure.\n * @note This function performs matrix multiplication with a constant with the specified padding and step sizes.\n * @note The function assumes that the input matrix is in row-major order.\n */\ntiny_error_t tiny_mat_multc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (rows &lt;= 0 || cols &lt;= 0 || padd_in &lt; 0 || padd_out &lt; 0 || step_in &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_MATH_INVALID_PARAM;\n    }\n    // pad refers to the columns that are not used in the matrix operation\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized matrix multiplication with a constant\n    dspm_mulc_f32(input, output, C, rows, cols, padd_in, padd_out, step_in, step_out);\n#else\n    const int ptr_input_step = cols + padd_in;\n    const int ptr_output_step = cols + padd_out;\n    float *ptr_input = (float *)input;\n\n    for (int row = 0; row &lt; rows; row++)\n    {\n        for (int col = 0; col &lt; cols; col++)\n        {\n            output[col * step_out] = ptr_input[col * step_in] * C;\n        }\n        ptr_input += ptr_input_step; // move to the next row of input\n        output += ptr_output_step;   // move to the next row of output\n    }\n#endif\n    return TINY_OK;\n}\n</code></pre>"},{"location":"MATH/MATRIX/tiny-mat-test/","title":"TINY_MAT TEST","text":""},{"location":"MATH/MATRIX/tiny-mat-test/#test-code","title":"TEST CODE","text":""},{"location":"MATH/MATRIX/tiny-mat-test/#tiny_mat_testh","title":"tiny_mat_test.h","text":"<pre><code>/**\n * @file tiny_mat_test.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the test of the submodule mat (basic matrix operations) of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-17\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_MAT_TEST__\n#define __TINY_MAT_TEST__\n\n/* DEPENDENCIES */\n#include \"tiny_math_config.h\"\n#include \"tiny_mat.h\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\nvoid tiny_mat_test(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_MAT_TEST__ */\n</code></pre>"},{"location":"MATH/MATRIX/tiny-mat-test/#tiny_mat_testc","title":"tiny_mat_test.c","text":"<pre><code>/**\n * @file tiny_mat_test.c\n * @brief This file implements test functions for the submodule mat of the tiny_math middleware.\n */\n\n#include \"tiny_mat_test.h\"\n\n#define ROWS 2\n#define COLS 3\n#define PAD 1\n#define FULL_WIDTH (COLS + PAD)\n\nvoid tiny_mat_test(void)\n{\n    float A[ROWS * FULL_WIDTH] = {\n        1, 2, 3, 0,\n        4, 5, 6, 0};\n\n    float B[COLS * FULL_WIDTH] = {\n        7, 8, 9, 0,\n        10, 11, 12, 0,\n        13, 14, 15, 0};\n\n    float A_compact[ROWS * COLS] = {0};\n    float B_compact[COLS * COLS] = {0};\n    float C_compact[ROWS * COLS] = {0};\n\n    float output_general[ROWS * FULL_WIDTH] = {0};\n    float constant = 2.0f;\n\n    for (int i = 0; i &lt; ROWS; i++)\n        for (int j = 0; j &lt; COLS; j++)\n            A_compact[i * COLS + j] = A[i * FULL_WIDTH + j];\n\n    for (int i = 0; i &lt; COLS; i++)\n        for (int j = 0; j &lt; COLS; j++)\n            B_compact[i * COLS + j] = B[i * FULL_WIDTH + j];\n\n    printf(\"============ [tiny_mat_test - Full Coverage] ============\\n\\r\");\n    printf(\"[TEST SETTINGS] ROWS=%d, COLS=%d, PAD=%d, FULL_WIDTH=%d\\n\\r\", ROWS, COLS, PAD, FULL_WIDTH);\n\n    print_matrix_padded(\"A (padded) | memory layout\", A, ROWS, FULL_WIDTH, FULL_WIDTH);\n    print_matrix_padded(\"B (padded) | memory layout\", B, COLS, FULL_WIDTH, FULL_WIDTH);\n    print_matrix(\"A_compact\", A_compact, ROWS, COLS);\n    print_matrix(\"B_compact\", B_compact, COLS, COLS);\n    printf(\"constant = %f\\n\\r\\n\\r\", constant);\n\n    TinyTimeMark_t t0, t1;\n    tiny_error_t err;\n\n    t0 = tiny_get_running_time();\n    err = tiny_mat_add_f32(A, B, output_general, ROWS, COLS, PAD, PAD, PAD, 1, 1, 1);\n    t1 = tiny_get_running_time();\n    printf(\"--- tiny_mat_add_f32(rows=%d, cols=%d, paddings=1) | Time: %6.2f us | Error: %d ---\\n\\r\", ROWS, COLS, (double)(t1 - t0), err);\n    print_matrix_padded(\"Output (padded)\", output_general, ROWS, COLS, FULL_WIDTH);\n\n    t0 = tiny_get_running_time();\n    err = tiny_mat_addc_f32(A, output_general, constant, ROWS, COLS, PAD, PAD, 1, 1);\n    t1 = tiny_get_running_time();\n    printf(\"--- tiny_mat_addc_f32(C=%f) | Time: %6.2f us | Error: %d ---\\n\\r\", constant, (double)(t1 - t0), err);\n    print_matrix_padded(\"Output (padded)\", output_general, ROWS, COLS, FULL_WIDTH);\n\n    t0 = tiny_get_running_time();\n    err = tiny_mat_sub_f32(A, B, output_general, ROWS, COLS, PAD, PAD, PAD, 1, 1, 1);\n    t1 = tiny_get_running_time();\n    printf(\"--- tiny_mat_sub_f32(rows=%d, cols=%d) | Time: %6.2f us | Error: %d ---\\n\\r\", ROWS, COLS, (double)(t1 - t0), err);\n    print_matrix_padded(\"Output (padded)\", output_general, ROWS, COLS, FULL_WIDTH);\n\n    t0 = tiny_get_running_time();\n    err = tiny_mat_subc_f32(A, output_general, constant, ROWS, COLS, PAD, PAD, 1, 1);\n    t1 = tiny_get_running_time();\n    printf(\"--- tiny_mat_subc_f32(C=%f) | Time: %6.2f us | Error: %d ---\\n\\r\", constant, (double)(t1 - t0), err);\n    print_matrix_padded(\"Output (padded)\", output_general, ROWS, COLS, FULL_WIDTH);\n\n    t0 = tiny_get_running_time();\n    err = tiny_mat_multc_f32(A, output_general, constant, ROWS, COLS, PAD, PAD, 1, 1);\n    t1 = tiny_get_running_time();\n    printf(\"--- tiny_mat_multc_f32(C=%f) | Time: %6.2f us | Error: %d ---\\n\\r\", constant, (double)(t1 - t0), err);\n    print_matrix_padded(\"Output (padded)\", output_general, ROWS, COLS, FULL_WIDTH);\n\n    t0 = tiny_get_running_time();\n    err = tiny_mat_mult_f32(A_compact, B_compact, C_compact, ROWS, COLS, COLS);\n    t1 = tiny_get_running_time();\n    printf(\"--- tiny_mat_mult_f32 (compact) | Time: %6.2f us | Error: %d ---\\n\\r\", (double)(t1 - t0), err);\n    print_matrix(\"Output (compact)\", C_compact, ROWS, COLS);\n\n    t0 = tiny_get_running_time();\n    err = tiny_mat_mult_ex_f32(A, B, output_general, ROWS, COLS, COLS, PAD, PAD, PAD);\n    t1 = tiny_get_running_time();\n    printf(\"--- tiny_mat_mult_ex_f32(padded) | Time: %6.2f us | Error: %d ---\\n\\r\", (double)(t1 - t0), err);\n    print_matrix_padded(\"Output (padded)\", output_general, ROWS, COLS, FULL_WIDTH);\n\n    printf(\"============ [test complete] ============\\n\\r\");\n}\n</code></pre>"},{"location":"MATH/MATRIX/tiny-mat-test/#test-output","title":"TEST OUTPUT","text":"<pre><code>============ [tiny_mat_test - Full Coverage] ============\n[TEST SETTINGS] ROWS=2, COLS=3, PAD=1, FULL_WIDTH=4\nA (padded) | memory layout =\n  1.000000   2.000000   3.000000   0.000000 \n  4.000000   5.000000   6.000000   0.000000 \n\nB (padded) | memory layout =\n  7.000000   8.000000   9.000000   0.000000 \n 10.000000  11.000000  12.000000   0.000000 \n 13.000000  14.000000  15.000000   0.000000 \n\nA_compact =\n  1.000000   2.000000   3.000000 \n  2.000000   3.000000   4.000000 \n\nB_compact =\n  7.000000   8.000000   9.000000 \n  8.000000   9.000000  10.000000 \n  9.000000  10.000000  11.000000 \n\nconstant = 2.000000\n\n--- tiny_mat_add_f32(rows=2, cols=3, paddings=1) | Time:  18.00 us | Error: 0 ---\nOutput (padded) =\n  8.000000  10.000000  12.000000 \n 14.000000  16.000000  18.000000 \n\n--- tiny_mat_addc_f32(C=2.000000) | Time:  10.00 us | Error: 0 ---\nOutput (padded) =\n  3.000000   4.000000   5.000000 \n  6.000000   7.000000   8.000000 \n\n--- tiny_mat_sub_f32(rows=2, cols=3) | Time:  13.00 us | Error: 0 ---\nOutput (padded) =\n -6.000000  -6.000000  -6.000000 \n -6.000000  -6.000000  -6.000000 \n\n--- tiny_mat_subc_f32(C=2.000000) | Time:   7.00 us | Error: 0 ---\nOutput (padded) =\n -1.000000   0.000000   1.000000 \n  2.000000   3.000000   4.000000 \n\n--- tiny_mat_multc_f32(C=2.000000) | Time:   8.00 us | Error: 0 ---\nOutput (padded) =\n  2.000000   4.000000   6.000000 \n  8.000000  10.000000  12.000000 \n\n--- tiny_mat_mult_f32 (compact) | Time:  10.00 us | Error: 0 ---\nOutput (compact) =\n 66.000000  72.000000  78.000000 \n 72.000000  78.000000 156.000000 \n\n--- tiny_mat_mult_ex_f32(padded) | Time:  13.00 us | Error: 0 ---\nOutput (padded) =\n 66.000000  72.000000  78.000000 \n156.000000 171.000000 186.000000 \n\n============ [test complete] ============\n</code></pre>"},{"location":"MATH/MATRIX/tiny-matrix-api/","title":"MATRIX OPERATIONS - TINY_MATRIX","text":"<p>TINY_MATRIX Library</p> <ul> <li>This library is a lightweight matrix computation library implemented in C++, providing basic matrix operations and linear algebra functions.</li> <li>The design goal of this library is to provide a simple and easy-to-use matrix operation interface, suitable for embedded systems and resource-constrained environments.</li> </ul> <p>Usage Scenario</p> <p>Compared to the TINY_MAT library, the TINY_MATRIX library offers richer functionality and higher flexibility, suitable for applications that require complex matrix computations. However, please note that this library is written in C++.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#list-of-functions","title":"LIST OF FUNCTIONS","text":"<pre><code>TinyMath\n    \u251c\u2500\u2500Vector\n    \u2514\u2500\u2500Matrix\n        \u251c\u2500\u2500 tiny_mat (c)\n        \u2514\u2500\u2500 tiny_matrix (c++) &lt;---\n</code></pre> <pre><code>namespace tiny\n{\n    class Mat\n    {\n    public:\n        /* === Matrix Metadata === */\n        int rows, cols, stride, padding, length;\n        float *data;\n        bool ext_buff, sub_matrix;\n\n        /* === Rectangular ROI Structure === */\n        struct Rect\n        {\n            int x, y, width, height;\n            Rect(int x = 0, int y = 0, int width = 0, int height = 0);\n            void resizeRect(int x, int y, int width, int height);\n            int areaRect(void) const;\n        };\n\n        /* === Constructors &amp; Destructor === */\n        Mat();                                      // Default constructor\n        Mat(int rows, int cols);                    // Internal allocation\n        Mat(float *data, int rows, int cols);       // External buffer\n        Mat(float *data, int rows, int cols, int stride); // External buffer with stride\n        Mat(const Mat &amp;src);                        // Copy constructor\n        ~Mat();                                     // Destructor\n\n        void allocate();                            // Allocate internal memory\n\n        /* === Element Access === */\n        inline float &amp;operator()(int row, int col) { return data[row * stride + col]; }\n        inline const float &amp;operator()(int row, int col) const { return data[row * stride + col]; }\n\n\n        /* === Data Manipulation === */\n        void Copy(const Mat &amp;src, int row_pos, int col_pos);\n        void CopyHead(const Mat &amp;src);\n        Mat getROI(int startRow, int startCol, int roiRows, int roiCols, int stride);\n        Mat getROI(int startRow, int startCol, int roiRows, int roiCols);\n        Mat getROI(const Rect &amp;rect);\n        Mat Get(int row_start, int row_size, int col_start, int col_size);\n        Mat Get(const Rect &amp;rect);\n        Mat block(int startRow, int startCol, int blockRows, int blockCols);\n        void swapRows(int row1, int row2);\n        void clear();\n\n        /* === Print &amp; Debug === */\n        void PrintHead();\n        void PrintMatrix(bool show_padding, const std::string &amp;label);\n\n        /* === Arithmetic Operators === */\n        Mat &amp;operator=(const Mat &amp;src);             // Copy assignment\n        Mat &amp;operator+=(const Mat &amp;A);\n        Mat &amp;operator+=(float C);\n        Mat &amp;operator-=(const Mat &amp;A);\n        Mat &amp;operator-=(float C);\n        Mat &amp;operator*=(const Mat &amp;A);\n        Mat &amp;operator*=(float C);\n        Mat &amp;operator/=(const Mat &amp;B);\n        Mat &amp;operator/=(float C);\n        Mat operator^(int C);\n\n        /* === Linear Algebra === */\n        void normalize();\n        float norm();\n        float det(int n);\n        Mat t();\n        Mat inverse();\n        Mat pinv();\n        Mat gaussianEliminate();\n        Mat rowReduceFromGaussian();\n\n        /* === Static Utility Functions === */\n        static Mat eye(int size);\n        static Mat ones(int size);\n        static Mat ones(int rows, int cols);\n        static Mat solve(Mat A, Mat b);\n        static Mat bandSolve(Mat A, Mat b, int k);\n        static Mat roots(Mat A, Mat y);\n        static float dotProduct(Mat A, Mat B);\n        static Mat augment(Mat A, Mat B);\n\n    private:\n        Mat cofactor(int row, int col, int n);\n        Mat adjoint();\n        Mat expHelper(const Mat &amp;m, int num);\n    };\n\n    /* === Stream Operators === */\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat &amp;m);\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat::Rect &amp;rect);\n    std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Mat &amp;m);\n\n    /* === Global Arithmetic Operators === */\n    Mat operator+(const Mat &amp;A, const Mat &amp;B);\n    Mat operator+(const Mat &amp;A, float C);\n    Mat operator-(const Mat &amp;A, const Mat &amp;B);\n    Mat operator-(const Mat &amp;A, float C);\n    Mat operator*(const Mat &amp;A, const Mat &amp;B);\n    Mat operator*(const Mat &amp;A, float C);\n    Mat operator*(float C, const Mat &amp;A);\n    Mat operator/(const Mat &amp;A, float C);\n    Mat operator/(const Mat &amp;A, const Mat &amp;B);\n    bool operator==(const Mat &amp;A, const Mat &amp;B);\n}\n</code></pre>"},{"location":"MATH/MATRIX/tiny-matrix-api/#matrix-metadata","title":"MATRIX METADATA","text":"<ul> <li> <p><code>int rows</code>: Number of rows in the matrix.</p> </li> <li> <p><code>int cols</code>: Number of columns in the matrix.</p> </li> <li> <p><code>int stride</code>: Number of elements in each row (including padding).</p> </li> <li> <p><code>int padding</code>: Number of padding elements in each row.</p> </li> <li> <p><code>int length</code>: Total number of elements in the matrix.</p> </li> <li> <p><code>float *data</code>: Pointer to the data buffer of the matrix.</p> </li> <li> <p><code>bool ext_buff</code>: Indicates whether the matrix uses an external buffer.</p> </li> <li> <p><code>bool sub_matrix</code>: Indicates whether the matrix is a sub-matrix of another matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#roi-structure","title":"ROI STRUCTURE","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#roi-metadata","title":"ROI Metadata","text":"<ul> <li> <p><code>int x</code>: X-coordinate of the top-left corner of the ROI.</p> </li> <li> <p><code>int y</code>: Y-coordinate of the top-left corner of the ROI.</p> </li> <li> <p><code>int width</code>: Width of the ROI.</p> </li> <li> <p><code>int height</code>: Height of the ROI.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#roi-constructor","title":"ROI Constructor","text":"<pre><code>Mat::Rect::Rect(int x, int y, int width, int height);\n</code></pre> <ul> <li> <p><code>x</code>: X-coordinate of the top-left corner of the ROI.</p> </li> <li> <p><code>y</code>: Y-coordinate of the top-left corner of the ROI.</p> </li> <li> <p><code>width</code>: Width of the ROI.</p> </li> <li> <p><code>height</code>: Height of the ROI.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#resize-roi","title":"Resize ROI","text":"<pre><code>void Mat::Rect::resizeRect(int x, int y, int width, int height);\n</code></pre> <ul> <li> <p><code>x</code>: New X-coordinate of the top-left corner of the ROI.</p> </li> <li> <p><code>y</code>: New Y-coordinate of the top-left corner of the ROI.</p> </li> <li> <p><code>width</code>: New width of the ROI.</p> </li> <li> <p><code>height</code>: New height of the ROI.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#area-of-roi","title":"Area of ROI","text":"<pre><code>int Mat::Rect::areaRect(void) const;\n</code></pre> <ul> <li>Returns the area of the ROI.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#constructors-destructor","title":"CONSTRUCTORS &amp; DESTRUCTOR","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#default-constructor","title":"Default Constructor","text":"<pre><code>Mat::Mat();\n</code></pre> <p>Description: Default constructor, creates an empty matrix.</p> <p>Parameters: None.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#constructor-with-rows-and-columns","title":"Constructor with Rows and Columns","text":"<pre><code>Mat::Mat(int rows, int cols);\n</code></pre> <p>Description: Constructor that allocates internal memory for the matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>int rows</code>: Number of rows in the matrix.</p> </li> <li> <p><code>int cols</code>: Number of columns in the matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#constructor-with-external-buffer","title":"Constructor with External Buffer","text":"<p><pre><code>Mat::Mat(float *data, int rows, int cols);\n</code></pre> Description: Constructor that uses an external buffer for the matrix data.</p> <p>Parameters:</p> <ul> <li> <p><code>float *data</code>: Pointer to the external buffer.</p> </li> <li> <p><code>int rows</code>: Number of rows in the matrix.</p> </li> <li> <p><code>int cols</code>: Number of columns in the matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#constructor-with-external-buffer-and-stride","title":"Constructor with External Buffer and Stride","text":"<pre><code>Mat::Mat(float *data, int rows, int cols, int stride);\n</code></pre> <p>Description: Constructor that uses an external buffer and specifies the stride.</p> <p>Parameters:</p> <ul> <li> <p><code>float *data</code>: Pointer to the external buffer.</p> </li> <li> <p><code>int rows</code>: Number of rows in the matrix.</p> </li> <li> <p><code>int cols</code>: Number of columns in the matrix.</p> </li> <li> <p><code>int stride</code>: Number of elements in each row (including padding).</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#copy-constructor","title":"Copy Constructor","text":"<pre><code>Mat::Mat(const Mat &amp;src);\n</code></pre> <p>Description: Copy constructor that creates a new matrix as a copy of the source matrix.</p> <p>Parameters:</p> <ul> <li><code>const Mat &amp;src</code>: Source matrix to copy from.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#destructor","title":"Destructor","text":"<pre><code>Mat::~Mat();\n</code></pre> <p>Description: Destructor that releases the internal memory of the matrix.</p> <p>Parameters: None.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#allocate-internal-memory","title":"Allocate Internal Memory","text":"<pre><code>void Mat::allocate();\n</code></pre> <p>Description: Allocates internal memory for the matrix.</p> <p>Parameters: None.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#element-access","title":"ELEMENT ACCESS","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#element-access-operator","title":"Element Access Operator","text":"<pre><code>inline float &amp;Mat::operator()(int row, int col);\n</code></pre> <p>Description: Accesses the element at the specified row and column.</p> <p>Parameters:</p> <ul> <li> <p><code>int row</code>: Row index of the element.</p> </li> <li> <p><code>int col</code>: Column index of the element.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#const-element-access-operator","title":"Const Element Access Operator","text":"<pre><code>inline const float &amp;Mat::operator()(int row, int col) const;\n</code></pre> <p>Description: Accesses the element at the specified row and column (const version).</p> <p>Parameters:</p> <ul> <li> <p><code>int row</code>: Row index of the element.</p> </li> <li> <p><code>int col</code>: Column index of the element.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#data-manipulation","title":"DATA MANIPULATION","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#copy-function","title":"Copy Function","text":"<pre><code>void Mat::Copy(const Mat &amp;src, int row_pos, int col_pos);\n</code></pre> <p>Description: Copies the source matrix to the current matrix at the specified position.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;src</code>: Source matrix to copy from.</p> </li> <li> <p><code>int row_pos</code>: Row position to copy to.</p> </li> <li> <p><code>int col_pos</code>: Column position to copy to.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#copy-head-function","title":"Copy Head Function","text":"<pre><code>void Mat::CopyHead(const Mat &amp;src);\n</code></pre> <p>Description: Copies the header (metadata) of the source matrix to the current matrix.</p> <p>Parameters:</p> <ul> <li><code>const Mat &amp;src</code>: Source matrix to copy from.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#get-roi-function","title":"Get ROI Function","text":"<pre><code>Mat Mat::getROI(int startRow, int startCol, int roiRows, int roiCols, int stride);\n</code></pre> <p>Description: Returns a sub-matrix (ROI) of the current matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>int startRow</code>: Starting row index of the ROI.</p> </li> <li> <p><code>int startCol</code>: Starting column index of the ROI.</p> </li> <li> <p><code>int roiRows</code>: Number of rows in the ROI.</p> </li> <li> <p><code>int roiCols</code>: Number of columns in the ROI.</p> </li> <li> <p><code>int stride</code>: Stride of the ROI.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#get-roi-function-without-stride","title":"Get ROI Function (Without Stride)","text":"<pre><code>Mat Mat::getROI(int startRow, int startCol, int roiRows, int roiCols);\n</code></pre> <p>Description: Returns a sub-matrix (ROI) of the current matrix without specifying stride.</p> <p>Parameters:</p> <ul> <li> <p><code>int startRow</code>: Starting row index of the ROI.</p> </li> <li> <p><code>int startCol</code>: Starting column index of the ROI.</p> </li> <li> <p><code>int roiRows</code>: Number of rows in the ROI.</p> </li> <li> <p><code>int roiCols</code>: Number of columns in the ROI.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#get-roi-function-with-rect","title":"Get ROI Function (With Rect)","text":"<pre><code>Mat Mat::getROI(const Rect &amp;rect);\n</code></pre> <p>Description: Returns a sub-matrix (ROI) of the current matrix using a Rect structure.</p> <p>Parameters:</p> <ul> <li><code>const Rect &amp;rect</code>: Rect structure defining the ROI.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#get-function","title":"Get Function","text":"<pre><code>Mat Mat::Get(int row_start, int row_size, int col_start, int col_size);\n</code></pre> <p>Description: Returns a sub-matrix of the current matrix defined by the specified row and column ranges.</p> <p>Parameters:</p> <ul> <li> <p><code>int row_start</code>: Starting row index of the sub-matrix.</p> </li> <li> <p><code>int row_size</code>: Number of rows in the sub-matrix.</p> </li> <li> <p><code>int col_start</code>: Starting column index of the sub-matrix.</p> </li> <li> <p><code>int col_size</code>: Number of columns in the sub-matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#get-function-with-rect","title":"Get Function (With Rect)","text":"<p><pre><code>Mat Mat::Get(const Rect &amp;rect);\n</code></pre> Description: Returns a sub-matrix of the current matrix defined by a Rect structure.</p> <p>Parameters:</p> <ul> <li><code>const Rect &amp;rect</code>: Rect structure defining the sub-matrix.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#block-function","title":"Block Function","text":"<pre><code>Mat Mat::block(int startRow, int startCol, int blockRows, int blockCols);\n</code></pre> <p>Description: Returns a block of the current matrix defined by the specified starting row and column indices.</p> <p>Parameters:</p> <ul> <li> <p><code>int startRow</code>: Starting row index of the block.</p> </li> <li> <p><code>int startCol</code>: Starting column index of the block.</p> </li> <li> <p><code>int blockRows</code>: Number of rows in the block.</p> </li> <li> <p><code>int blockCols</code>: Number of columns in the block.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#swap-rows-function","title":"Swap Rows Function","text":"<pre><code>void Mat::swapRows(int row1, int row2);\n</code></pre> <p>Description: Swaps two rows in the current matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>int row1</code>: Index of the first row to swap.</p> </li> <li> <p><code>int row2</code>: Index of the second row to swap.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#clear-function","title":"Clear Function","text":"<pre><code>void Mat::clear();\n</code></pre> <p>Description: Clears the current matrix, releasing its internal memory.</p> <p>Parameters: None.</p> <p>getROI | Get | block</p> <ul> <li>getROI: Get a sub-matrix (Region of Interest) from the current matrix.</li> <li>Get: Get a sub-matrix defined by row and column ranges.</li> <li>block: Get a block of the current matrix defined by starting row and column indices.</li> </ul> Method Copy Data New Memory Affect Original Matrix Performance Usage Scenario <code>getROI</code> No No Yes \u2b50\u2b50\u2b50\u2b50\u2b50 Fast temporary sub-matrix <code>Get</code> Yes Yes No \u2b50\u2b50\u2b50\u2b50 Safe &amp; independent sub-matrix <code>block</code> Yes Yes No \u2b50\u2b50\u2b50 Flexible complex copy"},{"location":"MATH/MATRIX/tiny-matrix-api/#print-debug","title":"PRINT &amp; DEBUG","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#print-head-function","title":"Print Head Function","text":"<pre><code>void Mat::PrintHead();\n</code></pre> <p>Description: Prints the header (metadata) of the current matrix.</p> <p>Parameters: None.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#print-matrix-function","title":"Print Matrix Function","text":"<pre><code>void Mat::PrintMatrix(bool show_padding, const std::string &amp;label);\n</code></pre> <p>Description: Prints the contents of the current matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>bool show_padding</code>: Indicates whether to show padding.</p> </li> <li> <p><code>const std::string &amp;label</code>: Label to print with the matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#arithmetic-operators","title":"ARITHMETIC OPERATORS","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#copy-assignment-operator","title":"Copy Assignment Operator","text":"<pre><code>Mat &amp;Mat::operator=(const Mat &amp;src);\n</code></pre> <p>Description: Copy assignment operator that assigns the source matrix to the current matrix.</p> <p>Parameters:</p> <ul> <li><code>const Mat &amp;src</code>: Source matrix to assign from.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#addition-assignment-operator","title":"Addition Assignment Operator","text":"<pre><code>Mat &amp;Mat::operator+=(const Mat &amp;A);\n</code></pre> <p>Description: Adds the source matrix to the current matrix.</p> <p>Parameters:</p> <ul> <li><code>const Mat &amp;A</code>: Source matrix to add.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#addition-assignment-operator-with-constant","title":"Addition Assignment Operator (with constant)","text":"<pre><code>Mat &amp;Mat::operator+=(float C);\n</code></pre> <p>Description: Adds a constant value to the current matrix.</p> <p>Parameters:</p> <ul> <li><code>float C</code>: Constant value to add.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#subtraction-assignment-operator","title":"Subtraction Assignment Operator","text":"<pre><code>Mat &amp;Mat::operator-=(const Mat &amp;A);\n</code></pre> <p>Description: Subtracts the source matrix from the current matrix.</p> <p>Parameters:</p> <ul> <li><code>const Mat &amp;A</code>: Source matrix to subtract.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#subtraction-assignment-operator-with-constant","title":"Subtraction Assignment Operator (with constant)","text":"<pre><code>Mat &amp;Mat::operator-=(float C);\n</code></pre> <p>Description: Subtracts a constant value from the current matrix.</p> <p>Parameters:</p> <ul> <li><code>float C</code>: Constant value to subtract.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#multiplication-assignment-operator","title":"Multiplication Assignment Operator","text":"<pre><code>Mat &amp;Mat::operator*=(const Mat &amp;A);\n</code></pre> <p>Description: Multiplies the current matrix by the source matrix.</p> <p>Parameters:</p> <ul> <li><code>const Mat &amp;A</code>: Source matrix to multiply.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#multiplication-assignment-operator-with-constant","title":"Multiplication Assignment Operator (with constant)","text":"<pre><code>Mat &amp;Mat::operator*=(float C);\n</code></pre> <p>Description: Multiplies the current matrix by a constant value.</p> <p>Parameters:</p> <ul> <li><code>float C</code>: Constant value to multiply.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#division-assignment-operator","title":"Division Assignment Operator","text":"<pre><code>Mat &amp;Mat::operator/=(const Mat &amp;B); // by element\n</code></pre> <p>Description: Divides the current matrix by the source matrix.</p> <p>Parameters:</p> <ul> <li><code>const Mat &amp;B</code>: Source matrix to divide by.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#division-assignment-operator-by-constant","title":"Division Assignment Operator (by constant)","text":"<pre><code>Mat &amp;Mat::operator/=(float C);\n</code></pre> <p>Description: Divides the current matrix by a constant value.</p> <p>Parameters:</p> <ul> <li><code>float C</code>: Constant value to divide by.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#power-operator","title":"Power Operator","text":"<pre><code>Mat Mat::operator^(int C);\n</code></pre> <p>Description: Raises the current matrix to the power of a constant value.</p> <p>Parameters:</p> <ul> <li><code>int C</code>: Constant value to raise the matrix to.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#linear-algebra","title":"LINEAR ALGEBRA","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#normalize-function","title":"Normalize Function","text":"<pre><code>void Mat::normalize();\n</code></pre> <p>Description: Normalizes the current matrix.</p> <p>Parameters: None.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#norm-function","title":"Norm Function","text":"<pre><code>float Mat::norm();\n</code></pre> <p>Description: Computes the norm of the current matrix.</p> <p>Parameters: None.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#determinant-function","title":"Determinant Function","text":"<pre><code>float Mat::det(int n);\n</code></pre> <p>Description: Computes the determinant of the current matrix.</p> <p>Parameters:</p> <ul> <li><code>int n</code>: Size of the matrix.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#transpose-function","title":"Transpose Function","text":"<pre><code>Mat Mat::t();\n</code></pre> <p>Description: Computes the transpose of the current matrix.</p> <p>Parameters: None.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#inverse-function","title":"Inverse Function","text":"<pre><code>Mat Mat::inverse();\n</code></pre> <p>Description: Computes the inverse of the current matrix.</p> <p>Parameters: None.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#pseudo-inverse-function","title":"Pseudo-Inverse Function","text":"<pre><code>Mat Mat::pinv();\n</code></pre> <p>Description: Computes the pseudo-inverse of the current matrix.</p> <p>Parameters: None.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#gaussian-elimination-function","title":"Gaussian Elimination Function","text":"<pre><code>Mat Mat::gaussianEliminate();\n</code></pre> <p>Description: Performs Gaussian elimination on the current matrix.</p> <p>Parameters: None.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#row-reduce-from-gaussian-function","title":"Row Reduce from Gaussian Function","text":"<pre><code>Mat Mat::rowReduceFromGaussian();\n</code></pre> <p>Description: Performs row reduction from Gaussian elimination on the current matrix.</p> <p>Parameters: None.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#static-utility-functions","title":"STATIC UTILITY FUNCTIONS","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#identity-matrix-function","title":"Identity Matrix Function","text":"<pre><code>Mat Mat::eye(int size);\n</code></pre> <p>Description: Creates an identity matrix of the specified size.</p> <p>Parameters:</p> <ul> <li><code>int size</code>: Size of the identity matrix.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#ones-square-matrix-function","title":"Ones Square Matrix Function","text":"<pre><code>Mat Mat::ones(int size);\n</code></pre> <p>Description: Creates a square matrix filled with ones.</p> <p>Parameters:</p> <ul> <li><code>int size</code>: Size of the square matrix.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#ones-rectangular-matrix-function","title":"Ones Rectangular Matrix Function","text":"<pre><code>Mat Mat::ones(int rows, int cols);\n</code></pre> <p>Description: Creates a rectangular matrix filled with ones.</p> <p>Parameters:</p> <ul> <li> <p><code>int rows</code>: Number of rows in the matrix.</p> </li> <li> <p><code>int cols</code>: Number of columns in the matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#solve-function","title":"Solve Function","text":"<pre><code>Mat Mat::solve(Mat A, Mat b);\n</code></pre> <p>Description: Solves the linear equation Ax = b.</p> <p>Parameters:</p> <ul> <li> <p><code>Mat A</code>: Coefficient matrix.</p> </li> <li> <p><code>Mat b</code>: Right-hand side matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#band-solve-function","title":"Band Solve Function","text":"<pre><code>Mat Mat::bandSolve(Mat A, Mat b, int k);\n</code></pre> <p>Description: Solves the banded linear equation Ax = b.</p> <p>Parameters:</p> <ul> <li> <p><code>Mat A</code>: Coefficient matrix.</p> </li> <li> <p><code>Mat b</code>: Right-hand side matrix.</p> </li> <li> <p><code>int k</code>: Bandwidth of the matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#roots-function","title":"Roots Function","text":"<pre><code>Mat Mat::roots(Mat A, Mat y);\n</code></pre> <p>Description: Computes the roots of the polynomial defined by the matrix A.</p> <p>Parameters:</p> <ul> <li> <p><code>Mat A</code>: Coefficient matrix.</p> </li> <li> <p><code>Mat y</code>: Right-hand side matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#dot-product-function","title":"Dot Product Function","text":"<pre><code>float Mat::dotProduct(Mat A, Mat B);\n</code></pre> <p>Description: Computes the dot product of two matrices.</p> <p>Parameters:</p> <ul> <li> <p><code>Mat A</code>: First matrix.</p> </li> <li> <p><code>Mat B</code>: Second matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#augment-function","title":"Augment Function","text":"<pre><code>Mat Mat::augment(Mat A, Mat B);\n</code></pre> <p>Description: Augments two matrices.</p> <p>Parameters:</p> <ul> <li> <p><code>Mat A</code>: First matrix.</p> </li> <li> <p><code>Mat B</code>: Second matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#cofactor-function","title":"Cofactor Function","text":"<pre><code>Mat Mat::cofactor(int row, int col, int n);\n</code></pre> <p>Description: Computes the cofactor of the current matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>int row</code>: Row index of the element.</p> </li> <li> <p><code>int col</code>: Column index of the element.</p> </li> <li> <p><code>int n</code>: Size of the matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#adjoint-function","title":"Adjoint Function","text":"<pre><code>Mat Mat::adjoint();\n</code></pre> <p>Description: Computes the adjoint of the current matrix.</p> <p>Parameters: None.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#exponential-helper-function","title":"Exponential Helper Function","text":"<pre><code>Mat Mat::expHelper(const Mat &amp;m, int num);\n</code></pre> <p>Description: Helper function for computing the matrix exponential.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;m</code>: Matrix to compute the exponential of.</p> </li> <li> <p><code>int num</code>: Number of terms in the series expansion.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#stream-operators","title":"STREAM OPERATORS","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#output-stream-operator","title":"Output Stream Operator","text":"<pre><code>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat &amp;m);\n</code></pre> <p>Description: Overloads the output stream operator to print the matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>std::ostream &amp;os</code>: Output stream.</p> </li> <li> <p><code>const Mat &amp;m</code>: Matrix to print.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#output-stream-operator-rect","title":"Output Stream Operator (Rect)","text":"<pre><code>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat::Rect &amp;rect);\n</code></pre> <p>Description: Overloads the output stream operator to print the Rect structure.</p> <p>Parameters:</p> <ul> <li> <p><code>std::ostream &amp;os</code>: Output stream.</p> </li> <li> <p><code>const Mat::Rect &amp;rect</code>: Rect structure to print.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#input-stream-operator","title":"Input Stream Operator","text":"<pre><code>std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Mat &amp;m);\n</code></pre> <p>Description: Overloads the input stream operator to read a matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>std::istream &amp;is</code>: Input stream.</p> </li> <li> <p><code>Mat &amp;m</code>: Matrix to read into.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#global-arithmetic-operators","title":"GLOBAL ARITHMETIC OPERATORS","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#addition-operator","title":"Addition Operator","text":"<pre><code>Mat operator+(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>Description: Adds two matrices.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code>: First matrix.</p> </li> <li> <p><code>const Mat &amp;B</code>: Second matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#addition-operator-with-constant","title":"Addition Operator (with constant)","text":"<pre><code>Mat operator+(const Mat &amp;A, float C);\n</code></pre> <p>Description: Adds a constant value to a matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code>: Matrix to add to.</p> </li> <li> <p><code>float C</code>: Constant value to add.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#subtraction-operator","title":"Subtraction Operator","text":"<pre><code>Mat operator-(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>Description: Subtracts one matrix from another.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code>: First matrix.</p> </li> <li> <p><code>const Mat &amp;B</code>: Second matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#subtraction-operator-with-constant","title":"Subtraction Operator (with constant)","text":"<pre><code>Mat operator-(const Mat &amp;A, float C);\n</code></pre> <p>Description: Subtracts a constant value from a matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code>: Matrix to subtract from.</p> </li> <li> <p><code>float C</code>: Constant value to subtract.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#multiplication-operator","title":"Multiplication Operator","text":"<pre><code>Mat operator*(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>Description: Multiplies two matrices.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code>: First matrix.</p> </li> <li> <p><code>const Mat &amp;B</code>: Second matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#multiplication-operator-with-constant","title":"Multiplication Operator (with constant)","text":"<pre><code>Mat operator*(const Mat &amp;A, float C);\n</code></pre> <p>Description: Multiplies a matrix by a constant value.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code>: Matrix to multiply.</p> </li> <li> <p><code>float C</code>: Constant value to multiply by.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#multiplication-operator-with-constant-on-left","title":"Multiplication Operator (with constant on left)","text":"<pre><code>Mat operator*(float C, const Mat &amp;A);\n</code></pre> <p>Description: Multiplies a constant value by a matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>float C</code>: Constant value to multiply by.</p> </li> <li> <p><code>const Mat &amp;A</code>: Matrix to multiply.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#division-operator","title":"Division Operator","text":"<pre><code>Mat operator/(const Mat &amp;A, float C);\n</code></pre> <p>Description: Divides a matrix by a constant value.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code>: Matrix to divide.</p> </li> <li> <p><code>float C</code>: Constant value to divide by.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#division-operator-by-matrix","title":"Division Operator (by matrix)","text":"<pre><code>Mat operator/(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>Description: Divides one matrix by another.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code>: Matrix to divide.</p> </li> <li> <p><code>const Mat &amp;B</code>: Matrix to divide by.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#equality-operator","title":"Equality Operator","text":"<pre><code>bool operator==(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>Description: Compares two matrices for equality.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code>: First matrix.</p> </li> <li> <p><code>const Mat &amp;B</code>: Second matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-code/","title":"CODE","text":""},{"location":"MATH/MATRIX/tiny-matrix-code/#tiny_matrixh","title":"tiny_matrix.h","text":"<pre><code>/**\n * @file tiny_matrix.hpp\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the submodule matrix (advanced matrix operations) of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-17\n * @note This file is built on top of the mat.h file from the ESP-DSP library.\n *\n */\n\n#pragma once\n\n/* DEPENDENCIES */\n// TinyMath\n#include \"tiny_math_config.h\"\n#include \"tiny_vec.h\"\n#include \"tiny_mat.h\"\n\n// Standard Libraries\n#include &lt;iostream&gt;\n#include &lt;stdint.h&gt;\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n// ESP32 DSP C++ Matrix library\n#include \"mat.h\"\n#endif\n\n/* STATEMENTS */\nnamespace tiny\n{\n    class Mat\n    {\n    public:\n        /* === Matrix Metadata === */\n        int rows;        /*!&lt; Amount of rows*/\n        int cols;        /*!&lt; Amount of columns*/\n        int stride;      /*!&lt; Stride = (number of elements in a row) + padding*/\n        int padding;     /*!&lt; Padding between 2 rows*/\n        int length;      /*!&lt; Total amount of data in data array*/\n        float *data;     /*!&lt; Buffer with matrix data*/\n        bool ext_buff;   /*!&lt; Flag indicates that matrix use external buffer*/\n        bool sub_matrix; /*!&lt; Flag indicates that matrix is a subset of another matrix*/\n\n        /* === Rectangular ROI Structure === */\n        /**\n         * @brief Rectangular area\n         *\n         * The Rect is used for creating regions of interest ROI(s). The ROI is then used as a sub-matrix\n         */\n        struct Rect\n        {\n            int x;      ///&lt; starting column index\n            int y;      ///&lt; starting row index\n            int width;  ///&lt; width of ROI (columns)\n            int height; ///&lt; height of ROI (rows)\n\n            /**\n             * @brief Constructor with initialization to 0\n             *\n             * @param[in] x: x starting position (start col) of the rectangular area\n             * @param[in] y: y starting position (start row) of the rectangular area\n             * @param[in] width: width (number of cols) of the rectangular area\n             * @param[in] height: height (number of rows) of the rectangular area\n             */\n            Rect(int x = 0, int y = 0, int width = 0, int height = 0);\n\n            /**\n             * @brief Resize rect area\n             *\n             * @param[in] x: x starting position (start col) of the new rectangular area\n             * @param[in] y: y starting position (start row) of the new rectangular area\n             * @param[in] width: width (number of cols) of the new rectangular area\n             * @param[in] height: height (number of rows) of the new rectangular area\n             */\n            void resizeRect(int x, int y, int width, int height);\n\n            /**\n             * @brief Get amount of elements in the rect area\n             */\n            int areaRect(void) const;\n        };\n\n        /* === Constructors &amp; Destructor === */\n        /**\n         * Allocate matrix with undefined size.\n         */\n        Mat();\n        /**\n         * @brief Construct a new Mat object (internal allocation)\n         *\n         * @param rows Number of rows\n         * @param cols Number of columns\n         */\n        Mat(int rows, int cols);\n        /**\n         * @brief Construct a new Mat object (external allocation)\n         *\n         * @param data Pointer to external data buffer\n         * @param rows Number of rows\n         * @param cols Number of columns\n         */\n        Mat(float *data, int rows, int cols);\n        /**\n         * @brief Construct a new Mat object (external allocation with stride)\n         *\n         * @param data Pointer to external data buffer\n         * @param rows Number of rows\n         * @param cols Number of columns\n         * @param stride Stride (number of elements in a row)\n         */\n        Mat(float *data, int rows, int cols, int stride);\n        /**\n         * @brief Make copy of matrix.\n         *\n         * if src matrix is sub matrix, only the header is copied\n         * if src matrix is matrix, header and data are copied\n         *\n         * @param[in] src: source matrix\n         */\n        Mat(const Mat &amp;src);\n        /**\n         * @brief Destroy the Mat object, freeing internal memory\n         */\n        ~Mat();\n        /**\n         * @brief Allocate internal memory buffer\n         */\n        void allocate(); // Allocate internal memory\n\n        /* === Element Access === */\n        inline float &amp;operator()(int row, int col) { return data[row * stride + col]; }             // for non-const\n        inline const float &amp;operator()(int row, int col) const { return data[row * stride + col]; } // for const\n\n        /* === Data Manipulation === */\n        /**\n         * Make copy of matrix. Memory not shared.\n         * @param[in] src: source matrix\n         * @param[in] row_pos: start row position of destination matrix\n         * @param[in] col_pos: start col position of destination matrix\n         */\n        void Copy(const Mat &amp;src, int row_pos, int col_pos);\n        /**\n         * @brief Copy header of matrix. Memory shared.\n         *\n         * Make a shallow copy of matrix (no data copy)\n         * @param[in] src: source matrix\n         */\n        void CopyHead(const Mat &amp;src);\n        /**\n         * @brief Create a subset of matrix as ROI (Region of Interest)\n         *\n         * @param[in] startRow: start row position of source matrix to get the subset matrix from\n         * @param[in] startCol: start col position of source matrix to get the subset matrix from\n         * @param[in] roiRows: size of row elements of source matrix to get the subset matrix from\n         * @param[in] roiCols: size of col elements of source matrix to get the subset matrix from\n         * @param[in] stride: number of cols + padding between 2 rows\n         *\n         * @return\n         *      - result matrix size roiRows x roiCols\n         */\n        Mat getROI(int startRow, int startCol, int roiRows, int roiCols, int stride);\n        /**\n         * @brief Create a subset of matrix as ROI (Region of Interest)\n         *\n         * @param[in] startRow: start row position of source matrix to get the subset matrix from\n         * @param[in] startCol: start col position of source matrix to get the subset matrix from\n         * @param[in] roiRows: size of row elements of source matrix to get the subset matrix from\n         * @param[in] roiCols: size of col elements of source matrix to get the subset matrix from\n         *\n         * @return\n         *      - result matrix size roiRows x roiCols\n         */\n        Mat getROI(int startRow, int startCol, int roiRows, int roiCols);\n        /**\n         * @brief Create a subset of matrix as ROI (Region of Interest)\n         *\n         * @param[in] rect: rectangular area of interest\n         *\n         * @return\n         *      - result matrix size rect.rectRows x rect.rectCols\n         */\n        Mat getROI(const Rect &amp;rect);\n        /**\n         * Make copy of matrix.\n         * @param[in] row_start: start row position of source matrix to copy\n         * @param[in] row_size: size of wor elements of source matrix to copy\n         * @param[in] col_start: start col position of source matrix to copy\n         * @param[in] col_size: size of wor elements of source matrix to copy\n         *\n         * @return\n         *      - result matrix size row_size x col_size\n         */\n        Mat Get(int row_start, int row_size, int col_start, int col_size);\n        /**\n         * Make copy of matrix.\n         * @param[in] rect: rectangular area of interest\n         * @return\n         *      - result matrix size row_size x col_size\n         */\n        Mat Get(const Rect &amp;rect);\n        /**\n         * Return part of matrix from defined position (startRow, startCol) as a matrix[blockRows x blockCols].\n         *\n         * @param[in] startRow: start row position\n         * @param[in] startCol: start column position\n         * @param[in] blockRows: amount of rows in result matrix\n         * @param[in] blockCols: amount of columns in the result matrix\n         *\n         * @return\n         *      - matrix [blockRows]x[blockCols]\n         */\n        Mat block(int startRow, int startCol, int blockRows, int blockCols);\n        /**\n         * Swap two rows between each other.\n         * @param[in] row1: position of first row\n         * @param[in] row2: position of second row\n         */\n        void swapRows(int row1, int row2);\n        /**\n         * The method fill 0 to the matrix structure.\n         *\n         */\n        void clear();\n\n        /* === Print &amp; Debug === */\n        /**\n         * @brief print matrix header\n         *\n         * Print all information about matrix to the terminal\n         * @param[in] src: source matrix\n         */\n        void PrintHead();\n        /**\n         * @brief print matrix header and data\n         *\n         * Print all information about matrix to the terminal\n         * @param[in] show_padding: show padding information\n         * @param[in] label: label for the matrix\n         */\n        void PrintMatrix(bool show_padding, const std::string &amp;label);\n\n        /* === Arithmetic Operators === */\n        /**\n         * Copy operator\n         *\n         * @param[in] src: source matrix\n         *\n         * @return\n         *      - matrix copy\n         */\n        Mat &amp;operator=(const Mat &amp;src); // Copy assignment\n        /**\n         * += operator\n         * The operator use DSP optimized implementation of multiplication.\n         *\n         * @param[in] A: source matrix\n         *\n         * @return\n         *      - result matrix: result += A\n         */\n        Mat &amp;operator+=(const Mat &amp;A);\n        /**\n         * += operator\n         * The operator use DSP optimized implementation of multiplication.\n         *\n         * @param[in] C: constant\n         *\n         * @return\n         *      - result matrix: result += C\n         */\n        Mat &amp;operator+=(float C);\n        /**\n         * -= operator\n         * The operator use DSP optimized implementation of multiplication.\n         *\n         * @param[in] A: source matrix\n         *\n         * @return\n         *      - result matrix: result -= A\n         */\n        Mat &amp;operator-=(const Mat &amp;A);\n        /**\n         * -= operator\n         * The operator use DSP optimized implementation of multiplication.\n         *\n         * @param[in] C: constant\n         *\n         * @return\n         *      - result matrix: result -= C\n         */\n        Mat &amp;operator-=(float C);\n        /**\n         * *= operator\n         * The operator use DSP optimized implementation of multiplication.\n         *\n         * @param[in] A: source matrix\n         *\n         * @return\n         *      - result matrix: result -= A\n         */\n        Mat &amp;operator*=(const Mat &amp;A);\n        /**\n         * += with constant operator\n         * The operator use DSP optimized implementation of multiplication.\n         *\n         * @param[in] C: constant value\n         *\n         * @return\n         *      - result matrix: result *= C\n         */\n        Mat &amp;operator*=(float C);\n        /**\n         * /= operator\n         *\n         * @param[in] B: source matrix\n         *\n         * @return\n         *      - result matrix: result[i,j] = result[i,j]/B[i,j]\n         */\n        Mat &amp;operator/=(const Mat &amp;B);\n        /**\n         * /= with constant operator\n         * The operator use DSP optimized implementation of multiplication.\n         *\n         * @param[in] C: constant value\n         *\n         * @return\n         *      - result matrix: result /= C\n         */\n        Mat &amp;operator/=(float C);\n        /**\n         * ^= exponentiation operator\n         * The operator use DSP optimized implementation of multiplication.\n         *\n         * @param[in] num: exponent\n         *\n         * @return\n         *      - result matrix: result = result^num\n         */\n        Mat operator^(int C);\n\n        /* === Linear Algebra === */\n        /**\n         * @brief Normalize the matrix\n         *\n         * The method normalize the matrix to unit length.\n         */\n        void normalize();\n        /**\n         * @brief Calculate the matrix norm\n         *\n         * The method calculate the matrix norm.\n         *\n         * @return\n         *      - result matrix norm\n         */\n        float norm();\n        /**\n         * @brief Calculate the determinant of the matrix\n         *\n         * The method calculate the determinant of the matrix.\n         *\n         * @param n: size of the matrix\n         *\n         * @return\n         *      - result matrix determinant\n         */\n        float det(int n);\n        /**\n         * Matrix transpose.\n         * Change rows and columns between each other.\n         *\n         * @return\n         *      - transposed matrix\n         */\n        Mat t();\n        /**\n         * Find the inverse matrix\n         *\n         * @return\n         *      - inverse matrix\n         */\n        Mat inverse();\n        /**\n         * Find pseudo inverse matrix\n         *\n         * @return\n         *      - inverse matrix\n         */\n        Mat pinv();\n        /**\n         * @brief   Gaussian Elimination\n         *\n         * Gaussian Elimination of matrix\n         *\n         * @return\n         *      - result matrix\n         */\n        Mat gaussianEliminate();\n        /**\n         * Row reduction for Gaussian elimination\n         *\n         * @return\n         *      - result matrix\n         */\n        Mat rowReduceFromGaussian();\n\n        /* === Static Utility Functions === */\n        /**\n         * Create identity matrix.\n         * Create a square matrix and fill diagonal with 1.\n         *\n         * @param[in] size: matrix size\n         *\n         * @return\n         *      - matrix [N]x[N] with 1 in diagonal\n         */\n        static Mat eye(int size);\n        /**\n         * Create matrix with all elements 1.\n         * Create a square matrix and fill all elements with 1.\n         *\n         * @param[in] size: matrix size\n         *\n         * @return\n         *      - matrix [N]x[N] with 1 in all elements\n         */\n        static Mat ones(int size);\n        /**\n         * Create matrix with all elements 1.\n         * Create a matrix and fill all elements with 1.\n         *\n         * @param[in] rows: matrix rows\n         * @param[in] cols: matrix cols\n         *\n         * @return\n         *      - matrix [N]x[N] with 1 in all elements\n         */\n        static Mat ones(int rows, int cols);\n        /**\n         * @brief   Solve the matrix\n         *\n         * Solve matrix. Find roots for the matrix A*x = b\n         *\n         * @param[in] A: matrix [N]x[N] with input coefficients\n         * @param[in] b: vector [N]x[1] with result values\n         *\n         * @return\n         *      - matrix [N]x[1] with roots\n         */\n        static Mat solve(Mat A, Mat b);\n        /**\n         * @brief   Band solve the matrix\n         *\n         * Solve band matrix. Find roots for the matrix A*x = b with bandwidth k.\n         *\n         * @param[in] A: matrix [N]x[N] with input coefficients\n         * @param[in] b: vector [N]x[1] with result values\n         * @param[in] k: upper bandwidth value\n         *\n         * @return\n         *      - matrix [N]x[1] with roots\n         */\n        static Mat bandSolve(Mat A, Mat b, int k);\n        /**\n         * @brief   Solve the matrix\n         *\n         * Different way to solve the matrix. Find roots for the matrix A*x = y\n         *\n         * @param[in] A: matrix [N]x[N] with input coefficients\n         * @param[in] y: vector [N]x[1] with result values\n         *\n         * @return\n         *      - matrix [N]x[1] with roots\n         */\n        static Mat roots(Mat A, Mat y);\n        /**\n         * @brief   Dotproduct of two vectors\n         *\n         * The method returns dotproduct of two vectors\n         *\n         * @param[in] A: Input vector A Nx1\n         * @param[in] B: Input vector B Nx1\n         *\n         * @return\n         *      - dotproduct value\n         */\n        static float dotProduct(Mat A, Mat B);\n        /**\n         * @brief   Augmented matrices (concatenate two matrices horizontally)\n         *\n         * Augmented matrices\n         *\n         * @param[in] A: Input vector A MxN\n         * @param[in] B: Input vector B MxK\n         *\n         * @return\n         *      - Augmented matrix Mx(N+K)\n         */\n        static Mat augment(Mat A, Mat B);\n\n    private:\n        /* === Private Utility Functions === */\n        /**\n         * @brief   Calculate cofactor matrix\n         *\n         * Calculate cofactor matrix of the matrix\n         *\n         * @param[in] row: row position\n         * @param[in] col: column position\n         * @param[in] n: size of the matrix\n         *\n         * @return\n         *      - cofactor matrix\n         */\n        Mat cofactor(int row, int col, int n);\n        /**\n         * @brief   Calculate adjoint matrix\n         *\n         * Calculate adjoint matrix of the matrix\n         *\n         * @return\n         *      - adjoint matrix\n         */\n        Mat adjoint();\n        /**\n         * @brief   Calculate matrix exponential\n         *\n         * Calculate matrix exponential of the matrix\n         *\n         * @param[in] m: input matrix\n         * @param[in] num: number of iterations\n         *\n         * @return\n         *      - matrix exponential\n         */\n        Mat expHelper(const Mat &amp;m, int num);\n    };\n\n    /* === Stream Operators === */\n    /**\n     * Print matrix to the standard iostream.\n     * @param[in] os: output stream\n     * @param[in] m: matrix to print\n     *\n     * @return\n     *      - output stream\n     */\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat &amp;m);\n    /**\n     * Print rectangular ROI to the standard iostream.\n     * @param[in] os: output stream\n     * @param[in] rect: ROI\n     *\n     * @return\n     *      - output stream\n     */\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat::Rect &amp;rect);\n    /**\n     * Fill the matrix from iostream.\n     * @param[in] is: input stream\n     * @param[in] m: matrix to fill\n     *\n     * @return\n     *      - input stream\n     */\n    std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Mat &amp;m);\n\n    /* === Global Arithmetic Operators === */\n    /**\n     * + operator, sum of two matrices\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] B: Input matrix B\n     *\n     * @return\n     *     - result matrix A+B\n     */\n    Mat operator+(const Mat &amp;A, const Mat &amp;B);\n    /**\n     * + operator, sum of matrix with constant\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] C: Input constant\n     *\n     * @return\n     *     - result matrix A+C\n     */\n    Mat operator+(const Mat &amp;A, float C);\n    /**\n     * - operator, subtraction of two matrices\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] B: Input matrix B\n     *\n     * @return\n     *     - result matrix A-B\n     */\n    Mat operator-(const Mat &amp;A, const Mat &amp;B);\n    /**\n     * - operator, subtraction of matrix with constant\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] C: Input constant\n     *\n     * @return\n     *     - result matrix A-C\n     */\n    Mat operator-(const Mat &amp;A, float C);\n    /**\n     * * operator, multiplication of two matrices.\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] B: Input matrix B\n     *\n     * @return\n     *     - result matrix A*B\n     */\n    Mat operator*(const Mat &amp;A, const Mat &amp;B);\n    /**\n     * * operator, multiplication of matrix with constant\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] C: floating point value\n     *\n     * @return\n     *     - result matrix A*B\n     */\n    Mat operator*(const Mat &amp;A, float C);\n    /**\n     * * operator, multiplication of matrix with constant\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] C: floating point value\n     * @param[in] A: Input matrix A\n     *\n     * @return\n     *     - result matrix C*A\n     */\n    Mat operator*(float C, const Mat &amp;A);\n    /**\n     * / operator, divide of matrix by constant\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] C: floating point value\n     *\n     * @return\n     *     - result matrix A/C\n     */\n    Mat operator/(const Mat &amp;A, float C);\n    /**\n     * / operator, divide matrix A by matrix B (element-wise)\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] B: Input matrix B\n     *\n     * @return\n     *     - result matrix C, where C[i,j] = A[i,j]/B[i,j]\n     */\n    Mat operator/(const Mat &amp;A, const Mat &amp;B);\n    /**\n     * == operator, compare two matrices\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] B: Input matrix B\n     *\n     * @return\n     *      - true if matrices are the same\n     *      - false if matrices are different\n     */\n    bool operator==(const Mat &amp;A, const Mat &amp;B);\n\n}\n</code></pre>"},{"location":"MATH/MATRIX/tiny-matrix-code/#tiny_matrixc","title":"tiny_matrix.c","text":"<pre><code>/**\n * @file tiny_matrix.cpp\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the source file for the submodule matrix (advanced matrix operations) of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-17\n * @copyright Copyright (c) 2025\n *\n */\n\n/* DEPENDENCIES */\n// TinyMath\n#include \"tiny_matrix.hpp\"\n\n// Standard Libraries\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\n#include &lt;cmath&gt;\n#include &lt;inttypes.h&gt;\n#include &lt;iomanip&gt;\n\n// Namespace\nusing std::endl;\nusing std::istream;\nusing std::ostream;\n\n/* LIBRARIE CONTENTS */\nnamespace tiny\n{\n    /* === Rectangular ROI Structure === */\n\n    /**\n     * @brief Constructor with initialization to 0\n     *\n     * @param[in] x: x starting position (start col) of the rectangular area\n     * @param[in] y: y starting position (start row) of the rectangular area\n     * @param[in] width: width (number of cols) of the rectangular area\n     * @param[in] height: height (number of rows) of the rectangular area\n     */\n    Mat::Rect::Rect(int x, int y, int width, int height)\n        : x(x), y(y), width(width), height(height) {}\n\n    /**\n     * @brief Resize rect area\n     *\n     * @param[in] x: x starting position (start col) of the new rectangular area\n     * @param[in] y: y starting position (start row) of the new rectangular area\n     * @param[in] width: width (number of cols) of the new rectangular area\n     * @param[in] height: height (number of rows) of the new rectangular area\n     */\n    void Mat::Rect::resizeRect(int x, int y, int width, int height)\n    {\n        this-&gt;x = x;\n        this-&gt;y = y;\n        this-&gt;width = width;\n        this-&gt;height = height;\n    }\n\n    /**\n     * @brief Get amount of elements in the rect area\n     */\n    int Mat::Rect::areaRect(void) const\n    {\n        return width * height;\n    }\n\n    /* === Constructors &amp; Destructor === */\n    /**\n     * Allocate matrix with undefined size.\n     */\n    Mat::Mat()\n        : rows(1), cols(1), stride(1), padding(0), length(1),\n          data(nullptr), ext_buff(false), sub_matrix(false)\n    {\n        allocate();\n        std::memset(this-&gt;data, 0, this-&gt;length * sizeof(float));\n    }\n\n    /**\n     * @brief Construct a new Mat object (internal allocation)\n     *\n     * @param rows Number of rows\n     * @param cols Number of columns\n     */\n    Mat::Mat(int rows, int cols)\n        : rows(rows), cols(cols), stride(cols), padding(0), length(rows * cols),\n          data(nullptr), ext_buff(false), sub_matrix(false)\n    {\n        allocate();\n        std::memset(this-&gt;data, 0, this-&gt;length * sizeof(float));\n    }\n\n    /**\n     * @brief Construct a new Mat object (external allocation)\n     *\n     * @param data Pointer to external data buffer\n     * @param rows Number of rows\n     * @param cols Number of columns\n     */\n    Mat::Mat(float *data, int rows, int cols)\n        : rows(rows), cols(cols), stride(cols), padding(0), length(rows * cols),\n          data(data), ext_buff(true), sub_matrix(false) {}\n\n    /**\n     * @brief Construct a new Mat object (external allocation with stride)\n     *\n     * @param data Pointer to external data buffer\n     * @param rows Number of rows\n     * @param cols Number of columns\n     * @param stride Stride (number of elements in a row)\n     */\n    Mat::Mat(float *data, int rows, int cols, int stride)\n        : rows(rows), cols(cols), stride(stride), padding(stride - cols), length(rows * cols),\n          data(data), ext_buff(true), sub_matrix(false) {}\n\n    /**\n     * @brief Make copy of matrix.\n     *\n     * if src matrix is sub matrix, only the header is copied\n     * if src matrix is matrix, header and data are copied\n     *\n     * @param[in] src: source matrix\n     */\n    Mat::Mat(const Mat &amp;m)\n        : rows(m.rows), cols(m.cols), stride(m.stride), padding(m.padding), length(m.length),\n          data(nullptr), ext_buff(false), sub_matrix(m.sub_matrix)\n    {\n        if (m.sub_matrix)\n        {\n            this-&gt;data = m.data;\n            this-&gt;ext_buff = true;\n        }\n        else\n        {\n            allocate();\n            std::memcpy(this-&gt;data, m.data, this-&gt;length * sizeof(float));\n        }\n    }\n\n    /**\n     * @brief Destroy the Mat object, freeing internal memory\n     */\n    Mat::~Mat()\n    {\n        if (!this-&gt;ext_buff &amp;&amp; this-&gt;data)\n        {\n            delete[] this-&gt;data;\n        }\n    }\n\n    /**\n     * @brief Allocate internal memory buffer\n     */\n    void Mat::allocate()\n    {\n        this-&gt;ext_buff = false;\n        this-&gt;length = this-&gt;rows * this-&gt;cols;\n        this-&gt;data = new float[this-&gt;length];\n    }\n    /* === Element Access === */\n    // Already defined by inline functions in the header file\n\n    /* === Data Manipulation === */\n    /**\n     * Make copy of matrix. Memory not shared.\n     * @param[in] src: source matrix\n     * @param[in] row_pos: start row position of destination matrix\n     * @param[in] col_pos: start col position of destination matrix\n     */\n    void Mat::Copy(const Mat &amp;src, int row_pos, int col_pos)\n    {\n        if ((row_pos + src.rows) &gt; this-&gt;rows)\n        {\n            return;\n        }\n        if ((col_pos + src.cols) &gt; this-&gt;cols)\n        {\n            return;\n        }\n\n        for (size_t r = 0; r &lt; src.rows; r++)\n        {\n            memcpy(&amp;this-&gt;data[(r + row_pos) * this-&gt;stride + col_pos], &amp;src.data[r * src.cols], src.cols * sizeof(float));\n        }\n    }\n\n    /**\n     * @brief Copy header of matrix. Memory shared.\n     *\n     * Make a shallow copy of matrix (no data copy)\n     * @param[in] src: source matrix\n     */\n    void Mat::CopyHead(const Mat &amp;src)\n    {\n        if (!this-&gt;ext_buff)\n        {\n            delete[] this-&gt;data;\n        }\n        this-&gt;rows = src.rows;\n        this-&gt;cols = src.cols;\n        this-&gt;length = src.length;\n        this-&gt;padding = src.padding;\n        this-&gt;stride = src.stride;\n        this-&gt;data = src.data;\n        this-&gt;ext_buff = src.ext_buff;\n        this-&gt;sub_matrix = src.sub_matrix;\n    }\n\n    /**\n     * @brief Create a subset of matrix as ROI (Region of Interest)\n     *\n     * @param[in] startRow: start row position of source matrix to get the subset matrix from\n     * @param[in] startCol: start col position of source matrix to get the subset matrix from\n     * @param[in] roiRows: size of row elements of source matrix to get the subset matrix from\n     * @param[in] roiCols: size of col elements of source matrix to get the subset matrix from\n     * @param[in] stride: number of cols + padding between 2 rows\n     *\n     * @return\n     *      - result matrix size roiRows x roiCols\n     */\n    Mat Mat::getROI(int startRow, int startCol, int roiRows, int roiCols, int stride)\n    {\n        Mat result(this-&gt;data, roiRows, roiCols, 0); // this is an illegal matrix, for illegal access\n\n        if ((startRow + roiRows) &gt; this-&gt;rows)\n        {\n            return result;\n        }\n        if ((startCol + roiCols) &gt; this-&gt;cols)\n        {\n            return result;\n        }\n\n        const int ptr_move = startRow * this-&gt;cols + startCol;\n        float *new_data_ptr = this-&gt;data + ptr_move;\n\n        result.data = new_data_ptr;\n        result.stride = stride;\n        result.padding = result.stride - result.cols;\n        return result;\n    }\n\n    /**\n     * @brief Create a subset of matrix as ROI (Region of Interest)\n     *\n     * @param[in] startRow: start row position of source matrix to get the subset matrix from\n     * @param[in] startCol: start col position of source matrix to get the subset matrix from\n     * @param[in] roiRows: size of row elements of source matrix to get the subset matrix from\n     * @param[in] roiCols: size of col elements of source matrix to get the subset matrix from\n     *\n     * @return\n     *      - result matrix size roiRows x roiCols\n     */\n    Mat Mat::getROI(int startRow, int startCol, int roiRows, int roiCols)\n    {\n        return (getROI(startRow, startCol, roiRows, roiCols, this-&gt;cols));\n    }\n\n    /**\n     * @brief Create a subset of matrix as ROI (Region of Interest)\n     *\n     * @param[in] rect: rectangular area of interest\n     *\n     * @return\n     *      - result matrix size rect.rectRows x rect.rectCols\n     */\n    Mat Mat::getROI(const Mat::Rect &amp;rect)\n    {\n        return (getROI(rect.y, rect.x, rect.height, rect.width, this-&gt;cols));\n    }\n\n    /**\n     * Make copy of matrix.\n     * @param[in] row_start: start row position of source matrix to copy\n     * @param[in] row_size: size of wor elements of source matrix to copy\n     * @param[in] col_start: start col position of source matrix to copy\n     * @param[in] col_size: size of wor elements of source matrix to copy\n     *\n     * @return\n     *      - result matrix size row_size x col_size\n     */\n    Mat Mat::Get(int row_start, int row_size, int col_start, int col_size)\n    {\n        Mat result(row_size, col_size);\n\n        if ((row_start + row_size) &gt; this-&gt;rows)\n        {\n            return result;\n        }\n        if ((col_start + col_size) &gt; this-&gt;cols)\n        {\n            return result;\n        }\n\n        for (size_t r = 0; r &lt; result.rows; r++)\n        {\n            memcpy(&amp;result.data[r * result.cols], &amp;this-&gt;data[(r + row_start) * this-&gt;stride + col_start], result.cols * sizeof(float));\n        }\n        return result;\n    }\n\n    /**\n     * Make copy of matrix.\n     * @param[in] rect: rectangular area of interest\n     * @return\n     *      - result matrix size row_size x col_size\n     */\n    Mat Mat::Get(const Mat::Rect &amp;rect)\n    {\n        return (Get(rect.y, rect.height, rect.x, rect.width));\n    }\n\n    /**\n     * Return part of matrix from defined position (startRow, startCol) as a matrix[blockRows x blockCols].\n     *\n     * @param[in] startRow: start row position\n     * @param[in] startCol: start column position\n     * @param[in] blockRows: amount of rows in result matrix\n     * @param[in] blockCols: amount of columns in the result matrix\n     *\n     * @return\n     *      - matrix [blockRows]x[blockCols]\n     */\n    Mat Mat::block(int startRow, int startCol, int blockRows, int blockCols)\n    {\n        Mat result(blockRows, blockCols);\n        for (int i = 0; i &lt; blockRows; ++i)\n        {\n            for (int j = 0; j &lt; blockCols; ++j)\n            {\n                result(i, j) = (*this)(startRow + i, startCol + j);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Swap two rows between each other.\n     * @param[in] row1: position of first row\n     * @param[in] row2: position of second row\n     */\n    void Mat::swapRows(int r1, int r2)\n    {\n        if ((this-&gt;rows &lt;= r1) || (this-&gt;rows &lt;= r2))\n        {\n            std::cerr &lt;&lt; \"swapRows Error: row \" &lt;&lt; r1 &lt;&lt; \" or \" &lt;&lt; r2 &lt;&lt; \" out of matrix row \" &lt;&lt; this-&gt;rows &lt;&lt; \" range\" &lt;&lt; std::endl;\n        }\n        else\n        {\n            for (int i = 0; i &lt; this-&gt;cols; i++)\n            {\n                float temp = this-&gt;data[r1 * this-&gt;stride + i];\n                this-&gt;data[r1 * this-&gt;stride + i] = this-&gt;data[r2 * this-&gt;stride + i];\n                this-&gt;data[r2 * this-&gt;stride + i] = temp;\n            }\n        }\n    }\n\n    /**\n     * The method fill 0 to the matrix structure.\n     *\n     */\n    void Mat::clear()\n    {\n        for (int row = 0; row &lt; this-&gt;rows; row++)\n        {\n            memset(this-&gt;data + (row * this-&gt;stride), 0, this-&gt;cols * sizeof(float));\n        }\n    }\n\n    /* === Print &amp; Debug === */\n    /**\n     * @brief print matrix header\n     *\n     * Print all information about matrix to the terminal\n     * @param[in] src: source matrix\n     */\n    void Mat::PrintHead(void)\n    {\n        std::cout &lt;&lt; \"rows     \" &lt;&lt; this-&gt;rows &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"cols     \" &lt;&lt; this-&gt;cols &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"lenght   \" &lt;&lt; this-&gt;length &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"data     \" &lt;&lt; this-&gt;data &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"ext_buff \" &lt;&lt; this-&gt;ext_buff &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"sub_mat  \" &lt;&lt; this-&gt;sub_matrix &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"stride   \" &lt;&lt; this-&gt;stride &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"padding  \" &lt;&lt; this-&gt;padding &lt;&lt; std::endl\n                  &lt;&lt; std::endl;\n    }\n\n    /**\n     * @brief print matrix header and data\n     *\n     * Print all information about matrix to the terminal\n     * @param[in] show_padding: show padding information\n     * @param[in] label: label for the matrix\n     */\n    void Mat::PrintMatrix(bool show_padding, const std::string &amp;label)\n    {\n        std::cout &lt;&lt; label &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"rows: \" &lt;&lt; rows &lt;&lt; \", cols: \" &lt;&lt; cols &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"stride: \" &lt;&lt; stride &lt;&lt; \", length: \" &lt;&lt; length &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"ext_buff: \" &lt;&lt; ext_buff &lt;&lt; \", sub_matrix: \" &lt;&lt; sub_matrix &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"data pointer: \" &lt;&lt; static_cast&lt;void *&gt;(data) &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"data (row-major):\\n\";\n\n        int display_cols = show_padding ? stride : cols;\n\n        for (int i = 0; i &lt; rows; ++i)\n        {\n            for (int j = 0; j &lt; display_cols; ++j)\n            {\n                std::cout &lt;&lt; std::setw(8) &lt;&lt; data[i * stride + j] &lt;&lt; \" \";\n            }\n            std::cout &lt;&lt; \"\\n\";\n        }\n        std::cout &lt;&lt; std::endl;\n    }\n    /* === Arithmetic Operators === */\n    /**\n     * Copy operator\n     *\n     * @param[in] src: source matrix\n     *\n     * @return\n     *      - matrix copy\n     */\n    Mat &amp;Mat::operator=(const Mat &amp;m)\n    {\n        if (this == &amp;m)\n        {\n            return *this;\n        }\n\n        // matrix dimensions not equal, note the dimension will be changed! (for non-sub-matrix)\n        if (this-&gt;rows != m.rows || this-&gt;cols != m.cols)\n        {\n            // left operand is a sub-matrix - error\n            if (this-&gt;sub_matrix)\n            {\n                std::cerr &lt;&lt; \"operator = Error for sub-matrices: operands matrices dimensions \" &lt;&lt; this-&gt;rows &lt;&lt; \"x\" &lt;&lt; this-&gt;cols &lt;&lt; \" and \" &lt;&lt; m.rows &lt;&lt; \"x\" &lt;&lt; m.cols &lt;&lt; \" do not match\" &lt;&lt; std::endl;\n                return *this;\n            }\n            if (!this-&gt;ext_buff)\n            {\n                delete[] this-&gt;data;\n            }\n            this-&gt;ext_buff = false;\n            this-&gt;rows = m.rows;\n            this-&gt;cols = m.cols;\n            this-&gt;stride = this-&gt;cols;\n            this-&gt;padding = 0;\n            this-&gt;sub_matrix = false;\n            allocate();\n        }\n\n        for (int row = 0; row &lt; this-&gt;rows; row++)\n        {\n            memcpy(this-&gt;data + (row * this-&gt;stride), m.data + (row * m.stride), this-&gt;cols * sizeof(float));\n        }\n        return *this;\n    }\n\n    /**\n     * += operator\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: source matrix\n     *\n     * @return\n     *      - result matrix: result += A\n     */\n    Mat &amp;Mat::operator+=(const Mat &amp;m)\n    {\n        if ((this-&gt;rows != m.rows) || (this-&gt;cols != m.cols))\n        {\n            std::cerr &lt;&lt; \"operator += Error: matrices do not have equal dimensions\" &lt;&lt; std::endl;\n            return *this;\n        }\n\n        if (this-&gt;sub_matrix || m.sub_matrix)\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_add_f32(this-&gt;data, m.data, this-&gt;data, this-&gt;rows, this-&gt;cols, this-&gt;padding, m.padding, this-&gt;padding, 1, 1, 1);\n#else\n            tiny_mat_add_f32(this-&gt;data, m.data, this-&gt;data, this-&gt;rows, this-&gt;cols, this-&gt;padding, m.padding, this-&gt;padding, 1, 1, 1);\n#endif\n        }\n        else\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dsps_add_f32(this-&gt;data, m.data, this-&gt;data, this-&gt;length, 1, 1, 1);\n#else\n            tiny_vec_add_f32(this-&gt;data, m.data, this-&gt;data, this-&gt;length, 1, 1, 1);\n#endif\n        }\n        return *this;\n    }\n\n    /**\n     * += operator\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] C: constant\n     *\n     * @return\n     *      - result matrix: result += C\n     */\n    Mat &amp;Mat::operator+=(float C)\n    {\n        if (this-&gt;sub_matrix)\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_addc_f32(this-&gt;data, this-&gt;data, C, this-&gt;rows, this-&gt;cols, this-&gt;padding, this-&gt;padding, 1, 1);\n#else\n            tiny_mat_addc_f32(this-&gt;data, this-&gt;data, C, this-&gt;rows, this-&gt;cols, this-&gt;padding, this-&gt;padding, 1, 1);\n#endif\n        }\n        else\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dsps_addc_f32_ansi(this-&gt;data, this-&gt;data, this-&gt;length, C, 1, 1);\n#else\n            tiny_vec_addc_f32(this-&gt;data, this-&gt;data, this-&gt;length, C, 1, 1);\n#endif\n        }\n        return *this;\n    }\n\n    /**\n     * -= operator\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: source matrix\n     *\n     * @return\n     *      - result matrix: result -= A\n     */\n\n    Mat &amp;Mat::operator-=(const Mat &amp;m)\n    {\n        if ((this-&gt;rows != m.rows) || (this-&gt;cols != m.cols))\n        {\n            std::cerr &lt;&lt; \"operator -= Error: matrices do not have equal dimensions\" &lt;&lt; std::endl;\n            return *this;\n        }\n\n        if (this-&gt;sub_matrix || m.sub_matrix)\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_sub_f32(this-&gt;data, m.data, this-&gt;data, this-&gt;rows, this-&gt;cols, this-&gt;padding, m.padding, this-&gt;padding, 1, 1, 1);\n#else\n            tiny_mat_sub_f32(this-&gt;data, m.data, this-&gt;data, this-&gt;rows, this-&gt;cols, this-&gt;padding, m.padding, this-&gt;padding, 1, 1, 1);\n#endif\n        }\n        else\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dsps_sub_f32(this-&gt;data, m.data, this-&gt;data, this-&gt;length, 1, 1, 1);\n#else\n            tiny_vec_sub_f32(this-&gt;data, m.data, this-&gt;data, this-&gt;length, 1, 1, 1);\n#endif\n        }\n        return *this;\n    }\n\n    /**\n     * -= operator\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] C: constant\n     *\n     * @return\n     *      - result matrix: result -= C\n     */\n    Mat &amp;Mat::operator-=(float C)\n    {\n        if (this-&gt;sub_matrix)\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_addc_f32(this-&gt;data, this-&gt;data, -C, this-&gt;rows, this-&gt;cols, this-&gt;padding, this-&gt;padding, 1, 1);\n#else\n            tiny_mat_addc_f32(this-&gt;data, this-&gt;data, -C, this-&gt;rows, this-&gt;cols, this-&gt;padding, this-&gt;padding, 1, 1);\n#endif\n        }\n        else\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dsps_addc_f32_ansi(this-&gt;data, this-&gt;data, this-&gt;length, -C, 1, 1);\n#else\n            tiny_vec_addc_f32(this-&gt;data, this-&gt;data, this-&gt;length, -C, 1, 1);\n#endif\n        }\n        return *this;\n    }\n\n    /**\n     * *= operator\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: source matrix\n     *\n     * @return\n     *      - result matrix: result -= A\n     */\n    Mat &amp;Mat::operator*=(const Mat &amp;m)\n    {\n        if (this-&gt;cols != m.rows)\n        {\n            std::cerr &lt;&lt; \"operator *= Error: matrices do not have equal dimensions\" &lt;&lt; std::endl;\n            return *this;\n        }\n\n        if (this-&gt;sub_matrix || m.sub_matrix)\n        {\n            Mat temp = this-&gt;Get(0, this-&gt;rows, 0, this-&gt;cols);\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mult_ex_f32(temp.data, m.data, this-&gt;data, temp.rows, temp.cols, m.cols, temp.padding, m.padding, this-&gt;padding);\n#else\n            tiny_mat_mult_ex_f32(temp.data, m.data, this-&gt;data, temp.rows, temp.cols, m.cols, temp.padding, m.padding, this-&gt;padding);\n#endif\n        }\n        else\n        {\n            Mat temp = *this;\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mult_f32(temp.data, m.data, this-&gt;data, temp.rows, temp.cols, m.cols);\n#else\n            tiny_mat_mult_f32(temp.data, m.data, this-&gt;data, temp.rows, temp.cols, m.cols);\n#endif\n        }\n        return (*this);\n    }\n\n    /**\n     * += with constant operator\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] C: constant value\n     *\n     * @return\n     *      - result matrix: result *= C\n     */\n    Mat &amp;Mat::operator*=(float num)\n    {\n        if (this-&gt;sub_matrix)\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mulc_f32(this-&gt;data, this-&gt;data, num, this-&gt;rows, this-&gt;cols, this-&gt;padding, this-&gt;padding, 1, 1);\n#else\n            tiny_mat_mulc_f32(this-&gt;data, this-&gt;data, num, this-&gt;rows, this-&gt;cols, this-&gt;padding, this-&gt;padding, 1, 1);\n#endif\n        }\n        else\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dsps_mulc_f32_ansi(this-&gt;data, this-&gt;data, this-&gt;length, num, 1, 1);\n#else\n            tiny_vec_mulc_f32(this-&gt;data, this-&gt;data, this-&gt;length, num, 1, 1);\n#endif\n        }\n        return *this;\n    }\n\n    /**\n     * /= operator\n     *\n     * @param[in] B: source matrix\n     *\n     * @return\n     *      - result matrix: result[i,j] = result[i,j]/B[i,j]\n     */\n    Mat &amp;Mat::operator/=(const Mat &amp;B) // note this is element-wise division\n    {\n        // dimension check\n        if ((this-&gt;rows != B.rows) || (this-&gt;cols != B.cols))\n        {\n            std::cerr &lt;&lt; \"operator /= Error: matrices do not have equal dimensions\" &lt;&lt; std::endl;\n            return *this;\n        }\n\n        // check for zero division\n        for (int row = 0; row &lt; B.rows; row++)\n        {\n            for (int col = 0; col &lt; B.cols; col++)\n            {\n                if (B(row, col) == 0)\n                {\n                    std::cerr &lt;&lt; \"operator /= Error: division by zero\" &lt;&lt; std::endl;\n                    return *this;\n                }\n            }\n        }\n\n        for (int row = 0; row &lt; this-&gt;rows; row++)\n        {\n            for (int col = 0; col &lt; this-&gt;cols; col++)\n            {\n                (*this)(row, col) = (*this)(row, col) / B(row, col); // note this is element-wise division\n            }\n        }\n        return (*this);\n    }\n\n    /**\n     * /= with constant operator\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] C: constant value\n     *\n     * @return\n     *      - result matrix: result /= C\n     */\n    Mat &amp;Mat::operator/=(float num)\n    {\n        if (num == 0)\n        {\n            std::cerr &lt;&lt; \"operator /= Error: division by zero\" &lt;&lt; std::endl;\n            return *this;\n        }\n\n        if (this-&gt;sub_matrix)\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mulc_f32(this-&gt;data, this-&gt;data, 1 / num, this-&gt;rows, this-&gt;cols, this-&gt;padding, this-&gt;padding, 1, 1);\n#else\n            tiny_mat_multc_f32(this-&gt;data, this-&gt;data, 1 / num, this-&gt;rows, this-&gt;cols, this-&gt;padding, this-&gt;padding, 1, 1);\n#endif\n        }\n        else\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dsps_mulc_f32_ansi(this-&gt;data, this-&gt;data, this-&gt;length, 1 / num, 1, 1);\n#else\n            tiny_vec_mulc_f32(this-&gt;data, this-&gt;data, this-&gt;length, 1 / num, 1, 1);\n#endif\n        }\n        return *this;\n    }\n\n    /**\n     * ^= exponentiation operator\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] num: exponent\n     *\n     * @return\n     *      - result matrix: result = result^num\n     */\n    Mat Mat::operator^(int num)\n    {\n        Mat temp(*this);\n        return expHelper(temp, num);\n    }\n\n    /* === Linear Algebra === */\n    /**\n     * @brief Normalize the matrix\n     *\n     * The method normalize the matrix to unit length.\n     */\n    void Mat::normalize(void) // normalize the matrix\n    {\n        float sqr_norm = 0;\n        for (int i = 0; i &lt; this-&gt;rows; ++i)\n        {\n            for (int j = 0; j &lt; this-&gt;cols; ++j)\n            {\n                sqr_norm += (*this)(i, j) * (*this)(i, j);\n            }\n        }\n        sqr_norm = 1 / sqrtf(sqr_norm);\n        *this *= sqr_norm;\n    }\n\n    /**\n     * @brief Calculate the matrix norm\n     *\n     * The method calculate the matrix norm.\n     *\n     * @return\n     *      - result matrix norm\n     */\n    float Mat::norm(void) // calculate matrix norm\n    {\n        float sqr_norm = 0;\n        for (int i = 0; i &lt; this-&gt;rows; ++i)\n        {\n            for (int j = 0; j &lt; this-&gt;cols; ++j)\n            {\n                sqr_norm += (*this)(i, j) * (*this)(i, j);\n            }\n        }\n        sqr_norm = sqrtf(sqr_norm);\n        return sqr_norm;\n    }\n\n    /**\n     * @brief Calculate the determinant of the matrix\n     *\n     * The method calculate the determinant of the matrix.\n     *\n     * @param n: size of the matrix\n     *\n     * @return\n     *      - result matrix determinant\n     */\n    float Mat::det(int n)\n    {\n        float D = 0; // Initialize result\n\n        //  Base case : if matrix contains single element\n        if (n == 1)\n        {\n            return (*this)(0, 0);\n        }\n\n        Mat temp(this-&gt;rows, this-&gt;rows); // To store cofactors\n\n        int sign = 1; // To store sign multiplier\n\n        // Iterate for each element of first row\n        for (int f = 0; f &lt; n; f++)\n        {\n            // Getting Cofactor of A[0][f]\n            Mat temp = this-&gt;cofactor(0, f, n);\n            D += (*this)(0, f) * temp.det(n - 1) * sign;\n\n            // terms are to be added with alternate sign\n            sign = -sign;\n        }\n\n        return D;\n    }\n\n    /**\n     * Matrix transpose.\n     * Change rows and columns between each other.\n     *\n     * @return\n     *      - transposed matrix\n     */\n    Mat Mat::t()\n    {\n        Mat ret(this-&gt;cols, this-&gt;rows);\n        for (int i = 0; i &lt; this-&gt;rows; ++i)\n        {\n            for (int j = 0; j &lt; this-&gt;cols; ++j)\n            {\n                ret(j, i) = this-&gt;data[i * this-&gt;stride + j];\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Find the inverse matrix\n     *\n     * @return\n     *      - inverse matrix\n     */\n    Mat Mat::inverse()\n    {\n        Mat result(this-&gt;rows, this-&gt;cols);\n        // Find determinant of matrix\n        float det = this-&gt;det(this-&gt;rows);\n        if (det == 0)\n        {\n            // std::cout &lt;&lt; \"Singular matrix, can't find its inverse\";\n            return result;\n        }\n\n        // Find adjoint\n        Mat adj = this-&gt;adjoint();\n\n        // Find Inverse using formula \"inverse(A) = adj(A)/det(A)\"\n        for (int i = 0; i &lt; this-&gt;rows; i++)\n            for (int j = 0; j &lt; this-&gt;cols; j++)\n            {\n                result(i, j) = adj(i, j) / float(det);\n            }\n\n        return result;\n    }\n\n    /**\n     * Find pseudo inverse matrix\n     *\n     * @return\n     *      - inverse matrix\n     */\n    Mat Mat::pinv()\n    {\n        Mat I = Mat::eye(this-&gt;rows);\n        Mat AI = Mat::augment(*this, I);\n        Mat U = AI.gaussianEliminate();\n        Mat IAInverse = U.rowReduceFromGaussian();\n        Mat AInverse(this-&gt;rows, this-&gt;cols);\n        for (int i = 0; i &lt; this-&gt;rows; ++i)\n        {\n            for (int j = 0; j &lt; this-&gt;cols; ++j)\n            {\n                AInverse(i, j) = IAInverse(i, j + this-&gt;cols);\n            }\n        }\n        return AInverse;\n    }\n\n    /**\n     * @brief   Gaussian Elimination\n     *\n     * Gaussian Elimination of matrix\n     *\n     * @return\n     *      - result matrix\n     */\n    Mat Mat::gaussianEliminate()\n    {\n        Mat Ab(*this);\n        int rows = Ab.rows;\n        int cols = Ab.cols;\n        int Acols = cols - 1;\n\n        int i = 0; // row tracker\n        int j = 0; // column tracker\n\n        // iterate through the rows\n        while (i &lt; rows)\n        {\n            // find a pivot for the row\n            bool pivot_found = false;\n            while (j &lt; Acols &amp;&amp; !pivot_found)\n            {\n                if (Ab(i, j) != 0)\n                { // pivot not equal to 0\n                    pivot_found = true;\n                }\n                else\n                { // check for a possible swap\n                    int max_row = i;\n                    float max_val = 0;\n                    for (int k = i + 1; k &lt; rows; ++k)\n                    {\n                        float cur_abs = Ab(k, j) &gt;= 0 ? Ab(k, j) : -1 * Ab(k, j);\n                        if (cur_abs &gt; max_val)\n                        {\n                            max_row = k;\n                            max_val = cur_abs;\n                        }\n                    }\n                    if (max_row != i)\n                    {\n                        Ab.swapRows(max_row, i);\n                        pivot_found = true;\n                    }\n                    else\n                    {\n                        j++;\n                    }\n                }\n            }\n\n            // perform elimination as normal if pivot was found\n            if (pivot_found)\n            {\n                for (int t = i + 1; t &lt; rows; ++t)\n                {\n                    for (int s = j + 1; s &lt; cols; ++s)\n                    {\n                        Ab(t, s) = Ab(t, s) - Ab(i, s) * (Ab(t, j) / Ab(i, j));\n                        if (Ab(t, s) &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32 &amp;&amp; Ab(t, s) &gt; -1 * TINY_MATH_MIN_POSITIVE_INPUT_F32)\n                        {\n                            Ab(t, s) = 0;\n                        }\n                    }\n                    Ab(t, j) = 0;\n                }\n            }\n\n            i++;\n            j++;\n        }\n\n        return Ab;\n    }\n\n    /**\n     * Row reduction for Gaussian elimination\n     *\n     * @return\n     *      - result matrix\n     */\n    Mat Mat::rowReduceFromGaussian()\n    {\n        Mat R(*this);\n        int rows = R.rows;\n        int cols = R.cols;\n\n        int i = rows - 1; // row tracker\n        int j = cols - 2; // column tracker\n\n        // iterate through every row\n        while (i &gt;= 0)\n        {\n            // find the pivot column\n            int k = j - 1;\n            while (k &gt;= 0)\n            {\n                if (R(i, k) != 0)\n                {\n                    j = k;\n                }\n                k--;\n            }\n\n            // zero out elements above pivots if pivot not 0\n            if (R(i, j) != 0)\n            {\n                for (int t = i - 1; t &gt;= 0; --t)\n                {\n                    for (int s = 0; s &lt; cols; ++s)\n                    {\n                        if (s != j)\n                        {\n                            R(t, s) = R(t, s) - R(i, s) * (R(t, j) / R(i, j));\n                            if (R(t, s) &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32 &amp;&amp; R(t, s) &gt; -1 * TINY_MATH_MIN_POSITIVE_INPUT_F32)\n                            {\n                                R(t, s) = 0;\n                            }\n                        }\n                    }\n                    R(t, j) = 0;\n                }\n\n                // divide row by pivot\n                for (int k = j + 1; k &lt; cols; ++k)\n                {\n                    R(i, k) = R(i, k) / R(i, j);\n                    if (R(i, k) &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32 &amp;&amp; R(i, k) &gt; -1 * TINY_MATH_MIN_POSITIVE_INPUT_F32)\n                    {\n                        R(i, k) = 0;\n                    }\n                }\n                R(i, j) = 1;\n            }\n\n            i--;\n            j--;\n        }\n\n        return R;\n    }\n\n    /* === Static Utility Functions === */\n\n    /**\n     * Create identity matrix.\n     * Create a square matrix and fill diagonal with 1.\n     *\n     * @param[in] size: matrix size\n     *\n     * @return\n     *      - matrix [N]x[N] with 1 in diagonal\n     */\n    Mat Mat::eye(int size)\n    {\n        Mat temp(size, size);\n        for (int i = 0; i &lt; temp.rows; ++i)\n        {\n            for (int j = 0; j &lt; temp.cols; ++j)\n            {\n                if (i == j)\n                {\n                    temp(i, j) = 1;\n                }\n                else\n                {\n                    temp(i, j) = 0;\n                }\n            }\n        }\n        return temp;\n    }\n\n    /**\n     * Create matrix with all elements 1.\n     * Create a square matrix and fill all elements with 1.\n     *\n     * @param[in] size: matrix size\n     *\n     * @return\n     *      - matrix [N]x[N] with 1 in all elements\n     */\n    Mat Mat::ones(int size)\n    {\n        return (ones(size, size));\n    }\n\n    /**\n     * Create matrix with all elements 1.\n     * Create a matrix and fill all elements with 1.\n     *\n     * @param[in] rows: matrix rows\n     * @param[in] cols: matrix cols\n     *\n     * @return\n     *      - matrix [N]x[N] with 1 in all elements\n     */\n    Mat Mat::ones(int rows, int cols)\n    {\n        Mat temp(rows, cols);\n        for (int row = 0; row &lt; temp.rows; ++row)\n        {\n            for (int col = 0; col &lt; temp.cols; ++col)\n            {\n                temp(row, col) = 1;\n            }\n        }\n        return temp;\n    }\n\n    /**\n     * @brief   Solve the matrix\n     *\n     * Solve matrix. Find roots for the matrix A*x = b\n     *\n     * @param[in] A: matrix [N]x[N] with input coefficients\n     * @param[in] b: vector [N]x[1] with result values\n     *\n     * @return\n     *      - matrix [N]x[1] with roots\n     */\n    Mat Mat::solve(Mat A, Mat b)\n    {\n        // Gaussian elimination\n        for (int i = 0; i &lt; A.rows; ++i)\n        {\n            if (A(i, i) == 0)\n            {\n                // pivot 0 - error\n                std::cerr &lt;&lt; \"Error: the coefficient matrix has 0 as a pivot. Please fix the input and try again.\" &lt;&lt; std::endl;\n                Mat err_result(0, 0);\n                return err_result;\n            }\n            float a_ii = 1 / A(i, i);\n            for (int j = i + 1; j &lt; A.rows; ++j)\n            {\n                float a_ji = A(j, i) * a_ii;\n                for (int k = i + 1; k &lt; A.cols; ++k)\n                {\n                    A(j, k) -= A(i, k) * a_ji;\n                    if ((A(j, k) &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32) &amp;&amp; (A(j, k) &gt; -1 * TINY_MATH_MIN_POSITIVE_INPUT_F32))\n                    {\n                        A(j, k) = 0;\n                    }\n                }\n                b(j, 0) -= b(i, 0) * a_ji;\n                if (A(j, 0) &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32 &amp;&amp; A(j, 0) &gt; -1 * TINY_MATH_MIN_POSITIVE_INPUT_F32)\n                {\n                    A(j, 0) = 0;\n                }\n                A(j, i) = 0;\n            }\n        }\n\n        // Back substitution\n        Mat x(b.rows, 1);\n        x((x.rows - 1), 0) = b((x.rows - 1), 0) / A((x.rows - 1), (x.rows - 1));\n        if (x((x.rows - 1), 0) &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32 &amp;&amp; x((x.rows - 1), 0) &gt; -1 * TINY_MATH_MIN_POSITIVE_INPUT_F32)\n        {\n            x((x.rows - 1), 0) = 0;\n        }\n        for (int i = x.rows - 2; i &gt;= 0; --i)\n        {\n            float sum = 0;\n            for (int j = i + 1; j &lt; x.rows; ++j)\n            {\n                sum += A(i, j) * x(j, 0);\n            }\n            x(i, 0) = (b(i, 0) - sum) / A(i, i);\n            if (x(i, 0) &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32 &amp;&amp; x(i, 0) &gt; -1 * TINY_MATH_MIN_POSITIVE_INPUT_F32)\n            {\n                x(i, 0) = 0;\n            }\n        }\n        return x;\n    }\n\n    /**\n     * @brief   Band solve the matrix\n     *\n     * Solve band matrix. Find roots for the matrix A*x = b with bandwidth k.\n     *\n     * @param[in] A: matrix [N]x[N] with input coefficients\n     * @param[in] b: vector [N]x[1] with result values\n     * @param[in] k: upper bandwidth value\n     *\n     * @return\n     *      - matrix [N]x[1] with roots\n     */\n    Mat Mat::bandSolve(Mat A, Mat b, int k)\n    {\n        // optimized Gaussian elimination\n        int bandsBelow = (k - 1) / 2;\n        for (int i = 0; i &lt; A.rows; ++i)\n        {\n            if (A(i, i) == 0)\n            {\n                // pivot 0 - error\n                std::cerr &lt;&lt; \"Error: the coefficient matrix has 0 as a pivot. Please fix the input and try again.\" &lt;&lt; std::endl;\n                Mat err_result(b.rows, 1);\n                memset(err_result.data, 0, b.rows * sizeof(float));\n                return err_result;\n            }\n            float a_ii = 1 / A(i, i);\n            for (int j = i + 1; j &lt; A.rows &amp;&amp; j &lt;= i + bandsBelow; ++j)\n            {\n                int k = i + 1;\n                while ((k &lt; A.cols) &amp;&amp; (fabs(A(j, k)) &gt; TINY_MATH_MIN_POSITIVE_INPUT_F32))\n                {\n                    A(j, k) -= A(i, k) * (A(j, i) * a_ii);\n                    k++;\n                }\n                b(j, 0) -= b(i, 0) * (A(j, i) * a_ii);\n                A(j, i) = 0;\n            }\n        }\n\n        // Back substitution\n        Mat x(b.rows, 1);\n        x((x.rows - 1), 0) = b((x.rows - 1), 0) / A((x.rows - 1), (x.rows - 1));\n        for (int i = x.rows - 2; i &gt;= 0; --i)\n        {\n            float sum = 0;\n            for (int j = i + 1; j &lt; x.rows; ++j)\n            {\n                sum += A(i, j) * x(j, 0);\n            }\n            x(i, 0) = (b(i, 0) - sum) / A(i, i);\n        }\n\n        return x;\n    }\n\n    /**\n     * @brief   Solve the matrix\n     *\n     * Different way to solve the matrix. Find roots for the matrix A*x = y\n     *\n     * @param[in] A: matrix [N]x[N] with input coefficients\n     * @param[in] y: vector [N]x[1] with result values\n     *\n     * @return\n     *      - matrix [N]x[1] with roots\n     */\n    Mat Mat::roots(Mat A, Mat y)\n    {\n        int n = A.cols + 1;\n\n        Mat result(y.rows, 1);\n\n        Mat g_m = Mat::augment(A, y);\n        for (int j = 0; j &lt; A.cols; j++)\n        {\n            float g_jj = 1 / g_m(j, j);\n            for (int i = 0; i &lt; A.cols; i++)\n            {\n                if (i != j)\n                {\n                    float c = g_m(i, j) * g_jj;\n                    for (int k = 0; k &lt; n; k++)\n                    {\n                        g_m(i, k) = g_m(i, k) - c * g_m(j, k);\n                    }\n                }\n            }\n        }\n        for (int i = 0; i &lt; A.rows; i++)\n        {\n            result(i, 0) = g_m(i, A.cols) / g_m(i, i);\n        }\n        return result;\n    }\n\n    /**\n     * @brief   Dotproduct of two vectors\n     *\n     * The method returns dotproduct of two vectors\n     *\n     * @param[in] A: Input vector A Nx1\n     * @param[in] B: Input vector B Nx1\n     *\n     * @return\n     *      - dotproduct value\n     */\n    float Mat::dotProduct(Mat a, Mat b)\n    {\n        float sum = 0;\n        for (int i = 0; i &lt; a.rows; ++i)\n        {\n            sum += (a(i, 0) * b(i, 0));\n        }\n        return sum;\n    }\n\n    /**\n     * @brief   Augmented matrices (concatenate two matrices horizontally)\n     *\n     * Augmented matrices\n     *\n     * @param[in] A: Input vector A MxN\n     * @param[in] B: Input vector B MxK\n     *\n     * @return\n     *      - Augmented matrix Mx(N+K)\n     */\n    Mat Mat::augment(Mat A, Mat B)\n    {\n        Mat AB(A.rows, A.cols + B.cols);\n        for (int i = 0; i &lt; AB.rows; ++i)\n        {\n            for (int j = 0; j &lt; AB.cols; ++j)\n            {\n                if (j &lt; A.cols)\n                {\n                    AB(i, j) = A(i, j);\n                }\n                else\n                {\n                    AB(i, j) = B(i, j - A.cols);\n                }\n            }\n        }\n        return AB;\n    }\n\n    /* === Private Utility Functions === */\n    /**\n     * @brief   Calculate cofactor matrix\n     *\n     * Calculate cofactor matrix of the matrix\n     *\n     * @param[in] row: row position\n     * @param[in] col: column position\n     * @param[in] n: size of the matrix\n     *\n     * @return\n     *      - cofactor matrix\n     */\n    Mat Mat::cofactor(int row, int col, int n)\n    {\n        int i = 0, j = 0;\n        Mat result(n, n);\n        // Looping for each element of the matrix\n        for (int r = 0; r &lt; n; r++)\n        {\n            for (int c = 0; c &lt; n; c++)\n            {\n                //  Copying into temporary matrix only those element\n                //  which are not in given row and column\n                if (r != row &amp;&amp; c != col)\n                {\n                    result(i, j++) = (*this)(r, c);\n\n                    // Row is filled, so increase row index and\n                    // reset col index\n                    if (j == this-&gt;rows - 1)\n                    {\n                        j = 0;\n                        i++;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @brief   Calculate adjoint matrix\n     *\n     * Calculate adjoint matrix of the matrix\n     *\n     * @return\n     *      - adjoint matrix\n     */\n    Mat Mat::adjoint()\n    {\n        Mat adj(this-&gt;rows, this-&gt;cols);\n        if (this-&gt;rows == 1)\n        {\n            adj(0, 0) = 1;\n            return adj;\n        }\n\n        // temp is used to store cofactors of A(,)\n        int sign = 1;\n        Mat temp(this-&gt;rows, this-&gt;cols);\n\n        for (int i = 0; i &lt; this-&gt;rows; i++)\n        {\n            for (int j = 0; j &lt; this-&gt;cols; j++)\n            {\n                // Get cofactor of A(i,j)\n                temp = this-&gt;cofactor(i, j, this-&gt;rows);\n\n                // sign of adj(j,i) positive if sum of row\n                // and column indexes is even.\n                sign = ((i + j) % 2 == 0) ? 1 : -1;\n\n                // Interchanging rows and columns to get the\n                // transpose of the cofactor matrix\n                adj(j, i) = (sign) * (temp.det(this-&gt;rows - 1));\n            }\n        }\n        return adj;\n    }\n\n    /**\n     * @brief   Calculate matrix exponential\n     *\n     * Calculate matrix exponential of the matrix\n     *\n     * @param[in] m: input matrix\n     * @param[in] num: number of iterations\n     *\n     * @return\n     *      - matrix exponential\n     */\n    Mat Mat::expHelper(const Mat &amp;m, int num)\n    {\n        if (num == 0)\n        {\n            return Mat::eye(m.rows);\n        }\n        else if (num == 1)\n        {\n            return m;\n        }\n        else if (num % 2 == 0)\n        { // num is even\n            return expHelper(m * m, num / 2);\n        }\n        else\n        { // num is odd\n            return m * expHelper(m * m, (num - 1) / 2);\n        }\n    }\n    /* === Stream Operators === */\n\n    /* === Stream Operators === */\n    /**\n     * Print matrix to the standard iostream.\n     * @param[in] os: output stream\n     * @param[in] m: matrix to print\n     *\n     * @return\n     *      - output stream\n     */\n    ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mat &amp;m)\n    {\n        for (int i = 0; i &lt; m.rows; ++i)\n        {\n            os &lt;&lt; m(i, 0);\n            for (int j = 1; j &lt; m.cols; ++j)\n            {\n                os &lt;&lt; \" \" &lt;&lt; m(i, j);\n            }\n            os &lt;&lt; endl;\n        }\n        return os;\n    }\n\n    /**\n     * Print rectangular ROI to the standard iostream.\n     * @param[in] os: output stream\n     * @param[in] rect: ROI\n     *\n     * @return\n     *      - output stream\n     */\n    ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mat::Rect &amp;rect)\n    {\n        os &lt;&lt; \"row start \" &lt;&lt; rect.y &lt;&lt; endl;\n        os &lt;&lt; \"col start \" &lt;&lt; rect.x &lt;&lt; endl;\n        os &lt;&lt; \"row count \" &lt;&lt; rect.height &lt;&lt; endl;\n        os &lt;&lt; \"col count \" &lt;&lt; rect.width &lt;&lt; endl;\n\n        return os;\n    }\n\n    /**\n     * Fill the matrix from iostream.\n     * @param[in] is: input stream\n     * @param[in] m: matrix to fill\n     *\n     * @return\n     *      - input stream\n     */\n    istream &amp;operator&gt;&gt;(istream &amp;is, Mat &amp;m)\n    {\n        for (int i = 0; i &lt; m.rows; ++i)\n        {\n            for (int j = 0; j &lt; m.cols; ++j)\n            {\n                is &gt;&gt; m(i, j);\n            }\n        }\n        return is;\n    }\n\n    /* === Global Arithmetic Operators === */\n    /**\n     * + operator, sum of two matrices\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] B: Input matrix B\n     *\n     * @return\n     *     - result matrix A+B\n     */\n    Mat operator+(const Mat &amp;m1, const Mat &amp;m2)\n    {\n        if ((m1.rows != m2.rows) || (m1.cols != m2.cols))\n        {\n            std::cerr &lt;&lt; \"operator + Error: matrices do not have equal dimensions\" &lt;&lt; std::endl;\n            Mat err_ret;\n            return err_ret;\n        }\n\n        if (m1.sub_matrix || m2.sub_matrix)\n        {\n            Mat temp(m1.rows, m2.cols);\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_add_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m1.padding, m2.padding, temp.padding, 1, 1, 1);\n#else\n            tiny_mat_add_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m1.padding, m2.padding, temp.padding, 1, 1, 1);\n#endif\n            return temp;\n        }\n        else\n        {\n            Mat temp(m1);\n            return (temp += m2);\n        }\n    }\n\n    /**\n     * + operator, sum of matrix with constant\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] C: Input constant\n     *\n     * @return\n     *     - result matrix A+C\n     */\n    Mat operator+(const Mat &amp;m, float C)\n    {\n        if (m.sub_matrix)\n        {\n            Mat temp(m.rows, m.cols);\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_addc_f32(m.data, temp.data, C, m.rows, m.cols, m.padding, temp.padding, 1, 1);\n#else\n            tiny_mat_addc_f32(m.data, temp.data, C, m.rows, m.cols, m.padding, temp.padding, 1, 1);\n#endif\n            return temp;\n        }\n        else\n        {\n            Mat temp(m);\n            return (temp += C);\n        }\n    }\n\n    /**\n     * - operator, subtraction of two matrices\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] B: Input matrix B\n     *\n     * @return\n     *     - result matrix A-B\n     */\n    Mat operator-(const Mat &amp;m1, const Mat &amp;m2)\n    {\n        if ((m1.rows != m2.rows) || (m1.cols != m2.cols))\n        {\n            std::cerr &lt;&lt; \"operator - Error: matrices do not have equal dimensions\" &lt;&lt; std::endl;\n            Mat err_ret;\n            return err_ret;\n        }\n\n        if (m1.sub_matrix || m2.sub_matrix)\n        {\n            Mat temp(m1.rows, m1.cols);\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_sub_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m1.padding, m2.padding, temp.padding, 1, 1, 1);\n#else\n            tiny_mat_sub_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m1.padding, m2.padding, temp.padding, 1, 1, 1);\n#endif\n            return temp;\n        }\n        else\n        {\n            Mat temp(m1);\n            return (temp -= m2);\n        }\n    }\n\n    /**\n     * - operator, subtraction of matrix with constant\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] C: Input constant\n     *\n     * @return\n     *     - result matrix A-C\n     */\n    Mat operator-(const Mat &amp;m, float C)\n    {\n        if (m.sub_matrix)\n        {\n            Mat temp(m.rows, m.cols);\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_addc_f32(m.data, temp.data, -C, m.rows, m.cols, m.padding, temp.padding, 1, 1);\n#else\n            tiny_mat_addc_f32(m.data, temp.data, -C, m.rows, m.cols, m.padding, temp.padding, 1, 1);\n#endif\n            return temp;\n        }\n        else\n        {\n            Mat temp(m);\n            return (temp -= C);\n        }\n    }\n\n    /**\n     * * operator, multiplication of two matrices.\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] B: Input matrix B\n     *\n     * @return\n     *     - result matrix A*B\n     */\n    Mat operator*(const Mat &amp;m1, const Mat &amp;m2)\n    {\n        if (m1.cols != m2.rows)\n        {\n            std::cerr &lt;&lt; \"operator * Error: matrices do not have correct dimensions\" &lt;&lt; std::endl;\n            Mat err_ret;\n            return err_ret;\n        }\n        Mat temp(m1.rows, m2.cols);\n\n        if (m1.sub_matrix || m2.sub_matrix)\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mult_ex_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m2.cols, m1.padding, m2.padding, temp.padding);\n#else\n            tiny_mat_mult_ex_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m2.cols, m1.padding, m2.padding, temp.padding);\n#endif\n        }\n        else\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mult_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m2.cols);\n#else\n            tiny_mat_mult_f32(m1.data, m2.data, temp.data, m1.rows, m1.cols, m2.cols);\n#endif\n        }\n\n        return temp;\n    }\n\n    /**\n     * * operator, multiplication of matrix with constant\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] C: floating point value\n     *\n     * @return\n     *     - result matrix A*B\n     */\n    Mat operator*(const Mat &amp;m, float num)\n    {\n        if (m.sub_matrix)\n        {\n            Mat temp(m.rows, m.cols);\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mulc_f32(m.data, temp.data, num, m.rows, m.cols, m.padding, temp.padding, 1, 1);\n#else\n            tiny_mat_mulc_f32(m.data, temp.data, num, m.rows, m.cols, m.padding, temp.padding, 1, 1);\n#endif\n            return temp;\n        }\n        else\n        {\n            Mat temp(m);\n            return (temp *= num);\n        }\n    }\n\n    /**\n     * * operator, multiplication of matrix with constant\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] C: floating point value\n     * @param[in] A: Input matrix A\n     *\n     * @return\n     *     - result matrix C*A\n     */\n    Mat operator*(float num, const Mat &amp;m)\n    {\n        return (m * num);\n    }\n\n    /**\n     * / operator, divide of matrix by constant\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] C: floating point value\n     *\n     * @return\n     *     - result matrix A/C\n     */\n    Mat operator/(const Mat &amp;m, float num)\n    {\n        if (m.sub_matrix)\n        {\n            Mat temp(m.rows, m.cols);\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mulc_f32(m.data, temp.data, 1 / num, m.rows, m.cols, m.padding, temp.padding, 1, 1);\n#else\n            tiny_mat_multc_f32(m.data, temp.data, 1 / num, m.rows, m.cols, m.padding, temp.padding, 1, 1);\n#endif\n            return temp;\n        }\n        else\n        {\n            Mat temp(m);\n            return (temp /= num);\n        }\n    }\n\n    /**\n     * / operator, divide matrix A by matrix B (element-wise)\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] B: Input matrix B\n     *\n     * @return\n     *     - result matrix C, where C[i,j] = A[i,j]/B[i,j]\n     */\n    Mat operator/(const Mat &amp;A, const Mat &amp;B)\n    {\n        if ((A.rows != B.rows) || (A.cols != B.cols))\n        {\n            std::cerr &lt;&lt; \"operator / Error: matrices do not have equal dimensions\" &lt;&lt; std::endl;\n            Mat err_ret;\n            return err_ret;\n        }\n\n        Mat temp(A.rows, A.cols);\n        for (int row = 0; row &lt; A.rows; row++)\n        {\n            for (int col = 0; col &lt; A.cols; col++)\n            {\n                temp(row, col) = A(row, col) / B(row, col);\n            }\n        }\n        return temp;\n    }\n\n    /**\n     * == operator, compare two matrices\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] B: Input matrix B\n     *\n     * @return\n     *      - true if matrices are the same\n     *      - false if matrices are different\n     */\n    bool operator==(const Mat &amp;m1, const Mat &amp;m2)\n    {\n        if ((m1.cols != m2.cols) || (m1.rows != m2.rows))\n        {\n            return false;\n        }\n\n        for (int row = 0; row &lt; m1.rows; row++)\n        {\n            for (int col = 0; col &lt; m1.cols; col++)\n            {\n                if (m1(row, col) != m2(row, col))\n                {\n                    std::cout &lt;&lt; \"operator == Error: \" &lt;&lt; row &lt;&lt; \" \" &lt;&lt; col &lt;&lt; \", m1.data=\" &lt;&lt; m1(row, col) &lt;&lt; \", m2.data=\" &lt;&lt; m2(row, col) &lt;&lt; std::endl;\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n\n\n}\n</code></pre>"},{"location":"MATH/MATRIX/tiny-matrix-test/","title":"TEST","text":""},{"location":"MATH/USAGE/usage/","title":"USAGE INSTRUCTIONS","text":"<p>Usage Instructions</p> <p>This document provides usage instructions for the <code>math</code> module in Python.  It includes examples and explanations of various functions and methods available in the module.</p>"},{"location":"MATH/USAGE/usage/#import-tinymath-as-a-whole","title":"Import TinyMath as a Whole","text":"<p>Info</p> <p>Suitable for C projects or projects with a simple structure in C++.</p> <pre><code>#include \"tiny_math.h\"\n</code></pre>"},{"location":"MATH/USAGE/usage/#import-tinymath-by-module","title":"Import TinyMath by Module","text":"<p>Info</p> <p>Suitable for projects that require precise control over module imports or complex C++ projects.</p> <pre><code>#include \"tiny_vec.h\" // Import vector module\n#include \"tiny_mat.h\" // Import matrix module\n</code></pre> <pre><code>#include \"tiny_matrix.hpp\" // Import advanced matrix module\n</code></pre> <p>Note</p> <ul> <li> <p><code>tiny_vec.h</code> and <code>tiny_mat.h</code> are header files for the C language version, suitable for C programming.</p> </li> <li> <p><code>tiny_matrix.hpp</code> is a header file for the C++ language version, suitable for C++ programming.</p> </li> </ul> <p>In simple terms, C language projects can only use <code>tiny_vec.h</code> and <code>tiny_mat.h</code>, while C++ projects can use <code>tiny_vec.h</code>, <code>tiny_mat.h</code>, and <code>tiny_matrix.hpp</code>.</p>"},{"location":"MATH/VECTOR/api/","title":"VECTOR OPERATIONS","text":""},{"location":"MATH/VECTOR/api/#list-of-functions","title":"LIST OF FUNCTIONS","text":"<pre><code>// Addition\ntiny_error_t tiny_vec_add_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_addc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n// Subtraction\ntiny_error_t tiny_vec_sub_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_subc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n// Multiplication\ntiny_error_t tiny_vec_mul_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_mulc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n// Division\ntiny_error_t tiny_vec_div_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out, bool allow_divide_by_zero);\ntiny_error_t tiny_vec_divc_f32(const float *input, float *output, int len, float C, int step_in, int step_out, bool allow_divide_by_zero);\n// Square root\ntiny_error_t tiny_vec_sqrt_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_sqrtf_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_inv_sqrt_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_inv_sqrtf_f32(const float *input, float *output, int len);\n// Dot product\ntiny_error_t tiny_vec_dotprod_f32(const float *src1, const float *src2, float *dest, int len);\ntiny_error_t tiny_vec_dotprode_f32(const float *src1, const float *src2, float *dest, int len, int step1, int step2);\n</code></pre>"},{"location":"MATH/VECTOR/api/#addition","title":"ADDITION","text":""},{"location":"MATH/VECTOR/api/#addition-of-two-vectors","title":"Addition of Two Vectors","text":"<pre><code>tiny_error_t tiny_vec_add_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\n</code></pre> <p>Function: Computes the element-wise addition of two vectors.</p> <p>Parameters:</p> <ul> <li><code>input1</code>: Pointer to the first input vector.</li> <li><code>input2</code>: Pointer to the second input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vectors.</li> <li><code>step1</code>: Step size for the first input vector.</li> <li><code>step2</code>: Step size for the second input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#addition-of-a-vector-and-a-constant","title":"Addition of a Vector and a Constant","text":"<pre><code>tiny_error_t tiny_vec_addc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n</code></pre> <p>Function: Computes the element-wise addition of a vector and a constant.</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> <li><code>C</code>: Constant value to be added.</li> <li><code>step_in</code>: Step size for the input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#subtraction","title":"SUBTRACTION","text":""},{"location":"MATH/VECTOR/api/#subtraction-of-two-vectors","title":"Subtraction of Two Vectors","text":"<pre><code>tiny_error_t tiny_vec_sub_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\n</code></pre> <p>Function: Computes the element-wise subtraction of two vectors.</p> <p>Parameters:</p> <ul> <li><code>input1</code>: Pointer to the first input vector.</li> <li><code>input2</code>: Pointer to the second input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vectors.</li> <li><code>step1</code>: Step size for the first input vector.</li> <li><code>step2</code>: Step size for the second input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#subtraction-of-a-vector-and-a-constant","title":"Subtraction of a Vector and a Constant","text":"<pre><code>tiny_error_t tiny_vec_subc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n</code></pre> <p>Function: Computes the element-wise subtraction of a vector and a constant.</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> <li><code>C</code>: Constant value to be subtracted.</li> <li><code>step_in</code>: Step size for the input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#multiplication","title":"MULTIPLICATION","text":""},{"location":"MATH/VECTOR/api/#multiplication-of-two-vectors","title":"Multiplication of Two Vectors","text":"<pre><code>tiny_error_t tiny_vec_mul_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\n</code></pre> <p>Function: Computes the element-wise multiplication of two vectors.</p> <p>Parameters:</p> <ul> <li><code>input1</code>: Pointer to the first input vector.</li> <li><code>input2</code>: Pointer to the second input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vectors.</li> <li><code>step1</code>: Step size for the first input vector.</li> <li><code>step2</code>: Step size for the second input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#multiplication-of-a-vector-and-a-constant","title":"Multiplication of a Vector and a Constant","text":"<pre><code>tiny_error_t tiny_vec_mulc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n</code></pre> <p>Function: Computes the element-wise multiplication of a vector and a constant.</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> <li><code>C</code>: Constant value to be multiplied.</li> <li><code>step_in</code>: Step size for the input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#division","title":"DIVISION","text":""},{"location":"MATH/VECTOR/api/#division-of-two-vectors","title":"Division of Two Vectors","text":"<pre><code>tiny_error_t tiny_vec_div_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out, bool allow_divide_by_zero);\n</code></pre> <p>Function: Computes the element-wise division of two vectors.</p> <p>Parameters:</p> <ul> <li><code>input1</code>: Pointer to the first input vector.</li> <li><code>input2</code>: Pointer to the second input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vectors.</li> <li><code>step1</code>: Step size for the first input vector.</li> <li><code>step2</code>: Step size for the second input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> <li><code>allow_divide_by_zero</code>: Flag to allow division by zero (true or false).</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#division-of-a-vector-and-a-constant","title":"Division of a Vector and a Constant","text":"<pre><code>tiny_error_t tiny_vec_divc_f32(const float *input, float *output, int len, float C, int step_in, int step_out, bool allow_divide_by_zero);\n</code></pre> <p>Function: Computes the element-wise division of a vector and a constant.</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> <li><code>C</code>: Constant value to be divided.</li> <li><code>step_in</code>: Step size for the input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> <li><code>allow_divide_by_zero</code>: Flag to allow division by zero (true or false).</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#square-root","title":"SQUARE ROOT","text":""},{"location":"MATH/VECTOR/api/#square-root-of-a-vector","title":"Square Root of a Vector","text":"<pre><code>tiny_error_t tiny_vec_sqrt_f32(const float *input, float *output, int len);\n</code></pre> <p>Function: Computes the element-wise square root of a vector.</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#square-root-of-a-vector-fast","title":"Square Root of a Vector (Fast)","text":"<pre><code>tiny_error_t tiny_vec_sqrtf_f32(const float *input, float *output, int len);\n</code></pre> <p>Function: Computes the element-wise square root of a vector (fast version).</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#inverse-square-root-of-a-vector","title":"Inverse Square Root of a Vector","text":"<pre><code>tiny_error_t tiny_vec_inv_sqrt_f32(const float *input, float *output, int len);\n</code></pre> <p>Function: Computes the element-wise inverse square root of a vector.</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#inverse-square-root-of-a-vector-fast","title":"Inverse Square Root of a Vector (Fast)","text":"<pre><code>tiny_error_t tiny_vec_inv_sqrtf_f32(const float *input, float *output, int len);\n</code></pre> <p>Function: Computes the element-wise inverse square root of a vector (fast version).</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#dot-product","title":"DOT PRODUCT","text":""},{"location":"MATH/VECTOR/api/#dot-product-of-two-vectors","title":"Dot Product of Two Vectors","text":"<pre><code>tiny_error_t tiny_vec_dotprod_f32(const float *src1, const float *src2, float *dest, int len);\n</code></pre> <p>Function: Computes the dot product of two vectors.</p> <p>Parameters:</p> <ul> <li><code>src1</code>: Pointer to the first input vector.</li> <li><code>src2</code>: Pointer to the second input vector.</li> <li><code>dest</code>: Pointer to the output scalar value.</li> <li><code>len</code>: Length of the vectors.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#dot-product-of-two-vectors-with-different-steps","title":"Dot Product of Two Vectors with Different Steps","text":"<pre><code>tiny_error_t tiny_vec_dotprode_f32(const float *src1, const float *src2, float *dest, int len, int step1, int step2);\n</code></pre> <p>Function: Computes the dot product of two vectors with different step sizes.</p> <p>Parameters:</p> <ul> <li><code>src1</code>: Pointer to the first input vector.</li> <li><code>src2</code>: Pointer to the second input vector.</li> <li><code>dest</code>: Pointer to the output scalar value.</li> <li><code>len</code>: Length of the vectors.</li> <li><code>step1</code>: Step size for the first input vector.</li> <li><code>step2</code>: Step size for the second input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/code/","title":"CODE","text":""},{"location":"MATH/VECTOR/code/#tiny_vech","title":"tiny_vec.h","text":"<pre><code>/**\n * @file tiny_vec.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the submodule vec of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY__VEC__\n#define __TINY__VEC__\n\n/* DEPENDENCIES */\n#include \"tiny_math_config.h\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* FUNCTION PROTOTYPES */\ntiny_error_t tiny_vec_add_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_addc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\ntiny_error_t tiny_vec_sub_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_subc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\ntiny_error_t tiny_vec_mul_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_mulc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\ntiny_error_t tiny_vec_div_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out, bool allow_divide_by_zero);\ntiny_error_t tiny_vec_divc_f32(const float *input, float *output, int len, float C, int step_in, int step_out, bool allow_divide_by_zero);\ntiny_error_t tiny_vec_sqrt_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_sqrtf_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_inv_sqrt_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_inv_sqrtf_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_dotprod_f32(const float *src1, const float *src2, float *dest, int len);\ntiny_error_t tiny_vec_dotprode_f32(const float *src1, const float *src2, float *dest, int len, int step1, int step2);\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY__VEC__ */\n</code></pre>"},{"location":"MATH/VECTOR/code/#tiny_vecc","title":"tiny_vec.c","text":"<pre><code>/**\n * @file tiny_vec.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the source file for the submodule vec of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n *\n */\n\n#include \"tiny_vec.h\"\n\n// #ifdef __cplusplus\n\n/* ADDITION */\n\n// vector + vector | float\n\n/**\n * @name tiny_vec_add_f32\n * @brief Adds two vectors element-wise.\n * @param input1 Pointer to the first input vector.\n * @param input2 Pointer to the second input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param step1 Step size for the first input vector.\n * @param step2 Step size for the second input vector.\n * @param step_out Step size for the output vector.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function performs element-wise addition of two vectors with specified step sizes, and the output is also specified with a step size.\n */\ntiny_error_t tiny_vec_add_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out)\n{\n    if (NULL == input1 || NULL == input2 || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (len &lt;= 0 || step1 &lt;= 0 || step2 &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized vector addition\n    dsps_add_f32(input1, input2, output, len, step1, step2, step_out);\n#else\n    // Fallback to a simple loop for vector addition\n    for (int i = 0; i &lt; len; i++)\n    {\n        output[i * step_out] = input1[i * step1] + input2[i * step2];\n    }\n\n#endif\n\n    return TINY_OK;\n}\n\n// vector + constant | float\n/**\n * @name tiny_vec_addc_f32\n * @brief Adds a constant to each element of a vector.\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param C Constant value to be added.\n * @param step_in Step size for the input vector.\n * @param step_out Step size for the output vector.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function adds a constant value to each element of the input vector, with specified step sizes for both input and output vectors.\n */\ntiny_error_t tiny_vec_addc_f32(const float *input, float *output, int len, float C, int step_in, int step_out)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (len &lt;= 0 || step_in &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized vector addition\n    dsps_addc_f32(input, output, len, C, step_in, step_out);\n#else\n    // Fallback to a simple loop for vector addition\n    for (int i = 0; i &lt; len; i++)\n    {\n        output[i * step_out] = input[i * step_in] + C;\n    }\n#endif\n    return TINY_OK;\n}\n\n/* SUBTRACTION */\n\n// vector - vector | float\n/**\n * @name tiny_vec_sub_f32\n * @brief Subtracts two vectors element-wise.\n * @param input1 Pointer to the first input vector.\n * @param input2 Pointer to the second input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param step1 Step size for the first input vector.\n * @param step2 Step size for the second input vector.\n * @param step_out Step size for the output vector.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function performs element-wise subtraction of two vectors with specified step sizes, and the output is also specified with a step size.\n */\ntiny_error_t tiny_vec_sub_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out)\n{\n    if (NULL == input1 || NULL == input2 || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (len &lt;= 0 || step1 &lt;= 0 || step2 &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized vector subtraction\n    dsps_sub_f32(input1, input2, output, len, step1, step2, step_out);\n#else\n    // Fallback to a simple loop for vector subtraction\n    for (int i = 0; i &lt; len; i++)\n    {\n        output[i * step_out] = input1[i * step1] - input2[i * step2];\n    }\n#endif\n    return TINY_OK;\n}\n\n// vector - constant (add -c) | float\n/**\n * @name tiny_vec_subc_f32\n * @brief Subtracts a constant from each element of a vector.\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param C Constant value to be subtracted.\n * @param step_in Step size for the input vector.\n * @param step_out Step size for the output vector.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function subtracts a constant value from each element of the input vector, with specified step sizes for both input and output vectors.\n */\ntiny_error_t tiny_vec_subc_f32(const float *input, float *output, int len, float C, int step_in, int step_out)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (len &lt;= 0 || step_in &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized vector subtraction\n    dsps_addc_f32(input, output, len, -C, step_in, step_out);\n#else\n    // Fallback to a simple loop for vector subtraction\n    for (int i = 0; i &lt; len; i++)\n    {\n        output[i * step_out] = input[i * step_in] - C;\n    }\n#endif\n    return TINY_OK;\n}\n\n/* MULTIPLICATION */\n\n// vector * vector (elementwise) | float\n/**\n * @name tiny_vec_mul_f32\n * @brief Multiplies two vectors element-wise.\n * @param input1 Pointer to the first input vector.\n * @param input2 Pointer to the second input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param step1 Step size for the first input vector.\n * @param step2 Step size for the second input vector.\n * @param step_out Step size for the output vector.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function performs element-wise multiplication of two vectors with specified step sizes, and the output is also specified with a step size.\n */\ntiny_error_t tiny_vec_mul_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out)\n{\n    if (NULL == input1 || NULL == input2 || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (len &lt;= 0 || step1 &lt;= 0 || step2 &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized vector multiplication\n    dsps_mul_f32(input1, input2, output, len, step1, step2, step_out);\n#else\n    // Fallback to a simple loop for vector multiplication\n    for (int i = 0; i &lt; len; i++)\n    {\n        output[i * step_out] = input1[i * step1] * input2[i * step2];\n    }\n#endif\n        return TINY_OK;\n}\n\n// vector * constant | float\n/**\n * @name tiny_vec_mulc_f32\n * @brief Multiplies each element of a vector by a constant.\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param C Constant value to be multiplied.\n * @param step_in Step size for the input vector.\n * @param step_out Step size for the output vector.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function multiplies each element of the input vector by a constant value, with specified step sizes for both input and output vectors.\n */\ntiny_error_t tiny_vec_mulc_f32(const float *input, float *output, int len, float C, int step_in, int step_out)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (len &lt;= 0 || step_in &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized vector multiplication\n    dsps_mulc_f32(input, output, len, C, step_in, step_out);\n#else\n    // Fallback to a simple loop for vector multiplication\n    for (int i = 0; i &lt; len; i++)\n    {\n        output[i * step_out] = input[i * step_in] * C;\n    }\n#endif\n    return TINY_OK;\n}\n\n/* DIVISION */\n\n// vector / vector (elementwise) | float\n/**\n * @name tiny_vec_div_f32\n * @brief Divides one vector by another element-wise.\n * @param input1 Pointer to the numerator vector.\n * @param input2 Pointer to the denominator vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param step1 Step size for the numerator vector.\n * @param step2 Step size for the denominator vector.\n * @param step_out Step size for the output vector.\n * @param allow_divide_by_zero Whether to safely handle zero denominators (true: set output to 0; false: return error if any zero is found).\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function performs element-wise division with specified step sizes.\n *       If allow_divide_by_zero is false, the function will first scan for zero denominators and return an error immediately if any are found.\n */\ntiny_error_t tiny_vec_div_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out, bool allow_divide_by_zero)\n{\n    if (NULL == input1 || NULL == input2 || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (len &lt;= 0 || step1 &lt;= 0 || step2 &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n    const float epsilon = TINY_MATH_MIN_DENOMINATOR;\n\n    // Step 1: Pre-check for zero denominators if not allowed\n    if (!allow_divide_by_zero)\n    {\n        for (int i = 0; i &lt; len; i++)\n        {\n            if (fabsf(input2[i * step2]) &lt; epsilon)\n            {\n                return TINY_ERR_MATH_ZERO_DIVISION;\n            }\n        }\n    }\n\n    // Step 2: Perform element-wise division\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    for (int i = 0; i &lt; len; i++)\n    {\n        float denom = input2[i * step2];\n        float numer = input1[i * step1];\n        if (fabsf(denom) &lt; epsilon)\n        {\n            output[i * step_out] = allow_divide_by_zero ? 0.0f : numer / denom; // fallback if user forced it\n        }\n        else\n        {\n            output[i * step_out] = numer / denom;\n        }\n    }\n#else\n    for (int i = 0; i &lt; len; i++)\n    {\n        float denom = input2[i * step2];\n        float numer = input1[i * step1];\n        if (fabsf(denom) &lt; epsilon)\n        {\n            output[i * step_out] = allow_divide_by_zero ? 0.0f : numer / denom;\n        }\n        else\n        {\n            output[i * step_out] = numer / denom;\n        }\n    }\n#endif\n\n    return TINY_OK;\n}\n\n// vector / constant | float\n/**\n * @name tiny_vec_divc_f32\n * @brief Divides each element of a vector by a constant using multiplication for performance.\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param C Constant value to divide by.\n * @param step_in Step size for the input vector.\n * @param step_out Step size for the output vector.\n * @param allow_divide_by_zero Whether to safely handle zero constant (true: set output to 0; false: return error if C is near zero).\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function divides each element of the input vector by a constant using multiplication for performance.\n *       If allow_divide_by_zero is false and C is near zero, the function returns an error.\n *       Otherwise, 1/C is precomputed and used as a multiplier.\n */\ntiny_error_t tiny_vec_divc_f32(const float *input, float *output, int len, float C, int step_in, int step_out, bool allow_divide_by_zero)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n\n    if (len &lt;= 0 || step_in &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n    const float epsilon = TINY_MATH_MIN_DENOMINATOR;\n\n    // Step 1: Handle constant C\n    if (fabsf(C) &lt; epsilon)\n    {\n        if (!allow_divide_by_zero)\n        {\n            return TINY_ERR_MATH_ZERO_DIVISION;\n        }\n\n        // Safe fallback: set all outputs to 0\n        for (int i = 0; i &lt; len; i++)\n        {\n            output[i * step_out] = 0.0f;\n        }\n        return TINY_OK;\n    }\n\n    // Step 2: Use 1/C for performance\n    float invC = 1.0f / C;\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    dsps_mulc_f32(input, output, len, invC, step_in, step_out);\n#else\n    for (int i = 0; i &lt; len; i++)\n    {\n        output[i * step_out] = input[i * step_in] * invC;\n    }\n#endif\n\n    return TINY_OK;\n}\n\n/* SQUARE ROOT */\n\n// vector ^ 0.5 (sqrt-based)| float\n/**\n * @name tiny_vec_sqrt_f32\n * @brief Computes the square root of each element in a vector using standard library sqrtf.\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function provides accurate results using math library sqrtf().\n *       It returns TINY_ERR_MATH_NEGATIVE_SQRT immediately if any element is negative.\n */\ntiny_error_t tiny_vec_sqrt_f32(const float *input, float *output, int len)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n\n    if (len &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n    for (int i = 0; i &lt; len; i++)\n    {\n        float x = input[i];\n        if (x &lt; 0.0f)\n        {\n            return TINY_ERR_MATH_NEGATIVE_SQRT;\n        }\n\n        output[i] = sqrtf(x);  // high-precision sqrt\n    }\n\n    return TINY_OK;\n}\n\n// single value sqrt\n/**\n * @name tiny_sqrtf_f32\n * @brief Computes the square root of a single float value using bit manipulation.\n * @param f Input float value.\n * @return Square root of the input value.\n * @note This function uses bit manipulation to compute the square root of a float value.\n *       It returns 0.0f for negative inputs to prevent sqrt of negative values.\n */\ninline float tiny_sqrtf_f32(float f)\n{\n    if (f &lt; 0.0f) {\n        return 0.0f;  // Prevent sqrt of negative values\n    }\n\n    int result;\n    int *f_ptr = (int *)&amp;f;\n    result = 0x1fbb4000 + (*f_ptr &gt;&gt; 1);\n    const int *p = &amp;result;\n    float *f_result = (float *)p;\n    return *f_result;\n}\n\n// vector ^ 0.5 (sqrtf-based)| float\n/**\n * @name tiny_vec_sqrtf_f32\n * @brief Computes the square root of each element in a vector.\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function computes the square root of each element in the input vector and stores the result in the output vector.\n *       It returns TINY_ERR_MATH_NEGATIVE_SQRT immediately if any element is negative.\n */\ntiny_error_t tiny_vec_sqrtf_f32(const float *input, float *output, int len)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n\n    if (len &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n    for (int i = 0; i &lt; len; i++)\n    {\n        float x = input[i];\n        if (x &lt; 0.0f)\n        {\n            return TINY_ERR_MATH_NEGATIVE_SQRT;\n        }\n\n        output[i] = tiny_sqrtf_f32(x);\n    }\n\n    return TINY_OK;\n}\n\n// vector ^ -0.5 (sqrt-based) | float\n/**\n * @name tiny_vec_inv_sqrt_f32\n * @brief Computes the inverse square root of each element in a vector using standard sqrtf().\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function provides accurate inverse square root results using 1.0f / sqrtf(x).\n *       It returns TINY_ERR_NOT_ALLOWED immediately if any element is less than TINY_MATH_MIN_POSITIVE_INPUT_F32.\n */\ntiny_error_t tiny_vec_inv_sqrt_f32(const float *input, float *output, int len)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n\n    if (len &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n    for (int i = 0; i &lt; len; i++)\n    {\n        float x = input[i];\n        if (x &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32)\n        {\n            return TINY_ERR_NOT_ALLOWED;\n        }\n\n        output[i] = 1.0f / sqrtf(x);  // Accurate inverse square root\n    }\n\n    return TINY_OK;\n}\n\n\n// single value inv sqrt\n/**\n * @name tiny_inverted_sqrtf_f32\n * @brief Computes the inverse square root of a single float value using bit manipulation.\n * @param data Input float value.\n * @return Inverse square root of the input value.\n * @note This function uses bit manipulation to compute the inverse square root of a float value.\n *       It returns 0.0f for negative or near-zero inputs to prevent division by zero.\n */\nfloat tiny_inverted_sqrtf_f32(float data)\n{\n    if (data &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32) {\n        return 0.0f;  // Avoid division by near-zero or zero\n    }\n\n    const float x2 = data * 0.5F;\n    const float threehalfs = 1.5F;\n\n    union {\n        float f;\n        uint32_t i;\n    } conv = {data};\n\n    conv.i  = 0x5f3759df - (conv.i &gt;&gt; 1);\n    conv.f  = conv.f * (threehalfs - (x2 * conv.f * conv.f));\n\n    return conv.f;\n}\n\n// vector ^ -0.5 (sqrtf-based) | float\n/**\n * @name tiny_vec_inv_sqrtf_f32\n * @brief Computes the inverse square root of each element in a vector.\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function computes the inverse square root of each element in the input vector and stores the result in the output vector.\n *       If any element is less than TINY_MATH_MIN_POSITIVE_INPUT_F32, the function returns TINY_ERR_NOT_ALLOWED.\n */\ntiny_error_t tiny_vec_inv_sqrtf_f32(const float *input, float *output, int len)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n\n    if (len &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n    for (int i = 0; i &lt; len; i++)\n    {\n        float x = input[i];\n        if (x &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32)\n        {\n            return TINY_ERR_NOT_ALLOWED;\n        }\n\n        output[i] = tiny_inverted_sqrtf_f32(x);\n    }\n\n    return TINY_OK;\n}\n\n/* DOT PRODUCT */\n\n// vector * vector (dot product) | float\n/**\n * @name tiny_vec_dotprod_f32\n * @brief Computes the dot product of two vectors.\n * @param src1 Pointer to the first input vector.\n * @param src2 Pointer to the second input vector.\n * @param dest Pointer to the output scalar result.\n * @param len Length of the vectors.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function computes the dot product of two vectors and stores the result in a single float value.\n *       It returns TINY_ERR_MATH_NULL_POINTER if any pointer is NULL.\n *       The function uses the ESP-DSP library for optimized computation.\n */\ntiny_error_t tiny_vec_dotprod_f32(const float *src1, const float *src2, float *dest, int len)\n{\n    if (NULL == src1 || NULL == src2 || NULL == dest)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n\n    if (len &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized dot product\n    dsps_dotprod_f32(src1, src2, dest, len);\n#else\n    // Fallback to a simple loop for dot product\n    float acc = 0.0f;\n    for (int i = 0; i &lt; len; i++)\n    {\n        acc += src1[i] * src2[i];\n    }\n    *dest = acc;\n#endif\n    return TINY_OK;\n}\n\n// vector * vector (dot product - step support) | float\n/**\n * @name tiny_vec_dotprode_f32\n * @brief Computes the dot product of two vectors with step support.\n * @param src1 Pointer to the first input vector.\n * @param src2 Pointer to the second input vector.\n * @param dest Pointer to the output scalar result.\n * @param len Length of the vectors.\n * @param step1 Step size for the first input vector.\n * @param step2 Step size for the second input vector.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function computes the dot product of two vectors with specified step sizes and stores the result in a single float value.\n */\ntiny_error_t tiny_vec_dotprode_f32(const float *src1, const float *src2, float *dest, int len, int step1, int step2)\n{\n    if (NULL == src1 || NULL == src2 || NULL == dest)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n\n    if (len &lt;= 0 || step1 &lt;= 0 || step2 &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized dot product with step support\n    dsps_dotprode_f32(src1, src2, dest, len, step1, step2);\n#else\n    // Fallback to a simple loop for dot product with step support\n    float acc = 0.0f;\n    for (int i = 0; i &lt; len; i++)\n    {\n        acc += src1[i * step1] * src2[i * step2];\n    }\n    *dest = acc;\n#endif\n    return TINY_OK;\n}\n</code></pre>"},{"location":"MATH/VECTOR/test/","title":"VECTOR OPERATIONS TEST","text":"<p>Vector Operations Test</p> <p>This test is designed to evaluate the performance of vector-related functions.</p>"},{"location":"MATH/VECTOR/test/#test-code","title":"Test Code","text":""},{"location":"MATH/VECTOR/test/#tiny_vec_testh","title":"tiny_vec_test.h","text":"<pre><code>/**\n * @file tiny_vec_test.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the test header file for the submodule vec of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n */\n\n#ifndef __TINY_VEC_TEST_H__\n#define __TINY_VEC_TEST_H__\n\n#include \"tiny_math_config.h\"\n#include \"tiny_vec.h\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n    /**\n     * @name tiny_vec_test\n     * @brief Run unit tests and timing benchmarks for the tiny_vec module.\n     */\n    void tiny_vec_test(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n/** End of __TINY_VEC_TEST_H__ */\n#endif /* __TINY_VEC_TEST_H__ */\n</code></pre>"},{"location":"MATH/VECTOR/test/#tiny_vec_testc","title":"tiny_vec_test.c","text":"<pre><code>/**\n * @file tiny_vec_test.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file implements test functions for the submodule vec of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n */\n\n#include \"tiny_vec_test.h\"\n\n#define LEN 6\n\n#define RUN_VEC_TEST(FUNC, ...)                              \\\n    do                                                       \\\n    {                                                        \\\n        TinyTimeMark_t t0 = tiny_get_running_time();         \\\n        tiny_error_t err = FUNC(__VA_ARGS__);                \\\n        TinyTimeMark_t t1 = tiny_get_running_time();         \\\n        double dt = (double)(t1 - t0);                       \\\n        printf(\"%-24s | Output: \", #FUNC);                   \\\n        for (int i = 0; i &lt; LEN; i++)                        \\\n        {                                                    \\\n            printf(\"%10.6f \", out[i]);                       \\\n        }                                                    \\\n        printf(\"| Time: %6.2f us | Error: %d\\n\\r\", dt, err); \\\n    } while (0)\n\nvoid tiny_vec_test(void)\n{\n    float a[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};\n    float b[] = {6.0f, 5.0f, 4.0f, 3.0f, 2.0f, 1.0f};\n    float out[LEN];\n    float C = 2.0f;\n    float dot_result = 0.0f;\n\n    printf(\"============ [tiny_vec_test] ============\\n\\r\");\n\n    printf(\"Input Vector a:        \");\n    for (int i = 0; i &lt; LEN; i++)\n        printf(\"%10.6f \", a[i]);\n    printf(\"\\n\\r\");\n\n    printf(\"Input Vector b:        \");\n    for (int i = 0; i &lt; LEN; i++)\n        printf(\"%10.6f \", b[i]);\n    printf(\"\\n\\r\");\n\n    printf(\"Constant C:            %10.6f\\n\\r\\n\\r\", C);\n\n    RUN_VEC_TEST(tiny_vec_add_f32, a, b, out, LEN, 1, 1, 1);\n    RUN_VEC_TEST(tiny_vec_addc_f32, a, out, LEN, C, 1, 1);\n    RUN_VEC_TEST(tiny_vec_sub_f32, a, b, out, LEN, 1, 1, 1);\n    RUN_VEC_TEST(tiny_vec_subc_f32, a, out, LEN, C, 1, 1);\n    RUN_VEC_TEST(tiny_vec_mul_f32, a, b, out, LEN, 1, 1, 1);\n    RUN_VEC_TEST(tiny_vec_mulc_f32, a, out, LEN, C, 1, 1);\n    RUN_VEC_TEST(tiny_vec_div_f32, a, b, out, LEN, 1, 1, 1, true);\n    RUN_VEC_TEST(tiny_vec_divc_f32, a, out, LEN, C, 1, 1, true);\n    RUN_VEC_TEST(tiny_vec_sqrt_f32, a, out, LEN);\n    RUN_VEC_TEST(tiny_vec_sqrtf_f32, a, out, LEN);\n    RUN_VEC_TEST(tiny_vec_inv_sqrt_f32, a, out, LEN);\n    RUN_VEC_TEST(tiny_vec_inv_sqrtf_f32, a, out, LEN);\n\n    // Dot product (non-strided)\n    {\n        TinyTimeMark_t t0 = tiny_get_running_time();\n        tiny_error_t err = tiny_vec_dotprod_f32(a, b, &amp;dot_result, LEN);\n        TinyTimeMark_t t1 = tiny_get_running_time();\n        double dt = (double)(t1 - t0);\n        printf(\"%-24s | Output: %10.6f | Time: %6.2f us | Error: %d\\n\\r\", \"tiny_vec_dotprod_f32\", dot_result, dt, err);\n    }\n\n    // Dot product (strided)\n    {\n        TinyTimeMark_t t0 = tiny_get_running_time();\n        tiny_error_t err = tiny_vec_dotprode_f32(a, b, &amp;dot_result, LEN, 1, 1);\n        TinyTimeMark_t t1 = tiny_get_running_time();\n        double dt = (double)(t1 - t0);\n        printf(\"%-24s | Output: %10.6f | Time: %6.2f us | Error: %d\\n\\r\", \"tiny_vec_dotprode_f32\", dot_result, dt, err);\n    }\n\n    printf(\"============ [test complete] ============\\n\\r\");\n}\n</code></pre>"},{"location":"MATH/VECTOR/test/#test-output","title":"Test Output","text":""},{"location":"MEASUREMENT/code/","title":"CODE","text":"<p>Warning</p> <p>The following code should be based on the code in the release code, which may have been updated.</p>"},{"location":"MEASUREMENT/code/#cmakeliststxt","title":"CMakeLists.txt","text":"<pre><code>set(src_dirs\n    .\n)\n\nset(include_dirs\n    include\n)\n\nset(requires\n    driver\n    tim\n    esp_rtc\n    spi_sdcard\n    mpu6050\n    exit\n    lcd\n    led\n    wifi\n    esp32_mqtt\n    tiny_toolbox\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"MEASUREMENT/code/#measurementh","title":"measurement.h","text":"<pre><code>/**\n * @file measurement.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the measurement module.\n * @version 1.0\n * @date 2025-04-01\n * @copyright Copyright (c) 2025\n * @note Currently, the sesning is realized by FreeRTOS, and therefore the upper limit sampling rate is 1kHz.\n * @todo Sampling by timer + interrupt\n * @todo Sampling by DMA\n */\n\n#ifndef __MEASUREMENT_H__\n#define __MEASUREMENT_H__\n\n/* DEPENDENCIES */\n// SYSTEM\n#include \"esp_system.h\" // ESP32 System\n#include \"esp_log.h\"    // ESP32 Logging\n\n// RTOS\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/event_groups.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/timers.h\"\n#include \"freertos/semphr.h\"\n\n// BSP\n#include \"driver/gptimer.h\"\n#include \"led.h\"\n#include \"lcd.h\"\n#include \"tim.h\"\n#include \"esp_rtc.h\"\n#include \"spi_sdcard.h\"\n#include \"wifi_wpa2_enterprise.h\"\n#include \"mqtt.h\"\n#include \"mpu6050.h\"\n\n// TinyAuton/TinySHM\n#include \"TinyAdapter.h\"\n\n/* VARIABLES */\nextern struct SenseConfig streamline_config; // Streamline configuration\nextern struct SenseConfig sense_config; // Sense configuration\n\n/* FUNCTIONS */\n/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters);\n\n/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters);\n\n#endif /* __MEASUREMENT_H__ */\n</code></pre>"},{"location":"MEASUREMENT/code/#measurementc","title":"measurement.c","text":"<pre><code>/**\n * @file measurement.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the source file for the measurement module.\n * @version 1.0\n * @date 2025-04-01\n * @copyright Copyright (c) 2025\n * @note Currently, the sesning is realized by FreeRTOS, and therefore the upper limit sampling rate is 1kHz.\n * @todo Sampling by timer + interrupt\n * @todo Sampling by DMA\n */\n\n/* DEPENDENCIES */\n#include \"measurement.h\"\n\n/* VARIABLES */\nstatic const char *TAG = \"TinySHM-Measurement\"; // Tag for logging\n\n// static uint8_t mpu6050_deviceid;    // MPU6050 Device ID\nstatic mpu6050_acce_value_t acce; // MPU6050 Accelerometer Value\n// static mpu6050_gyro_value_t gyro;   // MPU6050 Gyroscope Value\nstatic mpu6050_temp_value_t temp; // MPU6050 Temperature Value\n// static complimentary_angle_t angle; // Complimentary Angle\n\n/* DEFINITION */\nstruct SenseConfig\n{\n    int sample_rate;\n    int sample_duration;\n    bool temperature_sense; // whether to sense temperature\n    bool printout;          // not recommened for high sample rate as it will slow down the process\n    bool mqtt_pub;          // not recommened for high sample rate as it will slow down the process\n};\n\nstruct DataStruct\n{\n    int sample_rate;\n    int sample_duration;\n    float sensor_temperature;\n    TinyTimeMark_t start_time_stamp;\n    TinyTimeMark_t *time_stamp;\n    float *acc_data;\n    float *temperature;\n};\n\n/* VARIABLES */\n// for streamline configuration\nstruct SenseConfig streamline_config = {\n    .sample_rate = 1,          // Sample rate in Hz. For local printout + mqtt, at most 25Hz; for only mqtt, at most 200Hz.\n    .temperature_sense = true, // Whether to sense temperature\n    .printout = true,          // Only available for sampling rate &lt;= 100Hz\n    .mqtt_pub = true           // Only available for sampling rate &lt;= 100Hz\n};\n\n// for sensing configuration\nstruct SenseConfig sense_config = {\n    .sample_rate = 500,   // Sample rate in Hz, only can be (1, 2, 5, 10, 20, 25, 50, 100, 200, 500) for FreeRTOS based sensing. Note can not be 1000Hz (no time to feed the watchdog).\n    .sample_duration = 1, // Sample duration in seconds\n    .printout = true      // Only available for sampling rate &lt;= 100Hz\n};\n\n// for data structure\nstruct DataStruct data_struct = {\n    .sample_rate = 0,     // Sample rate in Hz\n    .sample_duration = 0, // Sample duration in seconds\n    .sensor_temperature = 0.0,\n    .start_time_stamp = 0,\n    .acc_data = NULL};\n\n/* FUNCTION PROTOTYPES */\n/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters)\n{\n\n    // streamline variables\n    float acc_x, acc_y, acc_z, temperature;\n    TinyTimeMark_t time_stamp;\n\n    // MQTT publish buffer\n    char streamline_buff[256];\n\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n\n    if (config-&gt;sample_rate &gt; 100 &amp;&amp; config-&gt;printout)\n    {\n        ESP_LOGW(TAG, \"Printout is disabled for sample rate &gt; 100Hz.\");\n        config-&gt;printout = false;\n    }\n\n    while (1)\n    {\n        // get the time stamp\n        time_stamp = tiny_get_running_time();\n\n        // get accelerometer data\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        acc_x = acce.acce_x;\n        acc_y = acce.acce_y;\n        acc_z = acce.acce_z;\n\n        // get temperature\n        mpu6050_get_temp(mpu6050, &amp;temp);\n        temperature = temp.temp;\n\n        // sprintf\n        if (config-&gt;printout || config-&gt;mqtt_pub)\n        {\n            snprintf(streamline_buff, sizeof(streamline_buff), \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Sensor Temperature: %4.2f \u00b0C\", time_stamp, acc_x, acc_y, acc_z, temperature);\n        }\n\n        // print out the data - comment out for higher sample rate\n        if (config-&gt;printout)\n        {\n            ESP_LOGI(TAG, \"%s\", streamline_buff);\n        }\n\n        // MQTT publish\n        if (config-&gt;mqtt_pub)\n        {\n            esp_mqtt_client_publish(s_mqtt_client, MQTT_PUBLIC_TOPIC, streamline_buff, strlen(streamline_buff), 0, 0); // for streamline, data quality is not expected to be high, so QoS = 0; data retaintion is also not required, so 0.\n        }\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n    ESP_LOGI(TAG, \"Streamline terminated. Task will delete itself.\");\n    vTaskDelete(NULL);\n}\n\n/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters)\n{\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n    int total_samples = config-&gt;sample_rate * config-&gt;sample_duration;\n\n    // Fill global data_struct\n    data_struct.sample_rate = config-&gt;sample_rate;\n    data_struct.sample_duration = config-&gt;sample_duration;\n    mpu6050_get_temp(mpu6050, &amp;temp);\n    data_struct.sensor_temperature = temp.temp;\n    data_struct.start_time_stamp = tiny_get_running_time();\n\n    // Allocate memory\n    data_struct.acc_data = malloc(sizeof(float) * 3 * total_samples);\n    data_struct.temperature = malloc(sizeof(float) * total_samples);\n    data_struct.time_stamp = malloc(sizeof(TinyTimeMark_t) * total_samples);\n\n    if (data_struct.acc_data == NULL || data_struct.temperature == NULL || data_struct.time_stamp == NULL)\n    {\n        ESP_LOGE(TAG, \"Failed to allocate memory for sensing data.\");\n        if (data_struct.acc_data)\n            free(data_struct.acc_data);\n        if (data_struct.temperature)\n            free(data_struct.temperature);\n        if (data_struct.time_stamp)\n            free(data_struct.time_stamp);\n        vTaskDelete(NULL);\n    }\n\n    ESP_LOGI(TAG, \"Sampling started: %d Hz for %d seconds (%d samples)\",\n             config-&gt;sample_rate, config-&gt;sample_duration, total_samples);\n\n    for (int i = 0; i &lt; total_samples; i++)\n    {\n        TinyTimeMark_t now = tiny_get_running_time();\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        mpu6050_get_temp(mpu6050, &amp;temp);\n\n        // Store data\n        data_struct.time_stamp[i] = now;\n        data_struct.acc_data[i * 3 + 0] = acce.acce_x;\n        data_struct.acc_data[i * 3 + 1] = acce.acce_y;\n        data_struct.acc_data[i * 3 + 2] = acce.acce_z;\n        data_struct.temperature[i] = temp.temp;\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n\n    ESP_LOGI(TAG, \"Sampling complete.\");\n\n    // Print metadata\n    ESP_LOGI(TAG, \"-----------------------------\");\n    ESP_LOGI(TAG, \"Sensor Temperature : %.2f \u00b0C\", data_struct.sensor_temperature);\n    ESP_LOGI(TAG, \"Start Time Stamp   : %ld\", (long)data_struct.start_time_stamp);\n    ESP_LOGI(TAG, \"Sample Rate        : %d Hz\", data_struct.sample_rate);\n    ESP_LOGI(TAG, \"Sample Duration    : %d sec\", data_struct.sample_duration);\n    ESP_LOGI(TAG, \"Total Samples      : %d\", total_samples);\n    ESP_LOGI(TAG, \"Data Size          : %.2f KB\",\n             (sizeof(float) * 4 + sizeof(TinyTimeMark_t)) * total_samples / 1024.0f);\n    ESP_LOGI(TAG, \"-----------------------------\");\n\n    // Print collected data if enabled\n    if (config-&gt;printout)\n    {\n        for (int i = 0; i &lt; total_samples; i++)\n        {\n            ESP_LOGI(TAG, \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Temperature: %.2f \u00b0C\",\n                     (long)data_struct.time_stamp[i],\n                     data_struct.acc_data[i * 3 + 0],\n                     data_struct.acc_data[i * 3 + 1],\n                     data_struct.acc_data[i * 3 + 2],\n                     data_struct.temperature[i]);\n\n            // Release CPU for a short time to avoid blocking\n            if ((i % 10) == 0)\n            {\n                vTaskDelay(pdMS_TO_TICKS(10));\n            }\n        }\n    }\n\n    // Free allocated memory\n    if (data_struct.acc_data)\n    {\n        free(data_struct.acc_data);\n        data_struct.acc_data = NULL;\n    }\n    if (data_struct.temperature)\n    {\n        free(data_struct.temperature);\n        data_struct.temperature = NULL;\n    }\n    if (data_struct.time_stamp)\n    {\n        free(data_struct.time_stamp);\n        data_struct.time_stamp = NULL;\n    }\n\n    vTaskDelete(NULL);\n}\n</code></pre>"},{"location":"MEASUREMENT/log/","title":"DEV LOG","text":"<p>2025-04-03</p> <ul> <li>Sampling configuration structure</li> <li>Sampling data structure</li> <li>Real-time sampling function / regular sampling function</li> <li>Sampling frequency upper limit test: real-time (25Hz-local output + MQTT; 200Hz-only MQTT); regular (500Hz)</li> <li>Server-side visualization program</li> <li>Server-side data storage</li> </ul>"},{"location":"MEASUREMENT/measurement/","title":"MEASUREMENT","text":"<p>Measurement</p> <p>High quality measurement/sampling is the basis of data analysis, and TinySHM fully considers this in its design. We have implemented a variety of measurement/sampling methods in TinySHM, and users can choose according to their needs.</p> <p>Warning</p> <p>Currently, development is based on ESP32, and migration to platforms like STM32 will require some modifications to the adaptation layer.</p>"},{"location":"MEASUREMENT/notes/","title":"NOTES","text":""},{"location":"MEASUREMENT/notes/#dependencies","title":"DEPENDENCIES","text":"<p>SYSTEM</p> <pre><code>#include \"esp_system.h\" // ESP32 System\n#include \"esp_log.h\"    // ESP32 Logging\n</code></pre> <p>RTOS</p> <pre><code>#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/event_groups.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/timers.h\"\n#include \"freertos/semphr.h\"\n</code></pre> <p>BSP</p> <pre><code>#include \"driver/gptimer.h\"\n#include \"led.h\"\n#include \"lcd.h\"\n#include \"tim.h\"\n#include \"esp_rtc.h\"\n#include \"spi_sdcard.h\"\n#include \"wifi_wpa2_enterprise.h\"\n#include \"mqtt.h\"\n#include \"mpu6050.h\"\n</code></pre> <p>TinyAuton/TinySHM</p> <pre><code>#include \"TinyAdapter.h\"\n</code></pre>"},{"location":"MEASUREMENT/notes/#sampling-configuration-struct","title":"SAMPLING CONFIGURATION STRUCT","text":"<p>Definition</p> <pre><code>struct SenseConfig\n{\n    int sample_rate;\n    int sample_duration;\n    bool temperature_sense; // whether to sense temperature\n    bool printout;          // not recommened for high sample rate as it will slow down the process\n    bool mqtt_pub;          // not recommened for high sample rate as it will slow down the process\n};\n</code></pre> <p>Usage - Streamline</p> <pre><code>// for streamline configuration\nstruct SenseConfig streamline_config = {\n    .sample_rate = 1,          // Sample rate in Hz. For local printout + mqtt, at most 25Hz; for only mqtt, at most 200Hz.\n    .temperature_sense = true, // Whether to sense temperature\n    .printout = true,          // Only available for sampling rate &lt;= 100Hz\n    .mqtt_pub = true           // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre> <p>Usage - Normal</p> <pre><code>// for sensing configuration\nstruct SenseConfig sense_config = {\n    .sample_rate = 500,   // Sample rate in Hz, only can be (1, 2, 5, 10, 20, 25, 50, 100, 200, 500) for FreeRTOS based sensing. Note can not be 1000Hz (no time to feed the watchdog).\n    .sample_duration = 1, // Sample duration in seconds\n    .printout = true      // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre>"},{"location":"MEASUREMENT/notes/#sampling-data-struct","title":"SAMPLING DATA STRUCT","text":"<pre><code>struct DataStruct\n{\n    int sample_rate;\n    int sample_duration;\n    float sensor_temperature;\n    TinyTimeMark_t start_time_stamp;\n    TinyTimeMark_t *time_stamp;\n    float *acc_data;\n    float *temperature;\n};\n</code></pre> <p>usage</p> <pre><code>// for data structure\nstruct DataStruct data_struct = {\n    .sample_rate = 0,     // Sample rate in Hz\n    .sample_duration = 0, // Sample duration in seconds\n    .sensor_temperature = 0.0,\n    .start_time_stamp = 0,\n    .acc_data = NULL}; \n</code></pre>"},{"location":"MEASUREMENT/notes/#sampling-principle","title":"SAMPLING PRINCIPLE","text":"<ul> <li>FreeRTOS based sampling</li> <li>Timer &amp; Interrupt based sampling (to be developed)</li> </ul>"},{"location":"MEASUREMENT/notes/#sampling-modes-and-tasks","title":"SAMPLING MODES AND TASKS","text":"<p>Currently, there are two sampling modes: - Streamline mode - Normal mode</p>"},{"location":"MEASUREMENT/notes/#streamline-sampling","title":"Streamline Sampling","text":"<p>Definition</p> <pre><code>/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters)\n{\n\n    // streamline variables\n    float acc_x, acc_y, acc_z, temperature;\n    TinyTimeMark_t time_stamp;\n\n    // MQTT publish buffer\n    char streamline_buff[256];\n\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n\n    if (config-&gt;sample_rate &gt; 100 &amp;&amp; config-&gt;printout)\n    {\n        ESP_LOGW(TAG, \"Printout is disabled for sample rate &gt; 100Hz.\");\n        config-&gt;printout = false;\n    }\n\n    while (1)\n    {\n        // get the time stamp\n        time_stamp = tiny_get_running_time();\n\n        // get accelerometer data\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        acc_x = acce.acce_x;\n        acc_y = acce.acce_y;\n        acc_z = acce.acce_z;\n\n        // get temperature\n        mpu6050_get_temp(mpu6050, &amp;temp);\n        temperature = temp.temp;\n\n        // sprintf\n        if (config-&gt;printout || config-&gt;mqtt_pub)\n        {\n            snprintf(streamline_buff, sizeof(streamline_buff), \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Sensor Temperature: %4.2f \u00b0C\", time_stamp, acc_x, acc_y, acc_z, temperature);\n        }\n\n        // print out the data - comment out for higher sample rate\n        if (config-&gt;printout)\n        {\n            ESP_LOGI(TAG, \"%s\", streamline_buff);\n        }\n\n        // MQTT publish\n        if (config-&gt;mqtt_pub)\n        {\n            esp_mqtt_client_publish(s_mqtt_client, MQTT_PUBLIC_TOPIC, streamline_buff, strlen(streamline_buff), 0, 0); // for streamline, data quality is not expected to be high, so QoS = 0; data retaintion is also not required, so 0.\n        }\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n    ESP_LOGI(TAG, \"Streamline terminated. Task will delete itself.\");\n    vTaskDelete(NULL);\n}\n</code></pre> <p>Usage</p> <pre><code>xTaskCreate(acc_streamline_task, \"Accel_Streamline_Task\", 4096, &amp;streamline_config, 5, NULL);\n</code></pre>"},{"location":"MEASUREMENT/notes/#normal-sampling","title":"Normal Sampling","text":"<p>Definition</p> <pre><code>/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters)\n{\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n    int total_samples = config-&gt;sample_rate * config-&gt;sample_duration;\n\n    // Fill global data_struct\n    data_struct.sample_rate = config-&gt;sample_rate;\n    data_struct.sample_duration = config-&gt;sample_duration;\n    mpu6050_get_temp(mpu6050, &amp;temp);\n    data_struct.sensor_temperature = temp.temp;\n    data_struct.start_time_stamp = tiny_get_running_time();\n\n    // Allocate memory\n    data_struct.acc_data = malloc(sizeof(float) * 3 * total_samples);\n    data_struct.temperature = malloc(sizeof(float) * total_samples);\n    data_struct.time_stamp = malloc(sizeof(TinyTimeMark_t) * total_samples);\n\n    if (data_struct.acc_data == NULL || data_struct.temperature == NULL || data_struct.time_stamp == NULL)\n    {\n        ESP_LOGE(TAG, \"Failed to allocate memory for sensing data.\");\n        if (data_struct.acc_data)\n            free(data_struct.acc_data);\n        if (data_struct.temperature)\n            free(data_struct.temperature);\n        if (data_struct.time_stamp)\n            free(data_struct.time_stamp);\n        vTaskDelete(NULL);\n    }\n\n    ESP_LOGI(TAG, \"Sampling started: %d Hz for %d seconds (%d samples)\",\n             config-&gt;sample_rate, config-&gt;sample_duration, total_samples);\n\n    for (int i = 0; i &lt; total_samples; i++)\n    {\n        TinyTimeMark_t now = tiny_get_running_time();\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        mpu6050_get_temp(mpu6050, &amp;temp);\n\n        // Store data\n        data_struct.time_stamp[i] = now;\n        data_struct.acc_data[i * 3 + 0] = acce.acce_x;\n        data_struct.acc_data[i * 3 + 1] = acce.acce_y;\n        data_struct.acc_data[i * 3 + 2] = acce.acce_z;\n        data_struct.temperature[i] = temp.temp;\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n\n    ESP_LOGI(TAG, \"Sampling complete.\");\n\n    // Print metadata\n    ESP_LOGI(TAG, \"-----------------------------\");\n    ESP_LOGI(TAG, \"Sensor Temperature : %.2f \u00b0C\", data_struct.sensor_temperature);\n    ESP_LOGI(TAG, \"Start Time Stamp   : %ld\", (long)data_struct.start_time_stamp);\n    ESP_LOGI(TAG, \"Sample Rate        : %d Hz\", data_struct.sample_rate);\n    ESP_LOGI(TAG, \"Sample Duration    : %d sec\", data_struct.sample_duration);\n    ESP_LOGI(TAG, \"Total Samples      : %d\", total_samples);\n    ESP_LOGI(TAG, \"Data Size          : %.2f KB\",\n             (sizeof(float) * 4 + sizeof(TinyTimeMark_t)) * total_samples / 1024.0f);\n    ESP_LOGI(TAG, \"-----------------------------\");\n\n    // Print collected data if enabled\n    if (config-&gt;printout)\n    {\n        for (int i = 0; i &lt; total_samples; i++)\n        {\n            ESP_LOGI(TAG, \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Temperature: %.2f \u00b0C\",\n                     (long)data_struct.time_stamp[i],\n                     data_struct.acc_data[i * 3 + 0],\n                     data_struct.acc_data[i * 3 + 1],\n                     data_struct.acc_data[i * 3 + 2],\n                     data_struct.temperature[i]);\n\n            // Release CPU for a short time to avoid blocking\n            if ((i % 10) == 0)\n            {\n                vTaskDelay(pdMS_TO_TICKS(10));\n            }\n        }\n    }\n\n    // Free allocated memory\n    if (data_struct.acc_data)\n    {\n        free(data_struct.acc_data);\n        data_struct.acc_data = NULL;\n    }\n    if (data_struct.temperature)\n    {\n        free(data_struct.temperature);\n        data_struct.temperature = NULL;\n    }\n    if (data_struct.time_stamp)\n    {\n        free(data_struct.time_stamp);\n        data_struct.time_stamp = NULL;\n    }\n\n    vTaskDelete(NULL);\n}\n</code></pre> <p>Usage</p> <pre><code>xTaskCreate(acc_sense_task, \"Accel_Sense_Task\", 8192, &amp;sense_config, 5, NULL);\n</code></pre>"},{"location":"MEASUREMENT/notes/#to-be-developed","title":"TO BE DEVELOPED","text":"<ul> <li>Standard time stamp</li> <li>Calibration</li> <li>Timer &amp; Interrupt based sampling</li> <li>DMA</li> <li>ADC + Analog Sensor</li> <li>Data post-processing</li> <li>Batch data MQTT upload</li> <li>Real-time processing function development</li> </ul>"},{"location":"RELEASES/releases/","title":"RELEASES","text":""},{"location":"RELEASES/releases/#dnesp32s3m-stable","title":"DNESP32S3M-STABLE","text":"<p>Stable version</p>"},{"location":"RELEASES/releases/#dnesp32s3m-latest","title":"DNESP32S3M-LATEST","text":"<p>Latest feature version</p>"},{"location":"TOOLBOX/toolbox/","title":"TOOLBOX","text":"<p>tiny_toolbox</p> <p>tiny_toolbox is a library designed for platform adaptation and optimization, providing various practical tools to serve edge computing and application development. Note that the adaptation and tools are included in the same library because many tools utilize the functions provided by the platform at a lower level. Therefore, placing platform adaptation and various tools together facilitates usage and maintenance.</p> <p>Warning</p> <p>Currently, development is based on ESP32, and migration to platforms like STM32 requires some modifications to the adaptation layer.</p>"},{"location":"TOOLBOX/toolbox/#component-dependencies","title":"COMPONENT DEPENDENCIES","text":"<pre><code>set(src_dirs\n    .\n    time\n)\n\nset(include_dirs\n    .\n    time\n)\n\nset(requires\n    esp_timer\n    esp_rtc\n    espressif__esp-dsp\n    espressif__esp_jpeg\n    espressif__esp-dl\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"TOOLBOX/toolbox/#architecture-and-function-directory","title":"ARCHITECTURE AND FUNCTION DIRECTORY","text":"<pre><code>    tiny_toolbox\n    \u251c\u2500\u2500 CMakeLists.txt\n    \u251c\u2500\u2500 tiny_toolbox.h // serves as a directory, integrating all submodules\n    \u251c\u2500\u2500 time\n    \u2502   \u251c\u2500\u2500 tiny_time.h // submodule for time management - header file\n    \u2502   \u251c\u2500\u2500 tiny_time.c // submodule for time management - source file\n    \u2502   \u2514\u2500\u2500 ...\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"TOOLBOX/toolbox/#time","title":"TIME","text":"<ul> <li>Get Running Time: <code>tiny_get_running_time()</code></li> <li>SNTP Time Synchronization: <code>sync_time_with_timezone(\"CST-8\")</code></li> <li>Get World Time: <code>tiny_get_current_time(1)</code></li> </ul> <p>TODO:</p> <ul> <li>Local Time Synchronization for Wireless Sensor Networks - Microsecond Level</li> </ul>"},{"location":"TOOLBOX/toolbox/#code","title":"CODE","text":"<p>Tip</p> <p>tiny_toolbox.h serves merely as a directory, integrating all submodules. The specific functionalities are implemented in each submodule. tiny_toolbox.c is just a formal source file without specific functionality.</p>"},{"location":"TOOLBOX/toolbox/#cmakeliststxt","title":"CMakeLists.txt","text":"<pre><code>set(src_dirs\n    .\n)\n\nset(include_dirs\n    include\n)\n\nset(requires\n    esp_timer\n    espressif__esp-dsp\n    espressif__esp_jpeg\n    espressif__esp-dl\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"TOOLBOX/toolbox/#tiny_toolboxh","title":"tiny_toolbox.h","text":"<pre><code>/**\n * @file tiny_toolbox.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the tiny_toolbox middleware.\n * @version 1.0\n * @date 2025-03-26\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_TOOLBOX__\n#define __TINY_TOOLBOX__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* DEPENDENCIES */\n// system\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n#include \"esp_timer.h\"\n#include \"esp_heap_caps.h\"\n\n// customized drivers\n#include \"esp_rtc.h\"\n\n/* SUBMODULES */\n#include \"tiny_time.h\" // Time\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_TOOLBOX__ */\n</code></pre>"},{"location":"TOOLBOX/TIME/code/","title":"TIME","text":""},{"location":"TOOLBOX/TIME/code/#tiny_timeh","title":"tiny_time.h","text":"<pre><code>/**\n * @file tiny_time.h    \n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief Submodule for TinyToolbox - header file\n * @version 1.0\n * @date 2025-04-10\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_TIME__\n#define __TINY_TIME__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* CONFIGURATIONS */\n\n/* ================================ DEPENDENCIES ================================ */\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n#include &lt;sys/time.h&gt;\n#include \"esp_log.h\"\n#include \"esp_timer.h\"\n#include \"esp_sntp.h\"\n// customized drivers\n#include \"esp_rtc.h\"\n\n/* ================================ DEFINITIONS ================================= */\ntypedef TickType_t TinyTimeMark_t;\n\n/**\n * @brief Structure to hold date and time\n */\ntypedef struct TinyDateTime_t\n{\n    int year;\n    int month;\n    int day;\n    int hour;\n    int minute;\n    int second;\n    long microsecond;\n} TinyDateTime_t;\n\n/* ================================ FUNCTIONS =================================== */\n/* LOCAL RUNNING TIME IN MICROSECONDS */\n/**\n * @brief Get the running time in microseconds\n * @return TinyTimeMark_t\n */\nTinyTimeMark_t tiny_get_running_time(void);\n\n/* WORLD CURRENT TIME - SNTP */\n/**\n * @brief Obtain the current time with timezone\n * @param timezone_str Timezone string (e.g., \"CST-8\")\n * @note The timezone string should be in the format \"TZ=GMT+/-HH:MM\"\n * @note To use this function, in application, insert \"sync_time_with_timezone(\"CST-8\");\" will do\n * @return None\n */\nvoid sync_time_with_timezone(const char *timezone_str);\n\n/* WORLD CURRENT TIME - GET TIME */\n/**\n * @name tiny_get_current_time\n * @brief Get the current time as a TinyDateTime_t struct\n * @param print_flag Flag to indicate whether to print the time\n * @return TinyDateTime_t structure containing the current date and time\n */\nTinyDateTime_t tiny_get_current_time(bool print_flag);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_TIME__ */\n</code></pre>"},{"location":"TOOLBOX/TIME/code/#tiny_timec","title":"tiny_time.c","text":"<pre><code>/**\n * @file tiny_time.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief Submodule for TinyToolbox - source file\n * @version 1.0\n * @date 2025-04-10\n * @copyright Copyright (c) 2025\n *\n */\n\n/* ================================ DEPENDENCIES ================================ */\n#include \"tiny_time.h\" // Time\n\n/* ================================ DEFINITIONS ================================= */\n/* CONFIGURATIONS */\n\n/* TAGS */\nstatic const char *TAG_SNTP = \"NTP_SYNC\";\nstatic const char *TAG_TIME = \"TIME\";\n\n/* ================================ FUNCTIONS =================================== */\n/* LOCAL RUNNING TIME IN MICROSECONDS */\n/**\n * @brief Get the running time in microseconds\n * @return TinyTimeMark_t\n */\nTinyTimeMark_t tiny_get_running_time(void)\n{\n    return esp_timer_get_time();\n}\n\n/* WORLD CURRENT TIME - SNTP */\n/**\n * @brief Callback function for time synchronization notification\n * @param tv Pointer to the timeval structure containing the synchronized time\n * @return None\n */\nvoid time_sync_notification_cb(struct timeval *tv)\n{\n    ESP_LOGI(TAG_SNTP, \"Time synchronized!\");\n}\n\n/**\n * @brief Initialize SNTP\n * @return None\n */\nvoid initialize_sntp(void)\n{\n    ESP_LOGI(TAG_SNTP, \"Initializing SNTP\");\n    sntp_setoperatingmode(SNTP_OPMODE_POLL);\n    sntp_setservername(0, \"pool.ntp.org\"); // NTP server // pool.ntp.org // ntp.aliyun.com\n    sntp_set_time_sync_notification_cb(time_sync_notification_cb);\n    sntp_init();\n}\n\n/**\n * @brief Obtain the current time with timezone\n * @param timezone_str Timezone string (e.g., \"CST-8\")\n * @note The timezone string should be in the format \"TZ=GMT+/-HH:MM\"\n * @note To use this function, in application, after internet connection, insert \"sync_time_with_timezone(\"CST-8\");\" will do\n * @return None\n */\nvoid sync_time_with_timezone(const char *timezone_str)\n{\n    // Set system timezone\n    setenv(\"TZ\", timezone_str, 1);\n    tzset();\n\n    // Initialize SNTP and start time sync\n    initialize_sntp();\n\n    // Wait for system time to be set\n    time_t now = 0;\n    struct tm timeinfo = { 0 };\n    int retry = 0;\n    const int retry_count = 15;\n\n    while (timeinfo.tm_year &lt; (2020 - 1900) &amp;&amp; ++retry &lt; retry_count) {\n        ESP_LOGI(TAG_SNTP, \"Waiting for system time to be set... (%d/%d)\", retry, retry_count);\n        vTaskDelay(2000 / portTICK_PERIOD_MS);\n        time(&amp;now);\n        localtime_r(&amp;now, &amp;timeinfo);\n    }\n\n    if (timeinfo.tm_year &gt;= (2020 - 1900)) {\n        rtc_set_time(timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday,\n                    timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec); // defined in esp_rtc.c\n        ESP_LOGI(TAG_SNTP, \"System time is set.\");\n    } else {\n        ESP_LOGW(TAG_SNTP, \"Failed to sync time.\");\n        return;\n    }\n\n    // Log current local time\n    ESP_LOGI(TAG_SNTP, \"Current time: %s\", asctime(&amp;timeinfo));\n\n    // vTaskDelay(10000 / portTICK_PERIOD_MS); // Wait for 10 second\n    // rtc_get_time(); // uncomment to check the RTC time\n    // ESP_LOGI(TAG_SNTP, \"Current RTC time: %04d-%02d-%02d %02d:%02d:%02d\",\n    //          calendar.year, calendar.month, calendar.date,\n    //          calendar.hour, calendar.min, calendar.sec); // uncomment to check the RTC time\n\n}\n\n/* WORLD CURRENT TIME - GET TIME */\n/**\n * @name tiny_get_current_time\n * @brief Get the current time as a TinyDateTime_t struct\n * @param print_flag Flag to indicate whether to print the time\n * @return TinyDateTime_t structure containing the current date and time\n */\nTinyDateTime_t tiny_get_current_time(bool print_flag)\n{\n    struct timeval tv;\n    gettimeofday(&amp;tv, NULL);  // Get current time (seconds + microseconds)\n\n    time_t now = tv.tv_sec;\n    struct tm timeinfo;\n    localtime_r(&amp;now, &amp;timeinfo);  // Convert to local time\n\n    TinyDateTime_t result;\n    result.year   = timeinfo.tm_year + 1900;\n    result.month  = timeinfo.tm_mon + 1;\n    result.day    = timeinfo.tm_mday;\n    result.hour   = timeinfo.tm_hour;\n    result.minute = timeinfo.tm_min;\n    result.second = timeinfo.tm_sec;\n    result.microsecond = tv.tv_usec;\n\n    if (print_flag)\n    {\n        ESP_LOGI(TAG_TIME, \"Current Time: %04d-%02d-%02d %02d:%02d:%02d.%06ld\",\n                 result.year, result.month, result.day,\n                 result.hour, result.minute, result.second, tv.tv_usec);\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"TOOLBOX/TIME/log/","title":"LOG","text":"<p>2025-04-10</p> <ul> <li>Get Running Time: <code>tiny_get_running_time()</code></li> <li>SNTP Time Synchronization: <code>sync_time_with_timezone(\"CST-8\")</code></li> <li>Get World Time: <code>tiny_get_current_time(1)</code></li> </ul> <p>TODO:</p> <ul> <li>Local Time Synchronization for Wireless Sensor Networks - Microsecond Level</li> </ul>"},{"location":"TOOLBOX/TIME/notes/","title":"TIME","text":"<p>Time</p> <p>Time related functions are of vital importance for MCU devices. This section provides a series of time related definitions and functions for developers to use.</p> <p>In MCU, time can be divided into the following types:</p> <ul> <li> <p>Running Time: The time from the power-on of the MCU to now.</p> </li> <li> <p>World Time: The time of the time zone where the MCU is located. World time can be represented by standard year, month, day, hour, minute, and second, or it can be represented as a UNIX timestamp.</p> </li> </ul>"},{"location":"TOOLBOX/TIME/notes/#running-time","title":"RUNNING TIME","text":"<p>ESP has its own function to get the running time, <code>esp_timer_get_time</code>, which depends on the <code>esp_timer</code> library. This function returns the time from power-on to now, in microseconds.</p> <p>To facilitate usage, TinyToolbox redefines the data type <code>TinyTimeMark_t</code> and provides a function <code>tiny_get_running_time</code> to get the running time. The time returned by this function is in the unit of TickType_t, which is the time unit defined in FreeRTOS.</p> <pre><code>typedef TickType_t TinyTimeMark_t;\n</code></pre> <pre><code>/**\n * @brief Get the running time in microseconds\n * @return TinyTimeMark_t\n */\nTinyTimeMark_t tiny_get_running_time(void)\n{\n    return esp_timer_get_time();\n}\n</code></pre> <p>Usage reference:</p> <pre><code>void app_main(void)\n{\n    // Get running time\n    TinyTimeMark_t running_time = tiny_get_running_time();\n    ESP_LOGI(TAG_TIME, \"Running Time: %lld us\", running_time);\n}\n</code></pre>"},{"location":"TOOLBOX/TIME/notes/#world-time","title":"WORLD TIME","text":"<p>Warning</p> <p>Note that obtaining world time requires a successful network connection. In other words, the function to obtain world time needs to be called after the network connection is successfully established.</p>"},{"location":"TOOLBOX/TIME/notes/#ntp-time-synchronization","title":"NTP TIME SYNCHRONIZATION","text":"<p>NTP Time Synchronization</p> <p>NTP (Network Time Protocol) is a protocol used to synchronize time in computer networks. It can obtain accurate time information through the Internet or local area network. NTP protocol uses UDP for communication, with the default port being 123. NTP servers periodically send time information to clients, and clients adjust their system time based on this information.</p> <pre><code>    Client                      Server\n      |-------------------&gt;      |     T1\uff1aRequest sent\n      |                          |\n      |         &lt;--------------- |     T2/T3\uff1aServer received &amp; replied\n      |                          |\n      |-------------------&gt;      |     T4\uff1aClient received response\n</code></pre> <p>NTP Time Synchronization Principle</p> <p>NTP time synchronization is based on four timestamps: 1. Timestamp T1 when the client sends the request 2. Timestamp T2 when the server receives the request 3. Timestamp T3 when the server sends the response 4. Timestamp T4 when the client receives the response. Based on these four timestamps, we can calculate Network Delay Delay = (T4 - T1) - (T3 - T2), and Time Offset Offset = ((T2 - T1) + (T3 - T4)) / 2.</p> <p>ESP32 SNTP Time Synchronization</p> <p>In ESP32, SNTP (Simple Network Time Protocol) is used. SNTP is a simplified version of NTP, suitable for scenarios where time accuracy is not critical. The time synchronization in ESP32 relies on the <code>esp_sntp</code> library. The working principle of SNTP is similar to that of NTP, but the implementation of SNTP is relatively simple, making it suitable for embedded devices. Its accuracy is usually at the millisecond level, which is sufficient for most application scenarios.</p> <p>First, define a callback function to receive time synchronization notifications:</p> <p><pre><code>/* WORLD CURRENT TIME - SNTP */\n/**\n * @brief Callback function for time synchronization notification\n * @param tv Pointer to the timeval structure containing the synchronized time\n * @return None\n */\nvoid time_sync_notification_cb(struct timeval *tv)\n{\n    ESP_LOGI(TAG_SNTP, \"Time synchronized!\");\n}\n</code></pre> Next is the SNTP initialization function, which is also the core function of time synchronization. It is usually called when the system is initialized and the network is connected. Note that the time synchronization server address can be modified as needed. After the time synchronization is completed, ESP32 will set the local time at the bottom layer.</p> <pre><code>/**\n * @brief Initialize SNTP\n * @return None\n */\nvoid initialize_sntp(void)\n{\n    ESP_LOGI(TAG_SNTP, \"Initializing SNTP\");\n    sntp_setoperatingmode(SNTP_OPMODE_POLL);\n    sntp_setservername(0, \"pool.ntp.org\"); // NTP server // pool.ntp.org // ntp.aliyun.com\n    sntp_set_time_sync_notification_cb(time_sync_notification_cb);\n    sntp_init();\n}\n</code></pre> <p>Next is a further encapsulation of the above functions, including time zone settings. Note that the following function includes the RTC setting <code>rtc_set_time</code>, which depends on the RTC driver at the driver layer. Here I use my custom rtc driver, if there is no related function, you can comment it out directly.</p> <pre><code>/**\n * @brief Obtain the current time with timezone\n * @param timezone_str Timezone string (e.g., \"CST-8\")\n * @note The timezone string should be in the format \"TZ=GMT+/-HH:MM\"\n * @note To use this function, in application, after internet connection, insert \"sync_time_with_timezone(\"CST-8\");\" will do\n * @return None\n */\nvoid sync_time_with_timezone(const char *timezone_str)\n{\n    // Set system timezone\n    setenv(\"TZ\", timezone_str, 1);\n    tzset();\n\n    // Initialize SNTP and start time sync\n    initialize_sntp();\n\n    // Wait for system time to be set\n    time_t now = 0;\n    struct tm timeinfo = { 0 };\n    int retry = 0;\n    const int retry_count = 15;\n\n    while (timeinfo.tm_year &lt; (2020 - 1900) &amp;&amp; ++retry &lt; retry_count) {\n        ESP_LOGI(TAG_SNTP, \"Waiting for system time to be set... (%d/%d)\", retry, retry_count);\n        vTaskDelay(2000 / portTICK_PERIOD_MS);\n        time(&amp;now);\n        localtime_r(&amp;now, &amp;timeinfo);\n    }\n\n    if (timeinfo.tm_year &gt;= (2020 - 1900)) {\n        rtc_set_time(timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday,\n                    timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec); // defined in esp_rtc.c\n        ESP_LOGI(TAG_SNTP, \"System time is set.\");\n    } else {\n        ESP_LOGW(TAG_SNTP, \"Failed to sync time.\");\n        return;\n    }\n\n    // Log current local time\n    ESP_LOGI(TAG_SNTP, \"Current time: %s\", asctime(&amp;timeinfo));\n\n    // vTaskDelay(10000 / portTICK_PERIOD_MS); // Wait for 10 second\n    // rtc_get_time(); // uncomment to check the RTC time\n    // ESP_LOGI(TAG_SNTP, \"Current RTC time: %04d-%02d-%02d %02d:%02d:%02d\",\n    //          calendar.year, calendar.month, calendar.date,\n    //          calendar.hour, calendar.min, calendar.sec); // uncomment to check the RTC time\n\n}\n</code></pre>"},{"location":"TOOLBOX/TIME/notes/#world-time-getting","title":"WORLD TIME GETTING","text":"<p>In order to facilitate the acquisition of world time, we first define a data structure <code>DateTime_t</code> to store information such as year, month, day, hour, minute, and second. Then we define a function <code>tiny_get_current_time</code> to obtain the current world time. This function returns a <code>DateTime_t</code> structure, which contains the current year, month, day, hour, minute, and second information. When using it, pass in a Boolean value <code>print_flag</code> to control whether to print the current time.</p> <pre><code>/**\n * @brief Structure to hold date and time\n */\ntypedef struct TinyDateTime_t\n{\n    int year;\n    int month;\n    int day;\n    int hour;\n    int minute;\n    int second;\n    long microsecond;\n} TinyDateTime_t; \n</code></pre> <pre><code>/* WORLD CURRENT TIME - GET TIME */\n/**\n * @name tiny_get_current_time\n * @brief Get the current time as a TinyDateTime_t struct\n * @param print_flag Flag to indicate whether to print the time\n * @return TinyDateTime_t structure containing the current date and time\n */\nTinyDateTime_t tiny_get_current_time(bool print_flag)\n{\n    struct timeval tv;\n    gettimeofday(&amp;tv, NULL);  // Get current time (seconds + microseconds)\n\n    time_t now = tv.tv_sec;\n    struct tm timeinfo;\n    localtime_r(&amp;now, &amp;timeinfo);  // Convert to local time\n\n    TinyDateTime_t result;\n    result.year   = timeinfo.tm_year + 1900;\n    result.month  = timeinfo.tm_mon + 1;\n    result.day    = timeinfo.tm_mday;\n    result.hour   = timeinfo.tm_hour;\n    result.minute = timeinfo.tm_min;\n    result.second = timeinfo.tm_sec;\n    result.microsecond = tv.tv_usec;\n\n    if (print_flag)\n    {\n        ESP_LOGI(TAG_TIME, \"Current Time: %04d-%02d-%02d %02d:%02d:%02d.%06ld\",\n                 result.year, result.month, result.day,\n                 result.hour, result.minute, result.second, tv.tv_usec);\n    }\n\n    return result;\n}\n</code></pre> <p>Usage</p> <pre><code>void app_main(void)\n{\n    // Initialize SNTP and sync time\n    sync_time_with_timezone(\"CST-8\");\n\n    // Get current time\n    TinyDateTime_t current_time = tiny_get_current_time(true);\n\n    // Print current time\n    ESP_LOGI(TAG_TIME, \"Current Time: %04d-%02d-%02d %02d:%02d:%02d.%06ld\",\n             current_time.year, current_time.month, current_time.day,\n             current_time.hour, current_time.minute, current_time.second, current_time.microsecond);\n}\n</code></pre> <p>Example Output</p> <p></p> <p>Danger</p> <p>The SNTP accuracy is at ms level.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"zh/","title":"TinySHM\uff1a\u9762\u5411\u5fae\u63a7\u5236\u5668\u7684\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u5206\u5e03\u5f0f\u667a\u80fd\u8d4b\u80fd\u6846\u67b6","text":""},{"location":"zh/#_1","title":"\u5173\u4e8e\u672c\u9879\u76ee","text":"<p>\u8be5\u9879\u76ee\u65e8\u5728\u5f00\u53d1\u4e00\u4e2a\u8d4b\u80fd\u6846\u67b6\uff0c\u4f7fMCU\u7ea7\u522b\u7684\u7269\u8054\u7f51\u8bbe\u5907\u5177\u5907\u5206\u5e03\u5f0f\u8ba1\u7b97\u548c\u667a\u80fd\u80fd\u529b\uff0c\u4ece\u800c\u63d0\u5347\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u5e94\u7528\u7684\u6548\u679c\u3002\u5982\u679c\u4f60\u5bf9\u8fd9\u4e2a\u9879\u76ee\u611f\u5174\u8da3\uff0c\u8bf7\u7ed9\u4e2a\u661f\u5e76\u4fdd\u6301\u5173\u6ce8\u3002</p> <p>TinySHM</p> <p>\"TinySHM\" \u662f \"Tiny\" \u548c \"SHM\" \u7684\u7ec4\u5408\u3002\"Tiny\" \u610f\u5473\u7740\u4ee3\u7801\u88ab\u8bbe\u8ba1\u4e3a\u8fd0\u884c\u5728 MCU \u8bbe\u5907\u4e0a\uff0c\u800c \"SHM\" \u662f \"Structural Health Monitoring\" \u7684\u7f29\u5199\u3002</p>"},{"location":"zh/#_2","title":"\u76ee\u6807\u786c\u4ef6","text":"<ul> <li>MCU \u8bbe\u5907\uff08\u4ee5 ESP32 \u4e3a\u4e3b\u8981\u76ee\u6807\uff09</li> </ul>"},{"location":"zh/#_3","title":"\u8303\u56f4","text":"<ul> <li>\u5e73\u53f0\u9002\u914d\u4e0e\u5404\u7c7b\u5404\u7c7b\u5de5\u5177\uff08\u65f6\u95f4\u3001\u901a\u8baf\u7b49\uff09</li> <li>\u57fa\u672c\u6570\u5b66\u8fd0\u7b97</li> <li>\u6570\u5b57\u4fe1\u53f7\u5904\u7406</li> <li>TinyML / \u8fb9\u7f18\u4eba\u5de5\u667a\u80fd</li> <li>\u6d4b\u91cf</li> <li>\u7cfb\u7edf\u8bc6\u522b</li> <li>\u635f\u4f24\u76d1\u6d4b\u3001\u5b9a\u4f4d\u3001\u8bc4\u4f30</li> </ul>"},{"location":"zh/ABOUT/about/","title":"TinySHM\uff1a\u9762\u5411\u5fae\u63a7\u5236\u5668\u7684\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u5206\u5e03\u5f0f\u667a\u80fd\u8d4b\u80fd\u6846\u67b6","text":""},{"location":"zh/ABOUT/about/#_1","title":"\u9879\u76ee\u6982\u8ff0","text":"<p>\u8be5\u9879\u76ee\u65e8\u5728\u5f00\u53d1\u4e00\u4e2a\u8d4b\u80fd\u6846\u67b6\uff0c\u4f7fMCU\u7ea7\u522b\u7684\u7269\u8054\u7f51\u8bbe\u5907\u5177\u5907\u5206\u5e03\u5f0f\u8ba1\u7b97\u548c\u667a\u80fd\u80fd\u529b\uff0c\u4ece\u800c\u63d0\u5347\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u5e94\u7528\u7684\u6548\u679c\u3002\u5982\u679c\u4f60\u5bf9\u8fd9\u4e2a\u9879\u76ee\u611f\u5174\u8da3\uff0c\u8bf7\u7ed9\u4e2a\u661f\u5e76\u4fdd\u6301\u5173\u6ce8\u3002</p> <p>TinySHM</p> <p>\"TinySHM\" \u662f \"Tiny\" \u548c \"SHM\" \u7684\u7ec4\u5408\u3002\"Tiny\" \u610f\u5473\u7740\u4ee3\u7801\u88ab\u8bbe\u8ba1\u4e3a\u8fd0\u884c\u5728 MCU \u8bbe\u5907\u4e0a\uff0c\u800c \"SHM\" \u662f \"Structural Health Monitoring\" \u7684\u7f29\u5199\u3002</p>"},{"location":"zh/ABOUT/about/#_2","title":"\u76ee\u6807\u786c\u4ef6","text":"<ul> <li>MCU \u8bbe\u5907\uff08\u76ee\u524d\u4ee5 ESP32 \u4e3a\u4e3b\u8981\u76ee\u6807\uff09</li> </ul>"},{"location":"zh/ABOUT/about/#_3","title":"\u8986\u76d6\u8303\u56f4","text":"<ul> <li>\u5e73\u53f0\u9002\u914d\u4e0e\u5404\u7c7b\u5404\u7c7b\u5de5\u5177\uff08\u65f6\u95f4\u3001\u901a\u8baf\u7b49\uff09</li> <li>\u57fa\u672c\u6570\u5b66\u8fd0\u7b97</li> <li>\u6570\u5b57\u4fe1\u53f7\u5904\u7406</li> <li>TinyML / \u8fb9\u7f18\u4eba\u5de5\u667a\u80fd</li> <li>\u6d4b\u91cf</li> <li>\u7cfb\u7edf\u8bc6\u522b</li> <li>\u635f\u4f24\u76d1\u6d4b\u3001\u5b9a\u4f4d\u3001\u8bc4\u4f30</li> </ul>"},{"location":"zh/ABOUT/about/#_4","title":"\u5f00\u53d1\u8f7d\u4f53","text":"<p>Tip</p> <p>\u4ee5\u4e0b\u786c\u4ef6\u4ec5\u505a\u5c55\u793a\u7528\u9014\uff0c\u672c\u9879\u76ee\u5e76\u4e0d\u5c40\u9650\u4e8e\u6b64\uff0c\u53ef\u4ee5\u79fb\u690d\u5230\u5176\u4ed6\u7c7b\u578b\u7684\u786c\u4ef6\u4e0a\u3002</p> <ul> <li>Alientek \u7684 DNESP32S3M\uff08ESP32-S3\uff09</li> </ul> <p></p> <p></p> <ul> <li> <p> NexNode</p> <p>  \u4ee3\u7801 </p> <p>  \u6587\u6863 </p> </li> </ul>"},{"location":"zh/ABOUT/about/#_5","title":"\u9879\u76ee\u67b6\u6784","text":"<pre><code>+------------------------------+\n| \u5e94\u7528\u5c42                        |\n|   - measurement              | &lt;-- \u6d4b\u91cf\n|   - system_identification    | &lt;-- \u7cfb\u7edf\u8bc6\u522b\n|   - damage_detection         | &lt;-- \u635f\u4f24\u68c0\u6d4b,\u5b9a\u4f4d\u548c\u8bc4\u4f30\n+------------------------------+\n| \u4e2d\u95f4\u4ef6                        |\n|   - TinyToolbox              | &lt;-- \u5e73\u53f0\u5e95\u5c42\u4f18\u5316 + \u5404\u79cd\u5de5\u5177\n|   - TinyMath                 | &lt;-- \u5e38\u7528\u6570\u5b66\u51fd\u6570\n|   - TinyDSP                  | &lt;-- DSP \u51fd\u6570\n|   - TinyAI                   | &lt;-- AI \u51fd\u6570\n+------------------------------+\n| \u9a71\u52a8\u5c42                        |\n+------------------------------+\n| \u786c\u4ef6\u5c42                        |\n+------------------------------+\n</code></pre>"},{"location":"zh/AI/ai/","title":"\u4eba\u5de5\u667a\u80fd","text":"<ul> <li> <p> ESP-DL</p> <p>  \u5728\u7ebf\u6587\u6863 </p> </li> </ul>"},{"location":"zh/DSP/dsp/","title":"\u6570\u5b57\u4fe1\u53f7\u5904\u7406","text":""},{"location":"zh/MATH/math/","title":"\u6570\u5b66\u8fd0\u7b97","text":"<p>Note</p> <p>\u8be5\u7ec4\u4ef6\u7528\u4e8e \u6570\u5b66\u8fd0\u7b97 \uff0c\u662f\u4e00\u4e2a\u8f7b\u91cf\u7ea7\u7684\u5e93\uff0c\u63d0\u4f9b\u57fa\u672c\u7684\u6570\u5b66\u51fd\u6570\uff0c\u4ee5\u4fbf\u4e8e\u677f\u8f7d\u8ba1\u7b97\u548cAI\u6a21\u578b\u63a8\u7406\u3002\u8be5\u5e93\u8bbe\u8ba1\u4e3a \u8f7b\u91cf\u9ad8\u6548 \uff0c\u9002\u5408\u8fb9\u7f18\u8ba1\u7b97\u5e94\u7528\u3002</p> <p>Note</p> <p>\u8be5\u7ec4\u4ef6\u57fa\u4e8eESP32\u5b98\u65b9\u6570\u5b57\u4fe1\u53f7\u5904\u7406\u5e93 ESP-DSP \u8fdb\u884c\u5c01\u88c5\u548c\u6269\u5c55\uff0c\u63d0\u4f9b\u4e86\u66f4\u9ad8\u5c42\u6b21\u7684API\u63a5\u53e3\u3002\u7b80\u5355\u6765\u8bf4\uff0cTinyMath\u5e93\u5bf9\u5e94ESP-DSP\u4e2d\u7684Math, Matrix, DotProduct\u6a21\u5757\uff0cESP-DSP\u4e2d\u7684\u5176\u4f59\u6a21\u5757\u5bf9\u5e94TinyDSP\u5e93\u3002</p>"},{"location":"zh/MATH/math/#_2","title":"\u7ec4\u4ef6\u4f9d\u8d56","text":"<pre><code>set(src_dirs\n    .\n    vec\n    mat\n)\n\nset(include_dirs\n    .\n    include\n    vec\n    mat\n)\n\nset(requires\n    tiny_toolbox\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"zh/MATH/math/#_3","title":"\u67b6\u6784\u4e0e\u529f\u80fd\u76ee\u5f55","text":""},{"location":"zh/MATH/math/#_4","title":"\u4f9d\u8d56\u5173\u7cfb\u793a\u610f\u56fe","text":""},{"location":"zh/MATH/math/#_5","title":"\u4ee3\u7801\u6811","text":"<pre><code>TinyMath\n    \u251c\u2500\u2500 CMakeLists.txt\n    \u251c\u2500\u2500 include\n    |   \u251c\u2500\u2500 tiny_error_type.h // error type header file\n    |   \u251c\u2500\u2500 tiny_constant.h // constant header file\n    |   \u251c\u2500\u2500 tiny_math_config.h // configuration header file\n    |   \u2514\u2500\u2500 tiny_math.h // main header file, include this file where you want to use the library\n    \u251c\u2500\u2500 vec\n    |   \u251c\u2500\u2500 tiny_vec.h // vector header file\n    |   \u251c\u2500\u2500 tiny_vec.c // vector source file\n    |   \u251c\u2500\u2500 tiny_vec_test.c // vector test file\n    |   \u2514\u2500\u2500 tiny_vec_test.h // vector test header file\n    \u251c\u2500\u2500 mat\n    |   \u251c\u2500\u2500 tiny_mat.h // matrix header file - c\n    |   \u251c\u2500\u2500 tiny_mat.c // matrix source file - c\n    |   \u251c\u2500\u2500 tiny_mat_test.c // matrix test file - c \n    |   \u251c\u2500\u2500 tiny_mat_test.h // matrix test header file - c\n    |   \u251c\u2500\u2500 tiny_matrix.hpp // matrix header file - cpp\n    |   \u251c\u2500\u2500 tiny_matrix.cpp // matrix source file - cpp\n    |   \u251c\u2500\u2500 tiny_matrix_test.cpp // matrix test file - cpp\n    |   \u2514\u2500\u2500 tiny_matrix_test.hpp // matrix test header file - cpp\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/","title":"ESP-DSP \u6570\u5b57\u4fe1\u53f7\u5904\u7406\u5e93","text":"<ul> <li> <p> ESP-DSP</p> <p>\u4e00\u4e2a Espressif DSP \u5e93 (esp-dsp)\uff0c\u5b83\u662f\u4e00\u4e2a\u51fd\u6570\u3001\u6a21\u5757\u548c\u7ec4\u4ef6\u7684\u5e93\uff0c\u63d0\u4f9b\u4e86\u4ee5\u9ad8\u6548\u7684\u65b9\u5f0f\u4f7f\u7528 Espressif \u7684 CPU \u4f5c\u4e3a DSP \u7684\u53ef\u80fd\u6027\u3002</p> <p>  \u5728\u7ebf\u6587\u6863 </p> </li> </ul>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_1","title":"\u51fd\u6570\u547d\u540d","text":"<p>\u547d\u540d\u7ea6\u5b9a\u9002\u7528\u4e8e\u6240\u6709\u8986\u76d6\u7684\u9886\u57df\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7 dsps \u524d\u7f00\u533a\u5206\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0c\u800c\u56fe\u50cf\u548c\u89c6\u9891\u5904\u7406\u51fd\u6570\u5177\u6709 dspi \u524d\u7f00\uff0c\u7279\u5b9a\u4e8e\u5c0f\u77e9\u9635\u64cd\u4f5c\u7684\u51fd\u6570\u5728\u5176\u540d\u79f0\u4e2d\u5177\u6709 dspm \u524d\u7f00\u3002\u5e93\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u5177\u6709\u4ee5\u4e0b\u901a\u7528\u683c\u5f0f\uff1a</p> <pre><code>dsp&lt;data-domain&gt;_&lt;name&gt;_&lt;datatype1&gt;&lt;datatype_ext&gt;_&lt;datatype2&gt;&lt;datatype_ext&gt;[_&lt;descriptor&gt;]&lt;_impl&gt;(&lt;parameters&gt;);\n</code></pre> <p>\u5176\u4e2d\uff1a</p> <ul> <li> <p><code>&lt;data-domain&gt;</code> \u662f\u51fd\u6570\u7684\u57df\uff0c\u4f8b\u5982 <code>s</code> \u8868\u793a\u4fe1\u53f7\u5904\u7406\uff0c<code>i</code> \u8868\u793a\u56fe\u50cf\u5904\u7406\uff0c<code>v</code> \u8868\u793a\u89c6\u9891\u5904\u7406\uff0c<code>m</code> \u8868\u793a\u5c0f\u77e9\u9635\u64cd\u4f5c\u3002</p> </li> <li> <p><code>&lt;name&gt;</code> \u662f\u51fd\u6570\u7684\u540d\u79f0\u3002</p> </li> <li> <p><code>&lt;datatype1&gt;</code> \u662f\u7b2c\u4e00\u4e2a\u8f93\u5165\u53c2\u6570\u7684\u7c7b\u578b\u3002</p> </li> <li> <p><code>&lt;datatype_ext&gt;</code> \u662f\u7b2c\u4e00\u4e2a\u8f93\u5165\u53c2\u6570\u7684\u7c7b\u578b\uff0c\u540e\u7f00\u8868\u793a\u6570\u636e\u7684\u7c7b\u578b\uff0c\u4f8b\u5982 <code>f</code> \u8868\u793a\u6d6e\u70b9\u6570\uff0c<code>i</code> \u8868\u793a\u6574\u6570\uff0c<code>c</code> \u8868\u793a\u590d\u6570\u7b49\u3002</p> </li> <li> <p><code>&lt;datatype2&gt;</code> \u662f\u7b2c\u4e8c\u4e2a\u8f93\u5165\u53c2\u6570\u7684\u7c7b\u578b\u3002</p> </li> <li> <p><code>&lt;descriptor&gt;</code> \u662f\u4e00\u4e2a\u53ef\u9009\u63cf\u8ff0\u7b26\uff0c\u63d0\u4f9b\u6709\u5173\u51fd\u6570\u7684\u9644\u52a0\u4fe1\u606f\u3002</p> </li> <li> <p><code>&lt;impl&gt;</code> \u662f\u4e00\u4e2a\u53ef\u9009\u5b9e\u73b0\u63cf\u8ff0\u7b26\uff0c\u63d0\u4f9b\u6709\u5173\u51fd\u6570\u5b9e\u73b0\u7684\u9644\u52a0\u4fe1\u606f\u3002</p> </li> <li> <p><code>&lt;parameters&gt;</code> \u662f\u51fd\u6570\u7684\u53c2\u6570\u3002</p> </li> </ul>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_2","title":"\u6570\u636e\u57df","text":"<p>\u6570\u636e\u57df\u662f\u4e00\u4e2a\u5355\u5b57\u7b26\uff0c\u8868\u793a\u7ed9\u5b9a\u51fd\u6570\u6240\u5c5e\u7684\u529f\u80fd\u5b50\u96c6\u3002\u5e93\u8bbe\u8ba1\u4e3a\u652f\u6301\u4ee5\u4e0b\u6570\u636e\u57df\uff1a</p> <ul> <li> <p>s - \u4fe1\u53f7\uff08\u9884\u671f\u6570\u636e\u7c7b\u578b\u4e3a 1D \u4fe1\u53f7\uff09</p> </li> <li> <p>i - \u56fe\u50cf\u548c\u89c6\u9891\uff08\u9884\u671f\u6570\u636e\u7c7b\u578b\u4e3a 2D \u56fe\u50cf\uff09</p> </li> <li> <p>m - \u77e9\u9635\uff08\u9884\u671f\u6570\u636e\u7c7b\u578b\u4e3a\u77e9\u9635\uff09</p> </li> <li> <p>r - \u903c\u771f\u6e32\u67d3\u529f\u80fd\u548c 3D \u6570\u636e\u5904\u7406\uff08\u9884\u671f\u6570\u636e\u7c7b\u578b\u53d6\u51b3\u4e8e\u652f\u6301\u7684\u6e32\u67d3\u6280\u672f\uff09</p> </li> <li> <p>q - \u56fa\u5b9a\u957f\u5ea6\u4fe1\u53f7</p> </li> </ul> <p>\u4f8b\u5982\uff0c\u4ee5 dspi \u5f00\u5934\u7684\u51fd\u6570\u540d\u79f0\u8868\u793a\u76f8\u5e94\u7684\u51fd\u6570\u7528\u4e8e\u56fe\u50cf\u6216\u89c6\u9891\u5904\u7406\u3002</p>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_3","title":"\u540d\u79f0","text":"<p>\u51fd\u6570\u540d\u79f0\u662f\u51fd\u6570\u5b9e\u9645\u6267\u884c\u7684\u6838\u5fc3\u64cd\u4f5c\u7684\u7f29\u5199\uff0c\u4f8b\u5982 Add\u3001Sqrt\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u4f1a\u540e\u8ddf\u51fd\u6570\u7279\u5b9a\u7684\u4fee\u9970\u7b26\uff1a= [_modifier]</p> <p>\u5982\u679c\u5b58\u5728\u6b64\u4fee\u9970\u7b26\uff0c\u5219\u8868\u793a\u5bf9\u7ed9\u5b9a\u51fd\u6570\u8fdb\u884c\u4e86\u7ec6\u5fae\u7684\u4fee\u6539\u6216\u53d8\u4f53\u3002</p>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_4","title":"\u6570\u636e\u7c7b\u578b","text":"<p>\u8be5\u5e93\u652f\u6301\u4e24\u79cd\u4e3b\u8981\u6570\u636e\u7c7b\u578b\uff1a\u7528\u4e8e\u5b9a\u70b9\u8fd0\u7b97\u7684 int16 \u548c\u7528\u4e8e\u6d6e\u70b9\u8fd0\u7b97\u7684 float\u3002\u6570\u636e\u7c7b\u578b\u63cf\u8ff0\u5982\u4e0b\uff1a</p>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_5","title":"\u6570\u636e\u7c7b\u578b\u540e\u7f00","text":"<ul> <li> <p>s - \u6709\u7b26\u53f7</p> </li> <li> <p>u - \u65e0\u7b26\u53f7</p> </li> <li> <p>f - \u6d6e\u70b9\u6570</p> </li> </ul>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_6","title":"\u6570\u636e\u7c7b\u578b\u6269\u5c55","text":"<ul> <li>c - \u590d\u6570</li> </ul>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_7","title":"\u6570\u636e\u7c7b\u578b\u6bd4\u7279\u5206\u8fa8\u7387","text":"<ul> <li> <p>16</p> </li> <li> <p>32</p> </li> </ul> <p>\u4f8b\u5982\uff1adsps_mac_sc16 \u5b9a\u4e49\u5c06\u4f7f\u7528 16 \u4f4d\u6709\u7b26\u53f7\u590d\u6570\u6570\u636e\u5bf9 1d \u6570\u7ec4\u8fdb\u884c m\u200b\u200bac \u8fd0\u7b97\u3002</p>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_8","title":"\u5b9e\u73b0\u65b9\u5f0f\u7c7b\u578b","text":"<p>\u6bcf\u4e2a\u51fd\u6570\u53ef\u4ee5\u9488\u5bf9\u4e0d\u540c\u7684\u5e73\u53f0\u8fdb\u884c\u4e0d\u540c\u7684\u5b9e\u73b0\uff0c\u5e76\u4e14\u53ef\u4ee5\u4f7f\u7528\u4e0d\u540c\u7684\u6837\u5f0f\u548c\u8d44\u6e90\u3002\u56e0\u6b64\uff0c\u6bcf\u4e2a\u5b9e\u73b0\u7684\u51fd\u6570\u90fd\u4f1a\u6709\u4e00\u4e2a\u6269\u5c55\u540d &lt;_impl&gt;\uff0c\u7528\u4e8e\u5b9a\u4e49\u5176\u5b9e\u73b0\u7c7b\u578b\u3002\u7528\u6237\u65e0\u9700\u6269\u5c55\u540d\u5373\u53ef\u4f7f\u7528\u901a\u7528\u51fd\u6570\u3002</p>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_9","title":"\u5b9e\u73b0\u65b9\u5f0f\u7c7b\u578b\u540e\u7f00","text":"<p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6240\u6709\u51fd\u6570\u65e0\u9700\u6269\u5c55\u5373\u53ef\u4f7f\u7528\u3002\u60a8\u53ef\u4ee5\u5728 menuconfig \u4e2d\u9009\u62e9\u201coptimized/ansi\u201d\u9009\u9879\u3002</p> <p>\u5e93\u4e2d\u7684\u6269\u5c55\u5305\u62ec\uff1a</p> <ul> <li> <p>_ansi - \u901a\u7528\u51fd\u6570\uff0c\u5176\u51fd\u6570\u4f53\u4f7f\u7528 ANSI C \u5b9e\u73b0\u3002\u6b64\u5b9e\u73b0\u4e0d\u5305\u542b\u4efb\u4f55\u786c\u4ef6\u4f18\u5316\u3002</p> </li> <li> <p>_ae32 - \u4f7f\u7528 ESP32 \u6c47\u7f16\u5668\u7f16\u5199\uff0c\u5e76\u9488\u5bf9 ESP32 \u8fdb\u884c\u4e86\u4f18\u5316\u3002</p> </li> <li> <p>_aes3 - \u4f7f\u7528 ESP32S3 \u6c47\u7f16\u5668\u7f16\u5199\uff0c\u5e76\u9488\u5bf9 ESP32S3 \u8fdb\u884c\u4e86\u4f18\u5316\u3002</p> </li> <li> <p>_arp4 - \u4f7f\u7528 ESP32P4 \u6c47\u7f16\u5668\u7f16\u5199\uff0c\u5e76\u9488\u5bf9 ESP32P4 \u8fdb\u884c\u4e86\u4f18\u5316\u3002</p> </li> <li> <p>_platform - \u5934\u6587\u4ef6\uff0c\u5176\u4e2d\u5305\u542b\u9488\u5bf9\u4e0d\u540c\u51fd\u6570\u7684\u53ef\u7528 CPU \u6307\u4ee4\u5b9a\u4e49\u3002</p> </li> <li> <p>\u5176\u4ed6 - \u53d6\u51b3\u4e8e\u652f\u6301\u7684 CPU \u6570\u91cf\u3002\u6b64\u5217\u8868\u672a\u6765\u5c06\u4e0d\u65ad\u6269\u5c55\u3002</p> </li> </ul>"},{"location":"zh/MATH/ESP-DSP/examples/","title":"ESP-DSP \u6848\u4f8b","text":""},{"location":"zh/MATH/ESP-DSP/examples/#esp-dsp_1","title":"esp-dsp \u793a\u4f8b\u5217\u8868","text":"<p>\u4fe1\u53f7\u5904\u7406 API \u4f7f\u7528 dsps \u524d\u7f00\u3002\u4ee5\u4e0b\u6a21\u5757\u53ef\u7528\uff1a</p> <ul> <li> <p>\u57fa\u7840\u6570\u5b66 - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528\u57fa\u672c\u5411\u91cf\u6570\u5b66\u8fd0\u7b97</p> </li> <li> <p>\u70b9\u79ef - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528\u70b9\u79ef\u51fd\u6570</p> </li> <li> <p>\u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362 - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528 FFT \u529f\u80fd</p> </li> <li> <p>\u7a97\u53e3 FFT - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528\u7a97\u53e3\u548c FFT \u529f\u80fd</p> </li> <li> <p>\u5b9e\u6570 FFT - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528 FFT \u529f\u80fd\u5904\u7406\u5b9e\u6570\u8f93\u5165\u4fe1\u53f7</p> </li> <li> <p>\u65e0\u9650\u8109\u51b2\u54cd\u5e94 (IIR) - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528 IIR \u6ee4\u6ce2\u5668\u529f\u80fd</p> </li> <li> <p>\u6709\u9650\u8109\u51b2\u54cd\u5e94 (FIR) - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528 FIR \u6ee4\u6ce2\u5668\u529f\u80fd</p> </li> <li> <p>\u5361\u5c14\u66fc\u6ee4\u6ce2\u5668 - \u6269\u5c55\u5361\u5c14\u66fc\u6ee4\u6ce2\u5668 (EKF) \u793a\u4f8b</p> </li> <li> <p>\u77e9\u9635 - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528 Mat \u7c7b\u529f\u80fd</p> </li> </ul>"},{"location":"zh/MATH/ESP-DSP/examples/#_1","title":"\u57fa\u7840\u6570\u5b66","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u4e86\u5982\u4f55\u4f7f\u7528 esp-dsp \u5e93\u4e2d\u7684\u57fa\u672c\u6570\u5b66\u51fd\u6570\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316\u5e93</p> </li> <li> <p>\u7528 1024 \u4e2a\u6837\u672c\u521d\u59cb\u5316\u8f93\u5165\u4fe1\u53f7</p> </li> <li> <p>\u4f7f\u7528\u6807\u51c6 C \u5faa\u73af\u5bf9\u8f93\u5165\u4fe1\u53f7\u52a0\u7a97\u3002</p> </li> <li> <p>\u8ba1\u7b97 1024 \u4e2a\u590d\u6570\u6837\u672c\u7684 FFT \u5e76\u663e\u793a\u7ed3\u679c</p> </li> <li> <p>\u5728\u56fe\u8868\u4e0a\u663e\u793a\u7ed3\u679c</p> </li> <li> <p>\u4f7f\u7528\u57fa\u672c\u6570\u5b66\u51fd\u6570 dsps_mul_f32 \u548c dsps_mulc_f32 \u5bf9\u8f93\u5165\u4fe1\u53f7\u52a0\u7a97\u3002</p> </li> <li> <p>\u8ba1\u7b97 1024 \u4e2a\u590d\u6570\u6837\u672c\u7684 FFT</p> </li> <li> <p>\u5728\u56fe\u8868\u4e0a\u663e\u793a\u7ed3\u679c</p> </li> </ul> <p>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 examples/basic_math/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#_2","title":"\u70b9\u79ef","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u4e86\u5982\u4f55\u4f7f\u7528 esp-dsp \u5e93\u4e2d\u7684 dotprod dsps_dotprod_f32 \u51fd\u6570\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316\u8f93\u5165\u6570\u7ec4</p> </li> <li> <p>\u8ba1\u7b97\u4e24\u4e2a\u6570\u7ec4\u7684\u70b9\u79ef</p> </li> <li> <p>\u6bd4\u8f83\u7ed3\u679c\u5e76\u8ba1\u7b97\u6267\u884c\u65f6\u95f4\uff08\u4ee5\u5468\u671f\u4e3a\u5355\u4f4d\uff09\u3002</p> </li> </ul> <p>\u66f4\u591a\u8be6\u60c5\uff0c\u8bf7\u53c2\u9605 examples/dotprod/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#fft","title":"FFT","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u4e86\u5982\u4f55\u4f7f\u7528 ESP-DSP \u5e93\u4e2d\u7684 FFT \u529f\u80fd\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316\u5e93</p> </li> <li> <p>\u7528 1024 \u4e2a\u6837\u672c\u521d\u59cb\u5316\u8f93\u5165\u4fe1\u53f7\uff1a\u7b2c\u4e00\u4e2a 0 dB\uff0c\u7b2c\u4e8c\u4e2a -20 dB</p> </li> <li> <p>\u5c06\u4e24\u4e2a\u4fe1\u53f7\u5408\u5e76\u4e3a\u4e00\u4e2a\u590d\u6570\u8f93\u5165\u4fe1\u53f7\uff0c\u5e76\u5bf9\u8f93\u5165\u4fe1\u53f7\u5bf9\u5e94\u7528\u7a97\u53e3\u3002</p> </li> <li> <p>\u8ba1\u7b97 1024 \u4e2a\u590d\u6570\u6837\u672c\u7684 FFT</p> </li> <li> <p>\u5bf9\u8f93\u51fa\u590d\u6570\u5411\u91cf\u5e94\u7528\u4f4d\u53cd\u8f6c\u64cd\u4f5c</p> </li> <li> <p>\u5c06\u4e00\u4e2a\u590d\u6570 FFT \u8f93\u51fa\u9891\u8c31\u62c6\u5206\u4e3a\u4e24\u4e2a\u5b9e\u6570\u4fe1\u53f7\u9891\u8c31</p> </li> <li> <p>\u5728\u56fe\u8868\u4e0a\u663e\u793a\u7ed3\u679c</p> </li> <li> <p>\u663e\u793a FFT \u7684\u6267\u884c\u65f6\u95f4</p> </li> </ul> <p>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 examples/fft/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#fft_1","title":"FFT \u7a97\u53e3","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u4e86\u5982\u4f55\u4f7f\u7528 esp-dsp \u5e93\u4e2d\u7684\u7a97\u53e3\u548c FFT \u529f\u80fd\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316\u5e93</p> </li> <li> <p>\u7528 1024 \u4e2a\u6837\u672c\u521d\u59cb\u5316\u8f93\u5165\u4fe1\u53f7</p> </li> <li> <p>\u5bf9\u8f93\u5165\u4fe1\u53f7\u5e94\u7528\u7a97\u53e3\u3002</p> </li> <li> <p>\u5bf9 1024 \u4e2a\u590d\u6570\u6837\u672c\u8ba1\u7b97 FFT</p> </li> <li> <p>\u5bf9\u8f93\u51fa\u590d\u6570\u5411\u91cf\u5e94\u7528\u4f4d\u53cd\u8f6c\u64cd\u4f5c</p> </li> <li> <p>\u5c06\u4e00\u4e2a\u590d\u6570 FFT \u8f93\u51fa\u9891\u8c31\u62c6\u5206\u4e3a\u4e24\u4e2a\u5b9e\u6570\u4fe1\u53f7\u9891\u8c31</p> </li> <li> <p>\u5728\u56fe\u8868\u4e0a\u663e\u793a\u7ed3\u679c</p> </li> </ul> <p>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 examples/fft_window/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#fft-4-real","title":"FFT 4 Real","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u4e86\u5982\u4f55\u4f7f\u7528 ESP-DSP \u5e93\u4e2d\u7684 FFT \u529f\u80fd\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316\u5e93</p> </li> <li> <p>\u7528 1024 \u4e2a\u6837\u672c\u521d\u59cb\u5316\u8f93\u5165\u4fe1\u53f7\uff1a\u7b2c\u4e00\u4e2a 0 dB\uff0c\u7b2c\u4e8c\u4e2a -20 dB</p> </li> <li> <p>\u8ba1\u7b97 1024 \u4e2a\u590d\u6570\u6837\u672c\u7684 FFT \u57fa\u6570 2</p> </li> <li> <p>\u8ba1\u7b97 1024 \u4e2a\u590d\u6570\u6837\u672c\u7684 FFT \u57fa\u6570 4</p> </li> <li> <p>\u5bf9\u8f93\u51fa\u590d\u6570\u5411\u91cf\u5e94\u7528\u4f4d\u53cd\u8f6c\u8fd0\u7b97</p> </li> <li> <p>\u7ed8\u56fe\u663e\u793a\u7ed3\u679c</p> </li> <li> <p>\u663e\u793a FFT \u6267\u884c\u65f6\u95f4</p> </li> </ul> <p>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 examples/fft4real/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#iir","title":"IIR","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u4e86\u5982\u4f55\u4f7f\u7528 ESP-DSP \u5e93\u4e2d\u7684 IIR \u6ee4\u6ce2\u5668\u529f\u80fd\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316\u5e93</p> </li> <li> <p>\u521d\u59cb\u5316\u8f93\u5165\u4fe1\u53f7</p> </li> <li> <p>\u663e\u793a Q \u56e0\u5b50\u4e3a 1 \u7684\u4f4e\u901a\u6ee4\u6ce2\u5668 (LPF)</p> </li> <li> <p>\u8ba1\u7b97 IIR \u6ee4\u6ce2\u5668\u7cfb\u6570</p> </li> <li> <p>\u6ee4\u6ce2\u8f93\u5165\u6d4b\u8bd5\u4fe1\u53f7\uff08Delta \u51fd\u6570\uff09</p> </li> <li> <p>\u5728\u56fe\u4e2d\u663e\u793a\u8109\u51b2\u54cd\u5e94</p> </li> <li> <p>\u5728\u56fe\u4e2d\u663e\u793a\u9891\u7387\u54cd\u5e94</p> </li> <li> <p>\u8ba1\u7b97\u6267\u884c\u6027\u80fd</p> </li> <li> <p>\u5bf9\u4e8e Q \u56e0\u5b50\u4e3a 10 \u7684\u4f4e\u901a\u6ee4\u6ce2\u5668\uff0c\u540c\u6837\u5982\u6b64</p> </li> </ul> <p>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 examples/fir/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#fir","title":"FIR","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u4e86\u5982\u4f55\u4f7f\u7528 ESP-DSP \u5e93\u4e2d\u7684 FIR \u6ee4\u6ce2\u5668\u529f\u80fd\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316 FFT \u5e93</p> </li> <li> <p>\u521d\u59cb\u5316\u8f93\u5165\u4fe1\u53f7</p> </li> <li> <p>\u663e\u793a\u8f93\u5165\u4fe1\u53f7</p> </li> <li> <p>\u663e\u793a\u6ee4\u6ce2\u540e\u7684\u4fe1\u53f7</p> </li> </ul> <p>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 examples/fir/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#_3","title":"\u5361\u5c14\u66fc\u6ee4\u6ce2\u5668","text":"<p>\u672c\u793a\u4f8b\u6a21\u62df\u4e86\u5e26\u6709 IMU \u4f20\u611f\u5668\u7684\u7cfb\u7edf\uff0c\u5e76\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528\u5177\u6709 13 \u4e2a\u72b6\u6001\u5411\u91cf\u7684\u6269\u5c55\u5361\u5c14\u66fc\u6ee4\u6ce2\u5668 (EKF) \u6765\u4f30\u8ba1\u9640\u87ba\u4eea\u8bef\u5dee\u5e76\u8ba1\u7b97\u7cfb\u7edf\u59ff\u6001\u3002\u6b64\u5916\uff0c\u672c\u793a\u4f8b\u8fd8\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528 esp-dsp \u5e93\u5bf9\u77e9\u9635\u548c\u5411\u91cf\u8fdb\u884c\u8fd0\u7b97\u3002</p> <p>\u5728\u5b9e\u9645\u7cfb\u7edf\u4e2d\uff0c\u5e94\u5c06\u6a21\u62df\u4f20\u611f\u5668\u503c\u66ff\u6362\u4e3a\u5b9e\u9645\u4f20\u611f\u5668\u503c\u3002\u7136\u540e\uff0c\u5728\u5b9e\u9645\u7cfb\u7edf\u4e2d\uff0c\u5e94\u6267\u884c\u6821\u51c6\u9636\u6bb5\u3002\u6821\u51c6\u9636\u6bb5\u7ed3\u675f\u540e\uff0c\u5e94\u4fdd\u5b58\u72b6\u6001\u5411\u91cf X \u548c\u534f\u65b9\u5dee\u77e9\u9635 P\uff0c\u5e76\u5728\u4e0b\u6b21\u8c03\u7528\u6ee4\u6ce2\u5668\u65f6\u6062\u590d\u3002\u8fd9\u5c06\u8282\u7701\u521d\u59cb\u9636\u6bb5\u7684\u65f6\u95f4\u3002</p> <p>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 examples/kalman/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#_4","title":"\u77e9\u9635","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528 esp-dsp \u5e93\u4e2d\u7684 Mat \u7c7b\u529f\u80fd\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316\u77e9\u9635 A \u548c \u77e9\u9635 x</p> </li> <li> <p>\u8ba1\u7b97\u77e9\u9635 b\uff1ab = A*x</p> </li> <li> <p>\u4f7f\u7528\u4e0d\u540c\u65b9\u6cd5\u6c42 x1 \u7684\u6839\uff1aA*x1 = b</p> </li> <li> <p>\u6253\u5370\u7ed3\u679c</p> </li> </ul>"},{"location":"zh/MATH/HEADER-FILE/tiny_constants/","title":"\u5e38\u91cf\u5b9a\u4e49","text":"<p>Info</p> <p>\u8be5\u6587\u4ef6\u5305\u542b\u4e86\u4e00\u4e9b\u5e38\u91cf\u7684\u5b9a\u4e49\u7528\u4e8e\u4e0a\u5c42\u8ba1\u7b97\u548c\u5e94\u7528\u3002\u6587\u6863\u66f4\u65b0\u901f\u5ea6\u8f83\u6162\uff0c\u53ef\u80fd\u4e0e\u5b9e\u9645\u4ee3\u7801\u4e0d\u4e00\u81f4\uff0c\u8bf7\u4ee5\u4ee3\u7801\u4e3a\u51c6\u3002</p> <pre><code>/**\n * @file tiny_constants.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file contains the constants used in the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n */\n\n#ifndef __TINY_CONSTANTS_H__\n#define __TINY_CONSTANTS_H__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n// =======================================\n//  Logical Constants\n// =======================================\n#ifndef TRUE\n#define TRUE 1\n#endif\n\n#ifndef FALSE\n#define FALSE 0\n#endif\n\n#ifndef NULL\n#define NULL ((void *)0)\n#endif\n\n// =======================================\n//  Math Constants (float/double safe)\n// =======================================\n#define TINY_PI 3.14159265358979323846f\n#define TINY_TWO_PI 6.28318530717958647692f\n#define TINY_HALF_PI 1.57079632679489661923f\n#define TINY_E 2.71828182845904523536f\n#define TINY_SQRT2 1.41421356237309504880f\n#define TINY_INV_SQRT2 0.70710678118654752440f\n\n#define TINY_DEG2RAD(x) ((x) * TINY_PI / 180.0f)\n#define TINY_RAD2DEG(x) ((x) * 180.0f / TINY_PI)\n\n// =======================================\n//  Bitmask &amp; Bit Manipulation\n// =======================================\n\n// Bitwise operations\n#define TINY_BIT(n) (1U &lt;&lt; (n)) // e.g. TINY_BIT(3) = 0b00001000\n#define TINY_BIT_SET(x, n) ((x) |= TINY_BIT(n))\n#define TINY_BIT_CLEAR(x, n) ((x) &amp;= ~TINY_BIT(n))\n#define TINY_BIT_TOGGLE(x, n) ((x) ^= TINY_BIT(n))\n#define TINY_BIT_CHECK(x, n) (((x) &gt;&gt; (n)) &amp; 0x1U)\n\n// Common bit masks\n#define TINY_MASK_4BIT 0x0FU\n#define TINY_MASK_8BIT 0xFFU\n#define TINY_MASK_16BIT 0xFFFFU\n#define TINY_MASK_32BIT 0xFFFFFFFFU\n\n// =======================================\n//  Fixed-Point Scaling Factors\n// =======================================\n#define TINY_Q7_SCALE 128          // 2^7\n#define TINY_Q15_SCALE 32768       // 2^15\n#define TINY_Q31_SCALE 2147483648U // 2^31\n\n// =======================================\n//  User-Defined Constants (Optional)\n// =======================================\n#define TINY_MATH_MIN_DENOMINATOR 1e-6f // Minimum denominator for safe division\n#define TINY_MATH_MIN_POSITIVE_INPUT_F32 1e-12f // Minimum positive input for float operations\n\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_CONSTANTS_H__ */\n</code></pre>"},{"location":"zh/MATH/HEADER-FILE/tiny_error_type/","title":"\u9519\u8bef\u7c7b\u578b\u5b9a\u4e49","text":"<p>Info</p> <p>\u8be5\u6587\u4ef6\u5b9a\u4e49\u4e86\u4e00\u4e9b\u8ba1\u7b97\u4e2d\u5e38\u89c1\u7684\u9519\u8bef\u7c7b\u578b\uff0c\u7528\u4e8e\u8f85\u52a9\u5224\u65ad\u9519\u8bef\u539f\u56e0\u3002\u6587\u6863\u66f4\u65b0\u901f\u5ea6\u8f83\u6162\uff0c\u53ef\u80fd\u4e0e\u5b9e\u9645\u4ee3\u7801\u4e0d\u7b26\uff0c\u8bf7\u4ee5\u4ee3\u7801\u4e3a\u51c6\u3002</p> <pre><code>/**\n * @file tiny_error_type.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief The configuration file for the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_ERROR_TYPE__\n#define __TINY_ERROR_TYPE__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* TYPE DEFINITIONS */\ntypedef int tiny_error_t; // Error type for the tiny_math middleware\n\n/* MACROS */\n/* Definitions for error constants. */\n#define TINY_OK          0       /*!&lt; tiny_err_t value indicating success (no error) */\n#define TINY_FAIL        -1      /*!&lt; Generic tiny_err_t code indicating failure */\n\n#define TINY_ERR_NO_MEM              0x101   /*!&lt; Out of memory */\n#define TINY_ERR_INVALID_ARG         0x102   /*!&lt; Invalid argument */\n#define TINY_ERR_INVALID_STATE       0x103   /*!&lt; Invalid state */\n#define TINY_ERR_INVALID_SIZE        0x104   /*!&lt; Invalid size */\n#define TINY_ERR_NOT_FOUND           0x105   /*!&lt; Requested resource not found */\n#define TINY_ERR_NOT_SUPPORTED       0x106   /*!&lt; Operation or feature not supported */\n#define TINY_ERR_TIMEOUT             0x107   /*!&lt; Operation timed out */\n#define TINY_ERR_INVALID_RESPONSE    0x108   /*!&lt; Received response was invalid */\n#define TINY_ERR_INVALID_CRC         0x109   /*!&lt; CRC or checksum was invalid */\n#define TINY_ERR_INVALID_VERSION     0x10A   /*!&lt; Version was invalid */\n#define TINY_ERR_INVALID_MAC         0x10B   /*!&lt; MAC address was invalid */\n#define TINY_ERR_NOT_FINISHED        0x10C   /*!&lt; Operation has not fully completed */\n#define TINY_ERR_NOT_ALLOWED         0x10D   /*!&lt; Operation is not allowed */\n\n#define TINY_ERR_WIFI_BASE           0x3000  /*!&lt; Starting number of WiFi error codes */\n#define TINY_ERR_MESH_BASE           0x4000  /*!&lt; Starting number of MESH error codes */\n#define TINY_ERR_FLASH_BASE          0x6000  /*!&lt; Starting number of flash error codes */\n#define TINY_ERR_HW_CRYPTO_BASE      0xc000  /*!&lt; Starting number of HW cryptography module error codes */\n#define TINY_ERR_MEMPROT_BASE        0xd000  /*!&lt; Starting number of Memory Protection API error codes */\n\n#define TINY_ERR_MATH_BASE                0x70000\n#define TINY_ERR_MATH_INVALID_LENGTH      (TINY_ERR_MATH_BASE + 1)\n#define TINY_ERR_MATH_INVALID_PARAM       (TINY_ERR_MATH_BASE + 2)\n#define TINY_ERR_MATH_PARAM_OUTOFRANGE    (TINY_ERR_MATH_BASE + 3)\n#define TINY_ERR_MATH_UNINITIALIZED       (TINY_ERR_MATH_BASE + 4)\n#define TINY_ERR_MATH_REINITIALIZED       (TINY_ERR_MATH_BASE + 5)\n#define TINY_ERR_MATH_ARRAY_NOT_ALIGNED   (TINY_ERR_MATH_BASE + 6)\n#define TINY_ERR_MATH_NULL_POINTER        (TINY_ERR_MATH_BASE + 7)\n#define TINY_ERR_MATH_ZERO_DIVISION       (TINY_ERR_MATH_BASE + 8)\n#define TINY_ERR_MATH_NEGATIVE_SQRT        (TINY_ERR_MATH_BASE + 9)\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_ERROR_TYPE__ */\n</code></pre>"},{"location":"zh/MATH/HEADER-FILE/tiny_math/","title":"TinyMath\u5934\u6587\u4ef6","text":"<p>Info</p> <p>\u8fd9\u662fTinyMath\u5e93\u7684\u4e3b\u5934\u6587\u4ef6\u3002\u5b83\u5305\u542b\u6240\u6709\u5fc5\u8981\u7684\u5934\u6587\u4ef6\uff0c\u5e76\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7edf\u4e00\u7684\u63a5\u53e3\u6765\u4f7f\u7528\u5e93\u7684\u529f\u80fd\u3002\u5728\u9879\u76ee\u4e2d\u5b8c\u6210\u8be5\u5e93\u7684\u79fb\u690d\u540e\uff0c\u5728\u9700\u8981\u4f7f\u7528\u76f8\u5173\u51fd\u6570\u7684\u5730\u65b9\u63d2\u5165\u8be5\u5934\u6587\u4ef6\u5373\u53ef\u4f7f\u7528\u5e93\u5185\u7684\u6240\u6709\u51fd\u6570\u3002\u6587\u6863\u66f4\u65b0\u901f\u5ea6\u8f83\u6162\uff0c\u53ef\u80fd\u4e0e\u5b9e\u9645\u4ee3\u7801\u4e0d\u4e00\u81f4\uff0c\u8bf7\u4ee5\u5b9e\u9645\u4ee3\u7801\u4e3a\u51c6\u3002</p> <pre><code>/**\n * @file tiny_math.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the tiny_math middleware.\n * @version 1.0\n * @date 2025-03-26\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_MATH__\n#define __TINY_MATH__\n\n/* DEPENDENCIES */\n\n// this layer\n#include \"tiny_math_config.h\"\n\n/* SUBMODULES */\n\n// vector operations\n#include \"tiny_vec.h\"\n\n// matrix operations\n#include \"tiny_mat.h\"\n\n// advanced matrix operations\n#ifdef __cplusplus\n\n#include \"tiny_matrix.hpp\"\n\n#endif\n\n/* TEST */ // NOTE: test files are platform specific and should not be included in the library\n\n// vector operations\n#include \"tiny_vec_test.h\"\n\n// matrix operations\n#include \"tiny_mat_test.h\"\n\n// advanced matrix operations\n#ifdef __cplusplus\n\n#include \"tiny_matrix_test.hpp\"\n\n#endif\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_MATH__ */\n</code></pre>"},{"location":"zh/MATH/HEADER-FILE/tiny_math_config/","title":"TinyMath \u914d\u7f6e","text":"<p>Info</p> <p>\u8fd9\u4e2a\u5934\u6587\u4ef6\u8d77\u5230\u914d\u7f6e\u6574\u4e2aTinyMath\u6a21\u5757\u7684\u4f5c\u7528\uff0c\u6bcf\u4e2a\u5b50\u6a21\u5757\u90fd\u5305\u542b\u4e86\u6b64\u5934\u6587\u4ef6\u3002\u5b83\u5b9a\u4e49\u4e86TinyMath\u7684\u914d\u7f6e\u9009\u9879\u548c\u5b8f\uff0c\u5141\u8bb8\u7528\u6237\u6839\u636e\u9700\u8981\u8fdb\u884c\u81ea\u5b9a\u4e49\u8bbe\u7f6e\u3002\u901a\u8fc7\u4fee\u6539\u8fd9\u4e2a\u5934\u6587\u4ef6\u4e2d\u7684\u914d\u7f6e\u9009\u9879\uff0c\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u5730\u8c03\u6574TinyMath\u7684\u884c\u4e3a\u548c\u529f\u80fd\uff0c\u4ee5\u6ee1\u8db3\u7279\u5b9a\u7684\u9700\u6c42\u3002\u6587\u6863\u66f4\u65b0\u901f\u5ea6\u8f83\u6162\uff0c\u53ef\u80fd\u4f1a\u4e0e\u5b9e\u9645\u4ee3\u7801\u4e0d\u4e00\u81f4\uff0c\u8bf7\u4ee5\u4ee3\u7801\u4e3a\u51c6\u3002</p> <p>Tip</p> <p>\u8be5\u7ec4\u4ef6\u5185\u5305\u62ec\u9009\u62e9\u5e73\u53f0\u7684\u5b8f\u5b9a\u4e49\uff0c\u7528\u6237\u53ef\u4ee5\u6839\u636e\u9700\u8981\u9009\u62e9\u4e0d\u540c\u7684\u5e73\u53f0\u8fdb\u884c\u7f16\u8bd1\u3002\u5207\u6362\u5230\u5bf9\u5e94\u5e73\u53f0\u7684\u5b8f\u540e\uff0c\u53ef\u4ee5\u5229\u7528\u5e73\u53f0\u52a0\u901f\u7684\u7279\u6027\u6765\u63d0\u5347\u6027\u80fd\u3002\u4f8b\u5982\uff0c\u5bf9\u4e8eESP32\u5e73\u53f0\uff0cTinyMath\u4f1a\u81ea\u52a8\u9009\u62e9ESP32\u7684DSP\u5e93\u8fdb\u884c\u7f16\u8bd1\uff0c\u4ece\u800c\u5b9e\u73b0\u66f4\u9ad8\u6548\u7684\u6570\u5b66\u8fd0\u7b97\u3002</p> <pre><code>/**\n * @file tiny_math_config.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief The configuration file for the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-14\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_MATH_CONFIG__\n#define __TINY_MATH_CONFIG__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* DEPENDENCIES */\n\n// ANSI C\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdint.h&gt;\n\n// lower level\n#include \"tiny_toolbox.h\"\n\n// this level\n#include \"tiny_error_type.h\"\n#include \"tiny_constants.h\"\n\n/* PLATFORM SELECTION */\n\n// available platforms\n#define MCU_PLATFORM_GENERIC     0\n#define MCU_PLATFORM_ESP32       1 // here, we utilize the ESP built-in DSP library, it will automatically select the optimized version\n#define MCU_PLATFORM_STM32       2\n#define MCU_PLATFORM_RISCV       3\n\n// choose one platform\n#define MCU_PLATFORM_SELECTED    MCU_PLATFORM_ESP32\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_MATH_CONFIG__ */\n</code></pre>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/","title":"\u77e9\u9635\u64cd\u4f5c - TINY_MAT","text":"<p>\u5173\u4e8etiny_mat\u5e93</p> <p>tiny_mat\u662f\u4e00\u4e2aC\u8bed\u8a00\u5b9e\u73b0\u7684\u77e9\u9635\u5e93\uff0c\u63d0\u4f9b\u4e86\u57fa\u672c\u7684\u77e9\u9635\u64cd\u4f5c\u51fd\u6570\u3002\u5b83\u652f\u6301\u6d6e\u70b9\u6570\u77e9\u9635\u7684\u52a0\u6cd5\u3001\u51cf\u6cd5\u548c\u4e58\u6cd5\u7b49\u64cd\u4f5c\u3002\u8be5\u5e93\u9002\u7528\u4e8e\u9700\u8981\u8fdb\u884c\u77e9\u9635\u8ba1\u7b97\u7684\u5d4c\u5165\u5f0f\u7cfb\u7edf\u548c\u5b9e\u65f6\u5e94\u7528\u3002\u8be5\u5e93\u57fa\u4e8eANSIC C\u6807\u51c6\uff0c\u5177\u6709\u826f\u597d\u7684\u53ef\u79fb\u690d\u6027\u548c\u6027\u80fd,\u540c\u65f6\u53c8\u652f\u6301\u5728\u914d\u7f6e\u6587\u4ef6\u4e2d\u8fdb\u884c\u914d\u7f6e\u4ece\u800c\u652f\u6301\u5e73\u53f0\u52a0\u901f\uff08ESP32\uff09\u3002</p> <p>\u5173\u4e8etiny_mat\u5e93\u7684\u4f7f\u7528</p> <p>tiny_mat\u7684\u529f\u80fd\u88abtiny_matrix\u5b8c\u5168\u8986\u76d6\uff0c\u4e5f\u5c31\u662f\u8bf4\u5728tiny_matrix\u4e2d\u7684\u529f\u80fd\u5305\u542b\u4e86tiny_mat\u7684\u6240\u6709\u529f\u80fd\u3002\u5bf9\u4e8e\u7b80\u5355\u7684\u77e9\u9635\u64cd\u4f5c\uff0c\u53ef\u4ee5\u4ec5\u5f15\u5165tiny_mat\u5e93\uff1b\u5bf9\u4e8e\u590d\u6742\u7684\u77e9\u9635\u64cd\u4f5c\uff0c\u5efa\u8bae\u4f7f\u7528tiny_matrix\u5e93\u3002tiny_matrix\u5e93\u662f\u4e00\u4e2aC++\u5b9e\u73b0\u7684\u77e9\u9635\u5e93\uff0c\u63d0\u4f9b\u4e86\u66f4\u4e30\u5bcc\u7684\u529f\u80fd\u548c\u66f4\u597d\u7684\u6027\u80fd\u3002\u5b83\u652f\u6301\u6d6e\u70b9\u6570\u548c\u6574\u6570\u77e9\u9635\u7684\u52a0\u6cd5\u3001\u51cf\u6cd5\u3001\u4e58\u6cd5\u3001\u8f6c\u7f6e\u3001\u6c42\u9006\u7b49\u64cd\u4f5c\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_1","title":"\u76ee\u5f55","text":"<pre><code>TinyMath\n    \u251c\u2500\u2500Vector\n    \u2514\u2500\u2500Matrix\n        \u251c\u2500\u2500 tiny_mat (c) &lt;---\n        \u2514\u2500\u2500 tiny_matrix (c++)\n</code></pre> <pre><code>// print matrix\nvoid print_matrix(const char *name, const float *mat, int rows, int cols);\n// print matrix padded (row-major)\nvoid print_matrix_padded(const char *name, const float *mat, int rows, int cols, int step);\n// addition\ntiny_error_t tiny_mat_add_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\ntiny_error_t tiny_mat_addc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n// subtraction\ntiny_error_t tiny_mat_sub_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\ntiny_error_t tiny_mat_subc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n// multiplication\ntiny_error_t tiny_mat_mult_f32(const float *A, const float *B, float *C, int m, int n, int k);\ntiny_error_t tiny_mat_mult_ex_f32(const float *A, const float *B, float *C, int A_rows, int A_cols, int B_cols, int A_padding, int B_padding, int C_padding);\ntiny_error_t tiny_mat_multc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_2","title":"\u5de5\u5177\u51fd\u6570","text":""},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_3","title":"\u6253\u5370\u77e9\u9635","text":"<pre><code>void print_matrix(const char *name, const float *mat, int rows, int cols);\n</code></pre> <p>\u51fd\u6570: \u4ee5\u884c\u4e3b\u5e8f\u6253\u5370\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>name</code>: \u77e9\u9635\u540d\u79f0\u3002</p> </li> <li> <p><code>mat</code>: \u77e9\u9635\u6570\u636e\u6307\u9488\u3002</p> </li> <li> <p><code>rows</code>: \u77e9\u9635\u884c\u6570\u3002</p> </li> <li> <p><code>cols</code>: \u77e9\u9635\u5217\u6570\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u65e0\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_4","title":"\u6253\u5370\u5e26\u586b\u5145\u7684\u77e9\u9635","text":"<pre><code>void print_matrix_padded(const char *name, const float *mat, int rows, int cols, int step);\n</code></pre> <p>\u51fd\u6570: \u4ee5\u884c\u4e3b\u5e8f\u6253\u5370\u5e26\u586b\u5145\u7684\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>name</code>: \u77e9\u9635\u540d\u79f0\u3002</p> </li> <li> <p><code>mat</code>: \u77e9\u9635\u6570\u636e\u6307\u9488\u3002</p> </li> <li> <p><code>rows</code>: \u77e9\u9635\u884c\u6570\u3002</p> </li> <li> <p><code>cols</code>: \u77e9\u9635\u5217\u6570\u3002</p> </li> <li> <p><code>step</code>: \u6b65\u957f\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u65e0\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_5","title":"\u77e9\u9635\u52a0\u6cd5","text":"<pre><code>tiny_error_t tiny_mat_add_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\n</code></pre> <p>\u51fd\u6570: \u77e9\u9635\u52a0\u6cd5\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>input1</code>: \u8f93\u5165\u77e9\u96351\u3002</p> </li> <li> <p><code>input2</code>: \u8f93\u5165\u77e9\u96352\u3002</p> </li> <li> <p><code>output</code>: \u8f93\u51fa\u77e9\u9635\u3002</p> </li> <li> <p><code>rows</code>: \u77e9\u9635\u884c\u6570\u3002</p> </li> <li> <p><code>cols</code>: \u77e9\u9635\u5217\u6570\u3002</p> </li> <li> <p><code>padd1</code>: \u8f93\u5165\u77e9\u96351\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>padd2</code>: \u8f93\u5165\u77e9\u96352\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>padd_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>step1</code>: \u8f93\u5165\u77e9\u96351\u7684\u6b65\u957f\u3002</p> </li> <li> <p><code>step2</code>: \u8f93\u5165\u77e9\u96352\u7684\u6b65\u957f\u3002</p> </li> <li> <p><code>step_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u9519\u8bef\u7801\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_6","title":"\u77e9\u9635\u52a0\u5e38\u6570","text":"<pre><code>tiny_error_t tiny_mat_addc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre> <p>\u51fd\u6570: \u77e9\u9635\u52a0\u5e38\u6570\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>input</code>: \u8f93\u5165\u77e9\u9635\u3002</p> </li> <li> <p><code>output</code>: \u8f93\u51fa\u77e9\u9635\u3002</p> </li> <li> <p><code>C</code>: \u5e38\u6570\u3002</p> </li> <li> <p><code>rows</code>: \u77e9\u9635\u884c\u6570\u3002</p> </li> <li> <p><code>cols</code>: \u77e9\u9635\u5217\u6570\u3002</p> </li> <li> <p><code>padd_in</code>: \u8f93\u5165\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>padd_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>step_in</code>: \u8f93\u5165\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> <li> <p><code>step_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u9519\u8bef\u7801\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_7","title":"\u77e9\u9635\u51cf\u6cd5","text":"<pre><code>tiny_error_t tiny_mat_sub_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\n</code></pre> <p>\u51fd\u6570: \u77e9\u9635\u51cf\u6cd5\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>input1</code>: \u8f93\u5165\u77e9\u96351\u3002</p> </li> <li> <p><code>input2</code>: \u8f93\u5165\u77e9\u96352\u3002</p> </li> <li> <p><code>output</code>: \u8f93\u51fa\u77e9\u9635\u3002</p> </li> <li> <p><code>rows</code>: \u77e9\u9635\u884c\u6570\u3002</p> </li> <li> <p><code>cols</code>: \u77e9\u9635\u5217\u6570\u3002</p> </li> <li> <p><code>padd1</code>: \u8f93\u5165\u77e9\u96351\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>padd2</code>: \u8f93\u5165\u77e9\u96352\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>padd_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>step1</code>: \u8f93\u5165\u77e9\u96351\u7684\u6b65\u957f\u3002</p> </li> <li> <p><code>step2</code>: \u8f93\u5165\u77e9\u96352\u7684\u6b65\u957f\u3002</p> </li> <li> <p><code>step_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u9519\u8bef\u7801\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_8","title":"\u77e9\u9635\u51cf\u5e38\u6570","text":"<pre><code>tiny_error_t tiny_mat_subc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre> <p>\u51fd\u6570: \u77e9\u9635\u51cf\u5e38\u6570\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>input</code>: \u8f93\u5165\u77e9\u9635\u3002</p> </li> <li> <p><code>output</code>: \u8f93\u51fa\u77e9\u9635\u3002</p> </li> <li> <p><code>C</code>: \u5e38\u6570\u3002</p> </li> <li> <p><code>rows</code>: \u77e9\u9635\u884c\u6570\u3002</p> </li> <li> <p><code>cols</code>: \u77e9\u9635\u5217\u6570\u3002</p> </li> <li> <p><code>padd_in</code>: \u8f93\u5165\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>padd_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>step_in</code>: \u8f93\u5165\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> <li> <p><code>step_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u9519\u8bef\u7801\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_9","title":"\u77e9\u9635\u4e58\u6cd5","text":"<pre><code>tiny_error_t tiny_mat_mult_f32(const float *A, const float *B, float *C, int m, int n, int k);\n</code></pre> <p>\u51fd\u6570: \u77e9\u9635\u4e58\u6cd5\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>A</code>: \u8f93\u5165\u77e9\u9635A\u3002</p> </li> <li> <p><code>B</code>: \u8f93\u5165\u77e9\u9635B\u3002</p> </li> <li> <p><code>C</code>: \u8f93\u51fa\u77e9\u9635C\u3002</p> </li> <li> <p><code>m</code>: \u77e9\u9635A\u7684\u884c\u6570\u3002</p> </li> <li> <p><code>n</code>: \u77e9\u9635A\u7684\u5217\u6570\u3002</p> </li> <li> <p><code>k</code>: \u77e9\u9635B\u7684\u5217\u6570\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u9519\u8bef\u7801\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_10","title":"\u6269\u5c55\u77e9\u9635\u4e58\u6cd5","text":"<pre><code>tiny_error_t tiny_mat_mult_ex_f32(const float *A, const float *B, float *C, int A_rows, int A_cols, int B_cols, int A_padding, int B_padding, int C_padding);\n</code></pre> <p>\u51fd\u6570: \u6269\u5c55\u77e9\u9635\u4e58\u6cd5\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>A</code>: \u8f93\u5165\u77e9\u9635A\u3002</p> </li> <li> <p><code>B</code>: \u8f93\u5165\u77e9\u9635B\u3002</p> </li> <li> <p><code>C</code>: \u8f93\u51fa\u77e9\u9635C\u3002</p> </li> <li> <p><code>A_rows</code>: \u77e9\u9635A\u7684\u884c\u6570\u3002</p> </li> <li> <p><code>A_cols</code>: \u77e9\u9635A\u7684\u5217\u6570\u3002</p> </li> <li> <p><code>B_cols</code>: \u77e9\u9635B\u7684\u5217\u6570\u3002</p> </li> <li> <p><code>A_padding</code>: \u77e9\u9635A\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>B_padding</code>: \u77e9\u9635B\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>C_padding</code>: \u77e9\u9635C\u7684\u586b\u5145\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u9519\u8bef\u7801\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_11","title":"\u77e9\u9635\u4e58\u5e38\u6570","text":"<pre><code>tiny_error_t tiny_mat_multc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre> <p>\u51fd\u6570: \u77e9\u9635\u4e58\u5e38\u6570\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>input</code>: \u8f93\u5165\u77e9\u9635\u3002</p> </li> <li> <p><code>output</code>: \u8f93\u51fa\u77e9\u9635\u3002</p> </li> <li> <p><code>C</code>: \u5e38\u6570\u3002</p> </li> <li> <p><code>rows</code>: \u77e9\u9635\u884c\u6570\u3002</p> </li> <li> <p><code>cols</code>: \u77e9\u9635\u5217\u6570\u3002</p> </li> <li> <p><code>padd_in</code>: \u8f93\u5165\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>padd_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>step_in</code>: \u8f93\u5165\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> <li> <p><code>step_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u9519\u8bef\u7801\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-code/","title":"\u4ee3\u7801","text":""},{"location":"zh/MATH/MATRIX/tiny-mat-test/","title":"TINY_MAT \u6d4b\u8bd5","text":""},{"location":"zh/MATH/MATRIX/tiny-mat-test/#_1","title":"\u6d4b\u8bd5\u4ee3\u7801","text":""},{"location":"zh/MATH/MATRIX/tiny-mat-test/#_2","title":"\u6d4b\u8bd5\u7ed3\u679c","text":"<pre><code>============ [tiny_mat_test - Full Coverage] ============\n[TEST SETTINGS] ROWS=2, COLS=3, PAD=1, FULL_WIDTH=4\nA (padded) | memory layout =\n  1.000000   2.000000   3.000000   0.000000 \n  4.000000   5.000000   6.000000   0.000000 \n\nB (padded) | memory layout =\n  7.000000   8.000000   9.000000   0.000000 \n 10.000000  11.000000  12.000000   0.000000 \n 13.000000  14.000000  15.000000   0.000000 \n\nA_compact =\n  1.000000   2.000000   3.000000 \n  2.000000   3.000000   4.000000 \n\nB_compact =\n  7.000000   8.000000   9.000000 \n  8.000000   9.000000  10.000000 \n  9.000000  10.000000  11.000000 \n\nconstant = 2.000000\n\n--- tiny_mat_add_f32(rows=2, cols=3, paddings=1) | Time:  18.00 us | Error: 0 ---\nOutput (padded) =\n  8.000000  10.000000  12.000000 \n 14.000000  16.000000  18.000000 \n\n--- tiny_mat_addc_f32(C=2.000000) | Time:  10.00 us | Error: 0 ---\nOutput (padded) =\n  3.000000   4.000000   5.000000 \n  6.000000   7.000000   8.000000 \n\n--- tiny_mat_sub_f32(rows=2, cols=3) | Time:  13.00 us | Error: 0 ---\nOutput (padded) =\n -6.000000  -6.000000  -6.000000 \n -6.000000  -6.000000  -6.000000 \n\n--- tiny_mat_subc_f32(C=2.000000) | Time:   7.00 us | Error: 0 ---\nOutput (padded) =\n -1.000000   0.000000   1.000000 \n  2.000000   3.000000   4.000000 \n\n--- tiny_mat_multc_f32(C=2.000000) | Time:   8.00 us | Error: 0 ---\nOutput (padded) =\n  2.000000   4.000000   6.000000 \n  8.000000  10.000000  12.000000 \n\n--- tiny_mat_mult_f32 (compact) | Time:  10.00 us | Error: 0 ---\nOutput (compact) =\n 66.000000  72.000000  78.000000 \n 72.000000  78.000000 156.000000 \n\n--- tiny_mat_mult_ex_f32(padded) | Time:  13.00 us | Error: 0 ---\nOutput (padded) =\n 66.000000  72.000000  78.000000 \n156.000000 171.000000 186.000000 \n\n============ [test complete] ============\n</code></pre>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/","title":"\u77e9\u9635\u64cd\u4f5c - TINY_MATRIX","text":"<p>TINY_MATRIX\u5e93</p> <ul> <li>\u8be5\u5e93\u662f\u4e00\u4e2a\u8f7b\u91cf\u7ea7\u7684\u77e9\u9635\u8fd0\u7b97\u5e93\uff0c\u57fa\u4e8eC++\u5b9e\u73b0\uff0c\u63d0\u4f9b\u4e86\u57fa\u672c\u7684\u77e9\u9635\u64cd\u4f5c\u548c\u7ebf\u6027\u4ee3\u6570\u529f\u80fd\u3002</li> <li>\u8be5\u5e93\u7684\u8bbe\u8ba1\u76ee\u6807\u662f\u63d0\u4f9b\u7b80\u5355\u6613\u7528\u7684\u77e9\u9635\u64cd\u4f5c\u63a5\u53e3\uff0c\u9002\u5408\u4e8e\u5d4c\u5165\u5f0f\u7cfb\u7edf\u548c\u8d44\u6e90\u53d7\u9650\u7684\u73af\u5883\u3002</li> </ul> <p>\u4f7f\u7528\u573a\u666f</p> <p>\u76f8\u5bf9\u4e8eTINY_MAT\u5e93\u800c\u8a00\uff0cTINY_MATRIX\u5e93\u63d0\u4f9b\u4e86\u66f4\u4e30\u5bcc\u7684\u529f\u80fd\u548c\u66f4\u9ad8\u7684\u7075\u6d3b\u6027\uff0c\u9002\u5408\u4e8e\u9700\u8981\u8fdb\u884c\u590d\u6742\u77e9\u9635\u8fd0\u7b97\u7684\u5e94\u7528\u573a\u666f\u3002\u4f46\u662f\u8bf7\u6ce8\u610f\uff0c\u8be5\u5e93\u57fa\u4e8eC++\u7f16\u5199\uff0c</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_1","title":"\u76ee\u5f55","text":"<pre><code>TinyMath\n    \u251c\u2500\u2500Vector\n    \u2514\u2500\u2500Matrix\n        \u251c\u2500\u2500 tiny_mat (c)\n        \u2514\u2500\u2500 tiny_matrix (c++) &lt;---\n</code></pre> <pre><code>namespace tiny\n{\n    class Mat\n    {\n    public:\n        /* === Matrix Metadata === */\n        int rows, cols, stride, padding, length;\n        float *data;\n        bool ext_buff, sub_matrix;\n\n        /* === Rectangular ROI Structure === */\n        struct Rect\n        {\n            int x, y, width, height;\n            Rect(int x = 0, int y = 0, int width = 0, int height = 0);\n            void resizeRect(int x, int y, int width, int height);\n            int areaRect(void) const;\n        };\n\n        /* === Constructors &amp; Destructor === */\n        Mat();                                      // Default constructor\n        Mat(int rows, int cols);                    // Internal allocation\n        Mat(float *data, int rows, int cols);       // External buffer\n        Mat(float *data, int rows, int cols, int stride); // External buffer with stride\n        Mat(const Mat &amp;src);                        // Copy constructor\n        ~Mat();                                     // Destructor\n\n        void allocate();                            // Allocate internal memory\n\n        /* === Element Access === */\n        inline float &amp;operator()(int row, int col) { return data[row * stride + col]; }\n        inline const float &amp;operator()(int row, int col) const { return data[row * stride + col]; }\n\n        /* === Data Manipulation === */\n        void Copy(const Mat &amp;src, int row_pos, int col_pos);\n        void CopyHead(const Mat &amp;src);\n        Mat getROI(int startRow, int startCol, int roiRows, int roiCols, int stride);\n        Mat getROI(int startRow, int startCol, int roiRows, int roiCols);\n        Mat getROI(const Rect &amp;rect);\n        Mat Get(int row_start, int row_size, int col_start, int col_size);\n        Mat Get(const Rect &amp;rect);\n        Mat block(int startRow, int startCol, int blockRows, int blockCols);\n        void swapRows(int row1, int row2);\n        void clear();\n\n        /* === Print &amp; Debug === */\n        void PrintHead();\n        void PrintMatrix(bool show_padding, const std::string &amp;label);\n\n        /* === Arithmetic Operators === */\n        Mat &amp;operator=(const Mat &amp;src);             // Copy assignment\n        Mat &amp;operator+=(const Mat &amp;A);\n        Mat &amp;operator+=(float C);\n        Mat &amp;operator-=(const Mat &amp;A);\n        Mat &amp;operator-=(float C);\n        Mat &amp;operator*=(const Mat &amp;A);\n        Mat &amp;operator*=(float C);\n        Mat &amp;operator/=(const Mat &amp;B);\n        Mat &amp;operator/=(float C);\n        Mat operator^(int C);\n\n        /* === Linear Algebra === */\n        Mat t();\n        void normalize();\n        float norm();\n        float det(int n);\n        Mat inverse();\n        Mat pinv();\n        Mat gaussianEliminate();\n        Mat rowReduceFromGaussian();\n\n        /* === Static Utility Functions === */\n        static Mat eye(int size);\n        static Mat ones(int size);\n        static Mat ones(int rows, int cols);\n        static Mat solve(Mat A, Mat b);\n        static Mat bandSolve(Mat A, Mat b, int k);\n        static Mat roots(Mat A, Mat y);\n        static float dotProduct(Mat A, Mat B);\n        static Mat augment(Mat A, Mat B);\n\n    private:\n        Mat cofactor(int row, int col, int n);\n        Mat adjoint();\n        Mat expHelper(const Mat &amp;m, int num);\n    };\n\n    /* === Stream Operators === */\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat &amp;m);\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat::Rect &amp;rect);\n    std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Mat &amp;m);\n\n    /* === Global Arithmetic Operators === */\n    Mat operator+(const Mat &amp;A, const Mat &amp;B);\n    Mat operator+(const Mat &amp;A, float C);\n    Mat operator-(const Mat &amp;A, const Mat &amp;B);\n    Mat operator-(const Mat &amp;A, float C);\n    Mat operator*(const Mat &amp;A, const Mat &amp;B);\n    Mat operator*(const Mat &amp;A, float C);\n    Mat operator*(float C, const Mat &amp;A);\n    Mat operator/(const Mat &amp;A, float C);\n    Mat operator/(const Mat &amp;A, const Mat &amp;B);\n    bool operator==(const Mat &amp;A, const Mat &amp;B);\n}\n</code></pre>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_2","title":"\u77e9\u9635\u5143\u6570\u636e","text":"<ul> <li> <p><code>int rows</code>\uff1a\u77e9\u9635\u7684\u884c\u6570</p> </li> <li> <p><code>int cols</code>\uff1a\u77e9\u9635\u7684\u5217\u6570</p> </li> <li> <p><code>int stride</code>\uff1a\u77e9\u9635\u7684\u6b65\u5e45\uff0c\u8868\u793a\u6bcf\u884c\u7684\u5b57\u8282\u6570</p> </li> <li> <p><code>int padding</code>\uff1a\u77e9\u9635\u7684\u586b\u5145\u5927\u5c0f\uff0c\u8868\u793a\u6bcf\u884c\u7684\u586b\u5145\u5b57\u8282\u6570</p> </li> <li> <p><code>int length</code>\uff1a\u77e9\u9635\u7684\u603b\u5143\u7d20\u4e2a\u6570</p> </li> <li> <p><code>float *data</code>\uff1a\u6307\u5411\u77e9\u9635\u6570\u636e\u7684\u6307\u9488</p> </li> <li> <p><code>bool ext_buff</code>\uff1a\u662f\u5426\u4f7f\u7528\u5916\u90e8\u7f13\u51b2\u533a</p> </li> <li> <p><code>bool sub_matrix</code>\uff1a\u662f\u5426\u4e3a\u5b50\u77e9\u9635</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_3","title":"\u5b50\u77e9\u9635\u7ed3\u6784","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_4","title":"\u5b50\u77e9\u9635\u5143\u6570\u636e","text":"<ul> <li> <p><code>int x</code>\uff1a\u5b50\u77e9\u9635\u7684\u8d77\u59cb\u884c</p> </li> <li> <p><code>int y</code>\uff1a\u5b50\u77e9\u9635\u7684\u8d77\u59cb\u5217</p> </li> <li> <p><code>int width</code>\uff1a\u5b50\u77e9\u9635\u7684\u5bbd\u5ea6</p> </li> <li> <p><code>int height</code>\uff1a\u5b50\u77e9\u9635\u7684\u9ad8\u5ea6</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_5","title":"\u5b50\u77e9\u9635\u6784\u9020\u51fd\u6570","text":"<p><pre><code>Mat::Rect::Rect(int x, int y, int width, int height);\n</code></pre> - <code>x</code>\uff1a\u5b50\u77e9\u9635\u7684\u8d77\u59cb\u884c</p> <ul> <li> <p><code>y</code>\uff1a\u5b50\u77e9\u9635\u7684\u8d77\u59cb\u5217</p> </li> <li> <p><code>width</code>\uff1a\u5b50\u77e9\u9635\u7684\u5bbd\u5ea6</p> </li> <li> <p><code>height</code>\uff1a\u5b50\u77e9\u9635\u7684\u9ad8\u5ea6</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_6","title":"\u5b50\u77e9\u9635\u91cd\u65b0\u8c03\u6574\u5927\u5c0f","text":"<pre><code>void Mat::Rect::resizeRect(int x, int y, int width, int height);\n</code></pre> <ul> <li> <p><code>x</code>\uff1a\u5b50\u77e9\u9635\u7684\u8d77\u59cb\u884c</p> </li> <li> <p><code>y</code>\uff1a\u5b50\u77e9\u9635\u7684\u8d77\u59cb\u5217</p> </li> <li> <p><code>width</code>\uff1a\u5b50\u77e9\u9635\u7684\u5bbd\u5ea6</p> </li> <li> <p><code>height</code>\uff1a\u5b50\u77e9\u9635\u7684\u9ad8\u5ea6</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_7","title":"\u5b50\u77e9\u9635\u9762\u79ef","text":"<pre><code>int Mat::Rect::areaRect(void) const\uff1b\n</code></pre> <ul> <li>\u8fd4\u56de\u5b50\u77e9\u9635\u7684\u9762\u79ef \uff08\u8986\u76d6\u7684\u5143\u7d20\u4e2a\u6570\uff09</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_8","title":"\u6784\u9020\u51fd\u6570\u548c\u6790\u6784\u51fd\u6570","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_9","title":"\u9ed8\u8ba4\u6784\u9020\u51fd\u6570","text":"<pre><code>Mat::Mat()\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u9ed8\u8ba4\u6784\u9020\u51fd\u6570\uff0c\u521b\u5efa\u4e00\u4e2a\u7a7a\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a \u65e0</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_10","title":"\u5185\u90e8\u5206\u914d\u6784\u9020\u51fd\u6570","text":"<p><pre><code>Mat::Mat(int rows, int cols)\uff1b\n</code></pre> \u529f\u80fd\u63cf\u8ff0\uff1a \u521b\u5efa\u4e00\u4e2a\u6307\u5b9a\u884c\u6570\u548c\u5217\u6570\u7684\u77e9\u9635\uff0c\u5e76\u5206\u914d\u5185\u5b58\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>int rows</code>\uff1a\u77e9\u9635\u7684\u884c\u6570</p> </li> <li> <p><code>int cols</code>\uff1a\u77e9\u9635\u7684\u5217\u6570</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_11","title":"\u5916\u90e8\u7f13\u51b2\u533a\u6784\u9020\u51fd\u6570","text":"<p><pre><code>Mat::Mat(float *data, int rows, int cols)\uff1b\n</code></pre> \u529f\u80fd\u63cf\u8ff0\uff1a \u521b\u5efa\u4e00\u4e2a\u6307\u5b9a\u884c\u6570\u548c\u5217\u6570\u7684\u77e9\u9635\uff0c\u5e76\u4f7f\u7528\u5916\u90e8\u7f13\u51b2\u533a\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>float *data</code>\uff1a\u6307\u5411\u5916\u90e8\u7f13\u51b2\u533a\u7684\u6307\u9488</p> </li> <li> <p><code>int rows</code>\uff1a\u77e9\u9635\u7684\u884c\u6570</p> </li> <li> <p><code>int cols</code>\uff1a\u77e9\u9635\u7684\u5217\u6570</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_12","title":"\u5916\u90e8\u7f13\u51b2\u533a\u548c\u6b65\u5e45\u6784\u9020\u51fd\u6570","text":"<pre><code>Mat::Mat(float *data, int rows, int cols, int stride)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u521b\u5efa\u4e00\u4e2a\u6307\u5b9a\u884c\u6570\u3001\u5217\u6570\u548c\u6b65\u5e45\u7684\u77e9\u9635\uff0c\u5e76\u4f7f\u7528\u5916\u90e8\u7f13\u51b2\u533a\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>float *data</code>\uff1a\u6307\u5411\u5916\u90e8\u7f13\u51b2\u533a\u7684\u6307\u9488</p> </li> <li> <p><code>int rows</code>\uff1a\u77e9\u9635\u7684\u884c\u6570</p> </li> <li> <p><code>int cols</code>\uff1a\u77e9\u9635\u7684\u5217\u6570</p> </li> <li> <p><code>int stride</code>\uff1a\u77e9\u9635\u7684\u6b65\u5e45</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_13","title":"\u62f7\u8d1d\u6784\u9020\u51fd\u6570","text":"<pre><code>Mat::Mat(const Mat &amp;src)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u521b\u5efa\u4e00\u4e2a\u77e9\u9635\u7684\u62f7\u8d1d\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>const Mat &amp;src</code>\uff1a\u8981\u62f7\u8d1d\u7684\u77e9\u9635</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_14","title":"\u6790\u6784\u51fd\u6570","text":"<pre><code>Mat::~Mat()\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u6790\u6784\u51fd\u6570\uff0c\u91ca\u653e\u77e9\u9635\u7684\u5185\u5b58\u3002</p> <p>\u53c2\u6570\uff1a \u65e0</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_15","title":"\u5185\u5b58\u5206\u914d\u51fd\u6570","text":"<pre><code>void Mat::allocate()\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u5206\u914d\u77e9\u9635\u7684\u5185\u5b58\u3002</p> <p>\u53c2\u6570\uff1a \u65e0</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_16","title":"\u77e9\u9635\u5143\u7d20\u8bbf\u95ee","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_17","title":"\u5143\u7d20\u8bbf\u95ee\u8fd0\u7b97\u7b26","text":"<p><pre><code>inline float &amp;operator()(int row, int col) { return data[row * stride + col]; }\n</code></pre> \u529f\u80fd\u63cf\u8ff0\uff1a \u8bbf\u95ee\u77e9\u9635\u7684\u5143\u7d20\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>int row</code>\uff1a\u8981\u8bbf\u95ee\u7684\u884c\u7d22\u5f15</p> </li> <li> <p><code>int col</code>\uff1a\u8981\u8bbf\u95ee\u7684\u5217\u7d22\u5f15</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_18","title":"\u5e38\u91cf\u5143\u7d20\u8bbf\u95ee\u8fd0\u7b97\u7b26","text":"<pre><code>inline const float &amp;operator()(int row, int col) const { return data[row * stride + col]; }\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u8bbf\u95ee\u77e9\u9635\u7684\u5143\u7d20\uff08\u5e38\u91cf\u7248\u672c\uff09\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>int row</code>\uff1a\u8981\u8bbf\u95ee\u7684\u884c\u7d22\u5f15</p> </li> <li> <p><code>int col</code>\uff1a\u8981\u8bbf\u95ee\u7684\u5217\u7d22\u5f15</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_19","title":"\u6570\u636e\u64cd\u4f5c","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_20","title":"\u62f7\u8d1d\u51fd\u6570","text":"<pre><code>void Mat::Copy(const Mat &amp;src, int row_pos, int col_pos)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u5c06\u6e90\u77e9\u9635\u7684\u5185\u5bb9\u62f7\u8d1d\u5230\u5f53\u524d\u77e9\u9635\u7684\u6307\u5b9a\u4f4d\u7f6e\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>const Mat &amp;src</code>\uff1a\u6e90\u77e9\u9635</p> </li> <li> <p><code>int row_pos</code>\uff1a\u76ee\u6807\u77e9\u9635\u7684\u8d77\u59cb\u884c\u7d22\u5f15</p> </li> <li> <p><code>int col_pos</code>\uff1a\u76ee\u6807\u77e9\u9635\u7684\u8d77\u59cb\u5217\u7d22\u5f15</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_21","title":"\u62f7\u8d1d\u5934\u51fd\u6570","text":"<pre><code>void Mat::CopyHead(const Mat &amp;src)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u5c06\u6e90\u77e9\u9635\u7684\u5934\u90e8\u4fe1\u606f\u62f7\u8d1d\u5230\u5f53\u524d\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>const Mat &amp;src</code>\uff1a\u6e90\u77e9\u9635</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#roi","title":"\u83b7\u53d6ROI\u51fd\u6570","text":"<pre><code>Mat getROI(int startRow, int startCol, int roiRows, int roiCols, int stride)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u83b7\u53d6\u77e9\u9635\u7684\u611f\u5174\u8da3\u533a\u57df\uff08ROI\uff09\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>int startRow</code>\uff1aROI\u7684\u8d77\u59cb\u884c\u7d22\u5f15</p> </li> <li> <p><code>int startCol</code>\uff1aROI\u7684\u8d77\u59cb\u5217\u7d22\u5f15</p> </li> <li> <p><code>int roiRows</code>\uff1aROI\u7684\u884c\u6570</p> </li> <li> <p><code>int roiCols</code>\uff1aROI\u7684\u5217\u6570</p> </li> <li> <p><code>int stride</code>\uff1a\u6b65\u5e45 </p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#roi-","title":"\u83b7\u53d6ROI\u51fd\u6570\uff08\u91cd\u8f7d-\u65e0\u6b65\u5e45\uff09","text":"<pre><code>Mat getROI(int startRow, int startCol, int roiRows, int roiCols)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u83b7\u53d6\u77e9\u9635\u7684\u611f\u5174\u8da3\u533a\u57df\uff08ROI\uff09\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>int startRow</code>\uff1aROI\u7684\u8d77\u59cb\u884c\u7d22\u5f15</p> </li> <li> <p><code>int startCol</code>\uff1aROI\u7684\u8d77\u59cb\u5217\u7d22\u5f15</p> </li> <li> <p><code>int roiRows</code>\uff1aROI\u7684\u884c\u6570</p> </li> <li> <p><code>int roiCols</code>\uff1aROI\u7684\u5217\u6570</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#roi-_1","title":"\u83b7\u53d6ROI\u51fd\u6570\uff08\u91cd\u8f7d-\u5b50\u77e9\u9635\uff09","text":"<pre><code>Mat getROI(const Rect &amp;rect)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u83b7\u53d6\u77e9\u9635\u7684\u611f\u5174\u8da3\u533a\u57df\uff08ROI\uff09\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>const Rect &amp;rect</code>\uff1a\u5b50\u77e9\u9635\u7684\u77e9\u5f62\u533a\u57df</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_22","title":"\u83b7\u53d6\u5b50\u77e9\u9635\u51fd\u6570","text":"<pre><code>Mat Get(int row_start, int row_size, int col_start, int col_size)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u83b7\u53d6\u77e9\u9635\u7684\u5b50\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>int row_start</code>\uff1a\u5b50\u77e9\u9635\u7684\u8d77\u59cb\u884c\u7d22\u5f15</p> </li> <li> <p><code>int row_size</code>\uff1a\u5b50\u77e9\u9635\u7684\u884c\u6570</p> </li> <li> <p><code>int col_start</code>\uff1a\u5b50\u77e9\u9635\u7684\u8d77\u59cb\u5217\u7d22\u5f15</p> </li> <li> <p><code>int col_size</code>\uff1a\u5b50\u77e9\u9635\u7684\u5217\u6570</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-","title":"\u83b7\u53d6\u5b50\u77e9\u9635\u51fd\u6570\uff08\u91cd\u8f7d-\u77e9\u5f62\u533a\u57df\uff09","text":"<pre><code>Mat Get(const Rect &amp;rect)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u83b7\u53d6\u77e9\u9635\u7684\u5b50\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>const Rect &amp;rect</code>\uff1a\u5b50\u77e9\u9635\u7684\u77e9\u5f62\u533a\u57df</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_23","title":"\u83b7\u53d6\u5757\u51fd\u6570","text":"<pre><code>Mat block(int startRow, int startCol, int blockRows, int blockCols)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u83b7\u53d6\u77e9\u9635\u7684\u5757\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>int startRow</code>\uff1a\u5757\u7684\u8d77\u59cb\u884c\u7d22\u5f15</p> </li> <li> <p><code>int startCol</code>\uff1a\u5757\u7684\u8d77\u59cb\u5217\u7d22\u5f15</p> </li> <li> <p><code>int blockRows</code>\uff1a\u5757\u7684\u884c\u6570</p> </li> <li> <p><code>int blockCols</code>\uff1a\u5757\u7684\u5217\u6570</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_24","title":"\u4ea4\u6362\u884c\u51fd\u6570","text":"<pre><code>void swapRows(int row1, int row2)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u4ea4\u6362\u77e9\u9635\u7684\u4e24\u884c\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>int row1</code>\uff1a\u8981\u4ea4\u6362\u7684\u7b2c\u4e00\u884c\u7d22\u5f15</p> </li> <li> <p><code>int row2</code>\uff1a\u8981\u4ea4\u6362\u7684\u7b2c\u4e8c\u884c\u7d22\u5f15</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_25","title":"\u6e05\u7a7a\u51fd\u6570","text":"<pre><code>void clear()\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u6e05\u7a7a\u77e9\u9635\u7684\u5185\u5bb9\u3002</p> <p>\u53c2\u6570\uff1a \u65e0</p> <p>getROI | Get | block</p> <ul> <li>getROI\uff1a\u83b7\u53d6\u77e9\u9635\u7684\u611f\u5174\u8da3\u533a\u57df\uff08ROI\uff09</li> <li>Get\uff1a\u83b7\u53d6\u77e9\u9635\u7684\u5b50\u77e9\u9635</li> <li>block\uff1a\u83b7\u53d6\u77e9\u9635\u7684\u5757</li> </ul> \u65b9\u6cd5 \u662f\u5426\u62f7\u8d1d\u6570\u636e \u662f\u5426\u65b0\u5efa\u5185\u5b58 \u4fee\u6539\u540e\u662f\u5426\u5f71\u54cd\u539f\u77e9\u9635 \u6027\u80fd \u9002\u7528\u573a\u666f <code>getROI</code> \u5426 \u5426 \u4f1a\u5f71\u54cd \u2b50\u2b50\u2b50\u2b50\u2b50 \u5feb\u901f\u5904\u7406\u4e34\u65f6\u5b50\u77e9\u9635 <code>Get</code> \u662f \u662f \u4e0d\u5f71\u54cd \u2b50\u2b50\u2b50\u2b50 \u5b89\u5168\u72ec\u7acb\u7684\u5b50\u77e9\u9635 <code>block</code> \u662f \u662f \u4e0d\u5f71\u54cd \u2b50\u2b50\u2b50 \u7075\u6d3b\u5904\u7406\u590d\u6742\u62f7\u8d1d"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_26","title":"\u6253\u5370\u548c\u8c03\u8bd5","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_27","title":"\u6253\u5370\u5934\u51fd\u6570","text":"<pre><code>void Mat::PrintHead()\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u6253\u5370\u77e9\u9635\u7684\u5143\u6570\u636e\u3002</p> <p>\u53c2\u6570\uff1a \u65e0</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_28","title":"\u6253\u5370\u77e9\u9635\u51fd\u6570","text":"<pre><code>void Mat::PrintMatrix(bool show_padding, const std::string &amp;label)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u6253\u5370\u77e9\u9635\u7684\u5185\u5bb9\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>bool show_padding</code>\uff1a\u662f\u5426\u663e\u793a\u586b\u5145</p> </li> <li> <p><code>const std::string &amp;label</code>\uff1a\u6253\u5370\u7684\u6807\u7b7e</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_29","title":"\u7b97\u672f\u8fd0\u7b97\u7b26","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_30","title":"\u8d4b\u503c\u8fd0\u7b97\u7b26","text":"<pre><code>Mat &amp;operator=(const Mat &amp;src)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u8d4b\u503c\u8fd0\u7b97\u7b26\uff0c\u5c06\u6e90\u77e9\u9635\u7684\u5185\u5bb9\u8d4b\u503c\u7ed9\u5f53\u524d\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>const Mat &amp;src</code>\uff1a\u6e90\u77e9\u9635</li> </ul> <p>\u6ce8\u610f</p> <p>\u8be5\u8fd0\u7b97\u7b26\u4f1a\u8bb2\u5f53\u524d\u77e9\u9635\u62f7\u8d1d\u6210\u4e3a\u6e90\u77e9\u9635\u7684\u5927\u5c0f\uff0c\u4e14\u5143\u7d20\u7684\u503c\u4e5f\u4f1a\u62f7\u8d1d\u5230\u5f53\u524d\u77e9\u9635\u4e2d\u3002\u4e24\u8005\u5e76\u4e0d\u5171\u4eab\u5185\u5b58\uff0c\u56e0\u4e3a\u8be5\u64cd\u4f5c\u4f1a\u65b0\u5206\u914d\u5185\u5b58\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_31","title":"\u52a0\u6cd5\u8fd0\u7b97\u7b26","text":"<pre><code>Mat &amp;operator+=(const Mat &amp;A)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u52a0\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u5f53\u524d\u77e9\u9635\u4e0e\u53e6\u4e00\u4e2a\u77e9\u9635\u76f8\u52a0\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>const Mat &amp;A</code>\uff1a\u8981\u76f8\u52a0\u7684\u77e9\u9635</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_32","title":"\u52a0\u6cd5\u8fd0\u7b97\u7b26\uff08\u52a0\u5e38\u6570\uff09","text":"<pre><code>Mat &amp;operator+=(float C)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u52a0\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u5f53\u524d\u77e9\u9635\u4e0e\u4e00\u4e2a\u5e38\u6570\u76f8\u52a0\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>float C</code>\uff1a\u8981\u76f8\u52a0\u7684\u5e38\u6570</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_33","title":"\u51cf\u6cd5\u8fd0\u7b97\u7b26","text":"<pre><code>Mat &amp;operator-=(const Mat &amp;A)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u51cf\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u5f53\u524d\u77e9\u9635\u4e0e\u53e6\u4e00\u4e2a\u77e9\u9635\u76f8\u51cf\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>const Mat &amp;A</code>\uff1a\u8981\u76f8\u51cf\u7684\u77e9\u9635</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_34","title":"\u51cf\u6cd5\u8fd0\u7b97\u7b26\uff08\u51cf\u5e38\u6570\uff09","text":"<pre><code>Mat &amp;operator-=(float C)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u51cf\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u5f53\u524d\u77e9\u9635\u4e0e\u4e00\u4e2a\u5e38\u6570\u76f8\u51cf\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>float C</code>\uff1a\u8981\u76f8\u51cf\u7684\u5e38\u6570</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_35","title":"\u4e58\u6cd5\u8fd0\u7b97\u7b26","text":"<pre><code>Mat &amp;operator*=(const Mat &amp;A)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u4e58\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u5f53\u524d\u77e9\u9635\u4e0e\u53e6\u4e00\u4e2a\u77e9\u9635\u76f8\u4e58\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>const Mat &amp;A</code>\uff1a\u8981\u76f8\u4e58\u7684\u77e9\u9635</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_36","title":"\u4e58\u6cd5\u8fd0\u7b97\u7b26\uff08\u4e58\u5e38\u6570\uff09","text":"<pre><code>Mat &amp;operator*=(float C)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u4e58\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u5f53\u524d\u77e9\u9635\u4e0e\u4e00\u4e2a\u5e38\u6570\u76f8\u4e58\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>float C</code>\uff1a\u8981\u76f8\u4e58\u7684\u5e38\u6570</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_37","title":"\u9664\u6cd5\u8fd0\u7b97\u7b26 \uff08\u6309\u5143\u7d20\uff09","text":"<pre><code>Mat &amp;operator/=(const Mat &amp;B)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u9664\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u5f53\u524d\u77e9\u9635\u9664\u4ee5\u53e6\u4e00\u4e2a\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>const Mat &amp;B</code>\uff1a\u8981\u9664\u4ee5\u7684\u77e9\u9635</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_38","title":"\u9664\u6cd5\u8fd0\u7b97\u7b26\uff08\u9664\u5e38\u6570\uff09","text":"<pre><code>Mat &amp;operator/=(float C)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u9664\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u5f53\u524d\u77e9\u9635\u9664\u4ee5\u4e00\u4e2a\u5e38\u6570\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>float C</code>\uff1a\u8981\u9664\u4ee5\u7684\u5e38\u6570</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_39","title":"\u5e42\u8fd0\u7b97\u7b26","text":"<pre><code>Mat operator^(int C)\uff1b\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u5e42\u8fd0\u7b97\u7b26\uff0c\u5c06\u5f53\u524d\u77e9\u9635\u7684\u6bcf\u4e2a\u5143\u7d20\u90fd\u8fdb\u884c\u5e42\u8fd0\u7b97\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>int C</code>\uff1a\u5e42\u7684\u6307\u6570</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_40","title":"\u7ebf\u6027\u4ee3\u6570","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_41","title":"\u5f52\u4e00\u5316\u51fd\u6570","text":"<pre><code>void Mat::normalize(void) // normalize the matrix\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u5f52\u4e00\u5316\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a \u65e0</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_42","title":"\u8303\u6570\u51fd\u6570","text":"<pre><code>float Mat::norm(void) // calculate matrix norm\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u8ba1\u7b97\u77e9\u9635\u7684\u8303\u6570\u3002</p> <p>\u53c2\u6570\uff1a \u65e0</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_43","title":"\u884c\u5217\u5f0f\u51fd\u6570","text":"<pre><code>float Mat::det(int n) // calculate determinant\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u8ba1\u7b97\u77e9\u9635\u7684\u884c\u5217\u5f0f\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>int n</code>\uff1a\u77e9\u9635\u7684\u5927\u5c0f</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_44","title":"\u8f6c\u7f6e\u51fd\u6570","text":"<pre><code>Mat Mat::t()\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u8f6c\u7f6e\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a \u65e0</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_45","title":"\u9006\u77e9\u9635\u51fd\u6570","text":"<pre><code>Mat Mat::inverse()\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u8ba1\u7b97\u77e9\u9635\u7684\u9006\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a \u65e0</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_46","title":"\u4f2a\u9006\u77e9\u9635\u51fd\u6570","text":"<pre><code>Mat Mat::pinv()\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u8ba1\u7b97\u77e9\u9635\u7684\u4f2a\u9006\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a \u65e0</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_47","title":"\u9ad8\u65af\u6d88\u5143\u51fd\u6570","text":"<pre><code>Mat Mat::gaussianEliminate()\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u8fdb\u884c\u9ad8\u65af\u6d88\u5143\u64cd\u4f5c\u3002</p> <p>\u53c2\u6570\uff1a \u65e0</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_48","title":"\u884c\u7b80\u5316\u51fd\u6570","text":"<pre><code>Mat Mat::rowReduceFromGaussian()\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u8fdb\u884c\u884c\u7b80\u5316\u64cd\u4f5c\u3002</p> <p>\u53c2\u6570\uff1a \u65e0</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_49","title":"\u5b9e\u7528\u51fd\u6570","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_50","title":"\u5355\u4f4d\u77e9\u9635\u51fd\u6570","text":"<pre><code>Mat Mat::eye(int size)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u521b\u5efa\u4e00\u4e2a\u5355\u4f4d\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>int size</code>\uff1a\u77e9\u9635\u7684\u5927\u5c0f</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#1","title":"\u51681\u77e9\u9635\u51fd\u6570","text":"<pre><code>Mat Mat::ones(int size)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u521b\u5efa\u4e00\u4e2a\u51681\u65b9\u9635\u3002</p> <p>\u53c2\u6570\uff1a </p> <ul> <li><code>int size</code>\uff1a\u77e9\u9635\u7684\u5927\u5c0f</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#1-","title":"\u51681\u77e9\u9635\u51fd\u6570\uff08\u91cd\u8f7d-\u6307\u5b9a\u884c\u5217\uff09","text":"<pre><code>Mat Mat::ones(int rows, int cols)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u521b\u5efa\u4e00\u4e2a\u51681\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>int rows</code>\uff1a\u77e9\u9635\u7684\u884c\u6570</p> </li> <li> <p><code>int cols</code>\uff1a\u77e9\u9635\u7684\u5217\u6570</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_51","title":"\u89e3\u7ebf\u6027\u65b9\u7a0b\u7ec4\u51fd\u6570","text":"<pre><code>Mat Mat::solve(Mat A, Mat b)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u89e3\u7ebf\u6027\u65b9\u7a0b\u7ec4Ax = b\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>Mat A</code>\uff1a\u7cfb\u6570\u77e9\u9635</p> </li> <li> <p><code>Mat b</code>\uff1a\u5e38\u6570\u77e9\u9635</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_52","title":"\u5e26\u72b6\u77e9\u9635\u6c42\u89e3\u51fd\u6570","text":"<pre><code>Mat Mat::bandSolve(Mat A, Mat b, int k)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u89e3\u5e26\u72b6\u77e9\u9635\u65b9\u7a0bAx = b\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>Mat A</code>\uff1a\u7cfb\u6570\u77e9\u9635</p> </li> <li> <p><code>Mat b</code>\uff1a\u5e38\u6570\u77e9\u9635</p> </li> <li> <p><code>int k</code>\uff1a\u5e26\u5bbd</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_53","title":"\u6c42\u6839\u51fd\u6570","text":"<pre><code>Mat Mat::roots(Mat A, Mat y)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u6c42\u7ebf\u6027\u65b9\u7a0b\u7ec4\u7684\u6839\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>Mat A</code>\uff1a\u7cfb\u6570\u77e9\u9635</li> <li><code>Mat y</code>\uff1a\u5e38\u6570\u77e9\u9635</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_54","title":"\u70b9\u79ef\u51fd\u6570","text":"<pre><code>Mat Mat::dotProduct(Mat A, Mat B)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u8ba1\u7b97\u4e24\u4e2a\u77e9\u9635\u7684\u70b9\u79ef\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>Mat A</code>\uff1a\u7b2c\u4e00\u4e2a\u77e9\u9635</p> </li> <li> <p><code>Mat B</code>\uff1a\u7b2c\u4e8c\u4e2a\u77e9\u9635</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_55","title":"\u589e\u5e7f\u77e9\u9635\u51fd\u6570","text":"<pre><code>Mat Mat::augment(Mat A, Mat B)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u521b\u5efa\u589e\u5e7f\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>Mat A</code>\uff1a\u7b2c\u4e00\u4e2a\u77e9\u9635</p> </li> <li> <p><code>Mat B</code>\uff1a\u7b2c\u4e8c\u4e2a\u77e9\u9635</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_56","title":"\u4ee3\u6570\u4f59\u5b50\u5f0f\u51fd\u6570","text":"<pre><code>Mat Mat::cofactor(int row, int col, int n)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u8ba1\u7b97\u4ee3\u6570\u4f59\u5b50\u5f0f\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>int row</code>\uff1a\u884c\u7d22\u5f15</p> </li> <li> <p><code>int col</code>\uff1a\u5217\u7d22\u5f15</p> </li> <li> <p><code>int n</code>\uff1a\u77e9\u9635\u7684\u5927\u5c0f</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_57","title":"\u4f34\u968f\u77e9\u9635\u51fd\u6570","text":"<pre><code>Mat Mat::adjoint()\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u8ba1\u7b97\u4f34\u968f\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a \u65e0</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_58","title":"\u6307\u6570\u51fd\u6570","text":"<pre><code>Mat Mat::expHelper(const Mat &amp;m, int num)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u8ba1\u7b97\u77e9\u9635\u7684\u6307\u6570\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>const Mat &amp;m</code>\uff1a\u77e9\u9635</p> </li> <li> <p><code>int num</code>\uff1a\u6307\u6570\u7684\u5927\u5c0f</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_59","title":"\u6d41\u64cd\u4f5c\u7b26","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_60","title":"\u8f93\u51fa\u6d41\u64cd\u4f5c\u7b26","text":"<pre><code>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat &amp;m)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u8f93\u51fa\u77e9\u9635\u5230\u8f93\u51fa\u6d41\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>std::ostream &amp;os</code>\uff1a\u8f93\u51fa\u6d41</p> </li> <li> <p><code>const Mat &amp;m</code>\uff1a\u8981\u8f93\u51fa\u7684\u77e9\u9635</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_61","title":"\u8f93\u51fa\u6d41\u64cd\u4f5c\u7b26\uff08\u77e9\u5f62\u533a\u57df\uff09","text":"<pre><code>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat::Rect &amp;rect)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u8f93\u51fa\u77e9\u5f62\u533a\u57df\u5230\u8f93\u51fa\u6d41\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>std::ostream &amp;os</code>\uff1a\u8f93\u51fa\u6d41</p> </li> <li> <p><code>const Mat::Rect &amp;rect</code>\uff1a\u8981\u8f93\u51fa\u7684\u77e9\u5f62\u533a\u57df</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_62","title":"\u8f93\u5165\u6d41\u64cd\u4f5c\u7b26","text":"<pre><code>std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Mat &amp;m)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u4ece\u8f93\u5165\u6d41\u8bfb\u53d6\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>std::istream &amp;is</code>\uff1a\u8f93\u5165\u6d41</p> </li> <li> <p><code>Mat &amp;m</code>\uff1a\u8981\u8bfb\u53d6\u7684\u77e9\u9635</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_63","title":"\u5168\u5c40\u7b97\u672f\u8fd0\u7b97\u7b26","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_64","title":"\u52a0\u6cd5\u8fd0\u7b97\u7b26","text":"<pre><code>Mat operator+(const Mat &amp;A, const Mat &amp;B)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u52a0\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u4e24\u4e2a\u77e9\u9635\u76f8\u52a0\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>const Mat &amp;A</code>\uff1a\u7b2c\u4e00\u4e2a\u77e9\u9635</p> </li> <li> <p><code>const Mat &amp;B</code>\uff1a\u7b2c\u4e8c\u4e2a\u77e9\u9635</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_65","title":"\u52a0\u6cd5\u8fd0\u7b97\u7b26\uff08\u52a0\u5e38\u6570\uff09","text":"<pre><code>Mat operator+(const Mat &amp;A, float C)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u52a0\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u77e9\u9635\u4e0e\u4e00\u4e2a\u5e38\u6570\u76f8\u52a0\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>const Mat &amp;A</code>\uff1a\u77e9\u9635</p> </li> <li> <p><code>float C</code>\uff1a\u8981\u76f8\u52a0\u7684\u5e38\u6570</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_66","title":"\u51cf\u6cd5\u8fd0\u7b97\u7b26","text":"<pre><code>Mat operator-(const Mat &amp;A, const Mat &amp;B)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u51cf\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u4e24\u4e2a\u77e9\u9635\u76f8\u51cf\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>const Mat &amp;A</code>\uff1a\u7b2c\u4e00\u4e2a\u77e9\u9635</p> </li> <li> <p><code>const Mat &amp;B</code>\uff1a\u7b2c\u4e8c\u4e2a\u77e9\u9635</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_67","title":"\u51cf\u6cd5\u8fd0\u7b97\u7b26\uff08\u51cf\u5e38\u6570\uff09","text":"<pre><code>Mat operator-(const Mat &amp;A, float C)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u51cf\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u77e9\u9635\u4e0e\u4e00\u4e2a\u5e38\u6570\u76f8\u51cf\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>const Mat &amp;A</code>\uff1a\u77e9\u9635</p> </li> <li> <p><code>float C</code>\uff1a\u8981\u76f8\u51cf\u7684\u5e38\u6570</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_68","title":"\u4e58\u6cd5\u8fd0\u7b97\u7b26","text":"<pre><code>Mat operator*(const Mat &amp;A, const Mat &amp;B)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u4e58\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u4e24\u4e2a\u77e9\u9635\u76f8\u4e58\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>const Mat &amp;A</code>\uff1a\u7b2c\u4e00\u4e2a\u77e9\u9635</p> </li> <li> <p><code>const Mat &amp;B</code>\uff1a\u7b2c\u4e8c\u4e2a\u77e9\u9635</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_69","title":"\u4e58\u6cd5\u8fd0\u7b97\u7b26\uff08\u4e58\u5e38\u6570\uff09","text":"<pre><code>Mat operator*(const Mat &amp;A, float C)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u4e58\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u77e9\u9635\u4e0e\u4e00\u4e2a\u5e38\u6570\u76f8\u4e58\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>const Mat &amp;A</code>\uff1a\u77e9\u9635</p> </li> <li> <p><code>float C</code>\uff1a\u8981\u76f8\u4e58\u7684\u5e38\u6570</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_70","title":"\u4e58\u6cd5\u8fd0\u7b97\u7b26\uff08\u5e38\u6570\u4e58\u77e9\u9635\uff09","text":"<pre><code>Mat operator*(float C, const Mat &amp;A)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u4e58\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u4e00\u4e2a\u5e38\u6570\u4e0e\u77e9\u9635\u76f8\u4e58\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>float C</code>\uff1a\u8981\u76f8\u4e58\u7684\u5e38\u6570</p> </li> <li> <p><code>const Mat &amp;A</code>\uff1a\u77e9\u9635</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_71","title":"\u9664\u6cd5\u8fd0\u7b97\u7b26 \uff08\u9664\u5e38\u6570\uff09","text":"<pre><code>Mat operator/(const Mat &amp;A, float C)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u9664\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u77e9\u9635\u9664\u4ee5\u4e00\u4e2a\u5e38\u6570\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>const Mat &amp;A</code>\uff1a\u77e9\u9635</p> </li> <li> <p><code>float C</code>\uff1a\u8981\u9664\u4ee5\u7684\u5e38\u6570</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_72","title":"\u9664\u6cd5\u8fd0\u7b97\u7b26 \uff08\u6309\u5143\u7d20\uff09","text":"<pre><code>Mat operator/(const Mat &amp;A, const Mat &amp;B)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u9664\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u77e9\u9635\u9664\u4ee5\u53e6\u4e00\u4e2a\u77e9\u9635\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>const Mat &amp;A</code>\uff1a\u7b2c\u4e00\u4e2a\u77e9\u9635</p> </li> <li> <p><code>const Mat &amp;B</code>\uff1a\u7b2c\u4e8c\u4e2a\u77e9\u9635</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_73","title":"\u7b49\u4e8e\u8fd0\u7b97\u7b26","text":"<pre><code>bool operator==(const Mat &amp;A, const Mat &amp;B)\n</code></pre> <p>\u529f\u80fd\u63cf\u8ff0\uff1a \u7b49\u4e8e\u8fd0\u7b97\u7b26\uff0c\u5224\u65ad\u4e24\u4e2a\u77e9\u9635\u662f\u5426\u76f8\u7b49\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>const Mat &amp;A</code>\uff1a\u7b2c\u4e00\u4e2a\u77e9\u9635</p> </li> <li> <p><code>const Mat &amp;B</code>\uff1a\u7b2c\u4e8c\u4e2a\u77e9\u9635</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-code/","title":"\u4ee3\u7801","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-test/","title":"\u6d4b\u8bd5","text":""},{"location":"zh/MATH/USAGE/usage/","title":"\u4f7f\u7528\u8bf4\u660e","text":"<p>\u4f7f\u7528\u8bf4\u660e</p> <p>\u8be5\u6587\u6863\u662f\u5bf9 <code>tiny_math</code> \u6a21\u5757\u7684\u4f7f\u7528\u8bf4\u660e\u3002</p>"},{"location":"zh/MATH/USAGE/usage/#tinymath","title":"\u6574\u4f53\u5f15\u5165TinyMath","text":"<p>Info</p> <p>\u9002\u7528\u4e8eC\u9879\u76ee\uff0c\u6216\u8005\u7ed3\u6784\u8f83\u4e3a\u7b80\u5355\u7684C++\u9879\u76ee\u3002</p> <pre><code>#include \"tiny_math.h\"\n</code></pre>"},{"location":"zh/MATH/USAGE/usage/#tinymath_1","title":"\u5206\u6a21\u5757\u5f15\u5165TinyMath","text":"<p>Info</p> <p>\u9002\u7528\u4e8e\u9700\u8981\u7cbe\u786e\u63a7\u5236\u5f15\u5165\u6a21\u5757\u7684\u9879\u76ee\uff0c\u6216\u8005\u590d\u6742\u7684C++\u9879\u76ee\u3002</p> <pre><code>#include \"tiny_vec.h\" // \u5f15\u5165\u5411\u91cf\u6a21\u5757\n#include \"tiny_mat.h\" // \u5f15\u5165\u77e9\u9635\u6a21\u5757\n</code></pre> <pre><code>#include \"tiny_matrix.hpp\" // \u5f15\u5165\u9ad8\u7ea7\u77e9\u9635\u6a21\u5757\n</code></pre> <p>\u6ce8\u610f</p> <ul> <li> <p><code>tiny_vec.h</code> \u548c <code>tiny_mat.h</code> \u662f C \u8bed\u8a00\u7248\u672c\u7684\u5934\u6587\u4ef6\uff0c\u9002\u7528\u4e8e C \u8bed\u8a00\u7f16\u7a0b\u3002</p> </li> <li> <p><code>tiny_matrix.hpp</code> \u662f C++ \u8bed\u8a00\u7248\u672c\u7684\u5934\u6587\u4ef6\uff0c\u9002\u7528\u4e8e C++ \u8bed\u8a00\u7f16\u7a0b\u3002</p> </li> </ul> <p>\u7b80\u5355\u6765\u8bf4\uff0cC\u8bed\u8a00\u9879\u76ee\u53ea\u80fd\u7528 <code>tiny_vec.h</code> \u548c <code>tiny_mat.h</code>\uff0c\u800c C++ \u9879\u76ee\u53ef\u4ee5\u4f7f\u7528 <code>tiny_vec.h</code>\u3001<code>tiny_mat.h</code> \u548c <code>tiny_matrix.hpp</code>\u3002</p>"},{"location":"zh/MATH/VECTOR/api/","title":"\u5411\u91cf\u64cd\u4f5c","text":""},{"location":"zh/MATH/VECTOR/api/#_2","title":"\u76ee\u5f55","text":"<pre><code>// Addition\ntiny_error_t tiny_vec_add_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_addc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n// Subtraction\ntiny_error_t tiny_vec_sub_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_subc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n// Multiplication\ntiny_error_t tiny_vec_mul_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_mulc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n// Division\ntiny_error_t tiny_vec_div_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out, bool allow_divide_by_zero);\ntiny_error_t tiny_vec_divc_f32(const float *input, float *output, int len, float C, int step_in, int step_out, bool allow_divide_by_zero);\n// Square root\ntiny_error_t tiny_vec_sqrt_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_sqrtf_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_inv_sqrt_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_inv_sqrtf_f32(const float *input, float *output, int len);\n// Dot product\ntiny_error_t tiny_vec_dotprod_f32(const float *src1, const float *src2, float *dest, int len);\ntiny_error_t tiny_vec_dotprode_f32(const float *src1, const float *src2, float *dest, int len, int step1, int step2);\n</code></pre>"},{"location":"zh/MATH/VECTOR/api/#_3","title":"\u52a0\u6cd5","text":""},{"location":"zh/MATH/VECTOR/api/#_4","title":"\u4e24\u4e2a\u5411\u91cf\u7684\u52a0\u6cd5","text":"<p><pre><code>tiny_error_t tiny_vec_add_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\n</code></pre> \u529f\u80fd\uff1a \u8ba1\u7b97\u4e24\u4e2a\u5411\u91cf\u7684\u9010\u5143\u7d20\u52a0\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input1</code>\uff1a\u6307\u5411\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>input2</code>\uff1a\u6307\u5411\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>step1</code>\uff1a\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step2</code>\uff1a\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_5","title":"\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u52a0\u6cd5","text":"<p><pre><code>tiny_error_t tiny_vec_addc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n</code></pre> \u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u9010\u5143\u7d20\u52a0\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>C</code>\uff1a\u5e38\u6570\u503c\u3002</li> <li><code>step_in</code>\uff1a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_6","title":"\u51cf\u6cd5","text":""},{"location":"zh/MATH/VECTOR/api/#_7","title":"\u4e24\u4e2a\u5411\u91cf\u7684\u51cf\u6cd5","text":"<pre><code>tiny_error_t tiny_vec_sub_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u4e24\u4e2a\u5411\u91cf\u7684\u9010\u5143\u7d20\u51cf\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input1</code>\uff1a\u6307\u5411\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>input2</code>\uff1a\u6307\u5411\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>step1</code>\uff1a\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step2</code>\uff1a\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_8","title":"\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u51cf\u6cd5","text":"<pre><code>tiny_error_t tiny_vec_subc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u9010\u5143\u7d20\u51cf\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>C</code>\uff1a\u5e38\u6570\u503c\u3002</li> <li><code>step_in</code>\uff1a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_9","title":"\u4e58\u6cd5","text":""},{"location":"zh/MATH/VECTOR/api/#_10","title":"\u4e24\u4e2a\u5411\u91cf\u7684\u4e58\u6cd5","text":"<pre><code>tiny_error_t tiny_vec_mul_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u4e24\u4e2a\u5411\u91cf\u7684\u9010\u5143\u7d20\u4e58\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input1</code>\uff1a\u6307\u5411\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>input2</code>\uff1a\u6307\u5411\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>step1</code>\uff1a\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step2</code>\uff1a\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_11","title":"\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u4e58\u6cd5","text":"<pre><code>tiny_error_t tiny_vec_mulc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u9010\u5143\u7d20\u4e58\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>C</code>\uff1a\u5e38\u6570\u503c\u3002</li> <li><code>step_in</code>\uff1a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_12","title":"\u9664\u6cd5","text":""},{"location":"zh/MATH/VECTOR/api/#_13","title":"\u4e24\u4e2a\u5411\u91cf\u7684\u9664\u6cd5","text":"<pre><code>tiny_error_t tiny_vec_div_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out, bool allow_divide_by_zero);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u4e24\u4e2a\u5411\u91cf\u7684\u9010\u5143\u7d20\u9664\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input1</code>\uff1a\u6307\u5411\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>input2</code>\uff1a\u6307\u5411\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>step1</code>\uff1a\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step2</code>\uff1a\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>allow_divide_by_zero</code>\uff1a\u5e03\u5c14\u503c\uff0c\u6307\u793a\u662f\u5426\u5141\u8bb8\u9664\u4ee5\u96f6\u7684\u64cd\u4f5c\u3002</li> </ul>"},{"location":"zh/MATH/VECTOR/api/#_14","title":"\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u9664\u6cd5","text":"<pre><code>tiny_error_t tiny_vec_divc_f32(const float *input, float *output, int len, float C, int step_in, int step_out, bool allow_divide_by_zero);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u9010\u5143\u7d20\u9664\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>C</code>\uff1a\u5e38\u6570\u503c\u3002</li> <li><code>step_in</code>\uff1a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>allow_divide_by_zero</code>\uff1a\u5e03\u5c14\u503c\uff0c\u6307\u793a\u662f\u5426\u5141\u8bb8\u9664\u4ee5\u96f6\u7684\u64cd\u4f5c\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_15","title":"\u5e73\u65b9\u6839","text":""},{"location":"zh/MATH/VECTOR/api/#_16","title":"\u5411\u91cf\u7684\u5e73\u65b9\u6839","text":"<pre><code>tiny_error_t tiny_vec_sqrt_f32(const float *input, float *output, int len);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u7684\u9010\u5143\u7d20\u5e73\u65b9\u6839\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_17","title":"\u5411\u91cf\u7684\u5e73\u65b9\u6839\uff08\u5feb\u901f\uff09","text":"<pre><code>tiny_error_t tiny_vec_sqrtf_f32(const float *input, float *output, int len);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u7684\u9010\u5143\u7d20\u5e73\u65b9\u6839\uff08\u5feb\u901f\u7248\u672c\uff09\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_18","title":"\u5411\u91cf\u7684\u5e73\u65b9\u6839\u5012\u6570","text":"<pre><code>tiny_error_t tiny_vec_inv_sqrt_f32(const float *input, float *output, int len);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u7684\u9010\u5143\u7d20\u5e73\u65b9\u6839\u5012\u6570\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_19","title":"\u5411\u91cf\u7684\u5e73\u65b9\u6839\u5012\u6570\uff08\u5feb\u901f\uff09","text":"<pre><code>tiny_error_t tiny_vec_inv_sqrtf_f32(const float *input, float *output, int len);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u7684\u9010\u5143\u7d20\u5e73\u65b9\u6839\u5012\u6570\uff08\u5feb\u901f\u7248\u672c\uff09\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_20","title":"\u70b9\u79ef","text":""},{"location":"zh/MATH/VECTOR/api/#_21","title":"\u5411\u91cf\u7684\u70b9\u79ef","text":"<pre><code>tiny_error_t tiny_vec_dotprod_f32(const float *src1, const float *src2, float *dest, int len);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u4e24\u4e2a\u5411\u91cf\u7684\u70b9\u79ef\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>src1</code>\uff1a\u6307\u5411\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>src2</code>\uff1a\u6307\u5411\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>dest</code>\uff1a\u6307\u5411\u8f93\u51fa\u7ed3\u679c\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_22","title":"\u5411\u91cf\u7684\u70b9\u79ef\uff08\u5e26\u6b65\u957f\uff09","text":"<pre><code>tiny_error_t tiny_vec_dotprode_f32(const float *src1, const float *src2, float *dest, int len, int step1, int step2);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u4e24\u4e2a\u5411\u91cf\u7684\u70b9\u79ef\uff08\u5e26\u6b65\u957f\uff09\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>src1</code>\uff1a\u6307\u5411\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>src2</code>\uff1a\u6307\u5411\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>dest</code>\uff1a\u6307\u5411\u8f93\u51fa\u7ed3\u679c\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>step1</code>\uff1a\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step2</code>\uff1a\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/code/","title":"\u4ee3\u7801","text":""},{"location":"zh/MATH/VECTOR/test/","title":"\u5411\u91cf\u64cd\u4f5c\u6d4b\u8bd5","text":"<p>\u5411\u91cf\u64cd\u4f5c\u6d4b\u8bd5</p> <p>\u8be5\u6d4b\u8bd5\u7528\u4e8e\u6d4b\u8bd5\u5411\u91cf\u76f8\u5173\u51fd\u6570\u7684\u6027\u80fd\u3002</p>"},{"location":"zh/MATH/VECTOR/test/#_2","title":"\u6d4b\u8bd5\u4ee3\u7801","text":""},{"location":"zh/MATH/VECTOR/test/#_3","title":"\u6d4b\u8bd5\u7ed3\u679c","text":""},{"location":"zh/MEASUREMENT/code/","title":"\u4ee3\u7801","text":"<p>\u6ce8\u610f</p> <p>\u4ee5\u4e0b\u4ee3\u7801\u5e94\u4ee5\u53d1\u5e03\u4ee3\u7801\u4e2d\u7684\u4ee3\u7801\u4e3a\u51c6\uff0c\u53ef\u80fd\u4f1a\u6709\u66f4\u65b0\u3002</p>"},{"location":"zh/MEASUREMENT/log/","title":"\u5f00\u53d1\u65e5\u5fd7","text":"<p>2025-04-03</p> <ul> <li>\u91c7\u6837\u914d\u7f6e\u7ed3\u6784\u4f53</li> <li>\u91c7\u6837\u6570\u636e\u7ed3\u6784\u4f53</li> <li>\u5b9e\u65f6\u91c7\u6837\u51fd\u6570/\u5e38\u89c4\u91c7\u6837\u51fd\u6570</li> <li>\u91c7\u6837\u9891\u7387\u9891\u7387\u4e0a\u9650\u6d4b\u8bd5\uff1a\u5b9e\u65f6\uff0825Hz-\u672c\u5730\u8f93\u51fa+MQTT;200Hz-\u4ec5MQTT\uff09\uff1b\u5e38\u89c4 \uff08500Hz\uff09</li> <li>\u670d\u52a1\u7aef\u53ef\u89c6\u5316\u7a0b\u5e8f</li> <li>\u670d\u52a1\u7aef\u6570\u636e\u5b58\u50a8</li> </ul>"},{"location":"zh/MEASUREMENT/measurement/","title":"\u6d4b\u91cf","text":"<p>\u5173\u4e8e\u6d4b\u91cf</p> <p>\u9ad8\u8d28\u91cf\u6d4b\u91cf/\u91c7\u6837\u662f\u6570\u636e\u5206\u6790\u7684\u57fa\u7840\uff0cTinySHM\u5728\u8bbe\u8ba1\u65f6\u5145\u5206\u8003\u8651\u4e86\u8fd9\u4e00\u70b9\u3002\u6211\u4eec\u5728TinySHM\u4e2d\u5b9e\u73b0\u4e86\u591a\u79cd\u6d4b\u91cf/\u91c7\u6837\u65b9\u6cd5\uff0c\u7528\u6237\u53ef\u4ee5\u6839\u636e\u81ea\u5df1\u7684\u9700\u6c42\u8fdb\u884c\u9009\u62e9\u3002</p> <p>Warning</p> <p>\u76ee\u524d\u5f00\u53d1\u4ee5ESP32\u4e3a\u57fa\u7840\uff0c\u5411STM32\u7b49\u5e73\u53f0\u7684\u8fc1\u79fb\u9700\u8981\u5bf9\u9002\u914d\u5c42\u8fdb\u884c\u4e00\u5b9a\u7684\u4fee\u6539\u3002</p>"},{"location":"zh/MEASUREMENT/notes/","title":"\u8bf4\u660e","text":""},{"location":"zh/MEASUREMENT/notes/#_2","title":"\u4f9d\u8d56","text":"<p>SYSTEM</p> <pre><code>#include \"esp_system.h\" // ESP32 System\n#include \"esp_log.h\"    // ESP32 Logging\n</code></pre> <p>RTOS</p> <pre><code>#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/event_groups.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/timers.h\"\n#include \"freertos/semphr.h\"\n</code></pre> <p>BSP</p> <pre><code>#include \"driver/gptimer.h\"\n#include \"led.h\"\n#include \"lcd.h\"\n#include \"tim.h\"\n#include \"esp_rtc.h\"\n#include \"spi_sdcard.h\"\n#include \"wifi_wpa2_enterprise.h\"\n#include \"mqtt.h\"\n#include \"mpu6050.h\"\n</code></pre> <p>TinyAuton/TinySHM</p> <pre><code>#include \"TinyAdapter.h\"\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_3","title":"\u91c7\u6837\u914d\u7f6e\u7ed3\u6784\u4f53","text":"<p>\u5b9a\u4e49</p> <pre><code>struct SenseConfig\n{\n    int sample_rate;\n    int sample_duration;\n    bool temperature_sense; // whether to sense temperature\n    bool printout;          // not recommened for high sample rate as it will slow down the process\n    bool mqtt_pub;          // not recommened for high sample rate as it will slow down the process\n};\n</code></pre> <p>\u4f7f\u7528 - \u5b9e\u65f6</p> <pre><code>// for streamline configuration\nstruct SenseConfig streamline_config = {\n    .sample_rate = 1,          // Sample rate in Hz. For local printout + mqtt, at most 25Hz; for only mqtt, at most 200Hz.\n    .temperature_sense = true, // Whether to sense temperature\n    .printout = true,          // Only available for sampling rate &lt;= 100Hz\n    .mqtt_pub = true           // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre> <p>\u4f7f\u7528 - \u5e38\u89c4\u91c7\u6837</p> <pre><code>// for sensing configuration\nstruct SenseConfig sense_config = {\n    .sample_rate = 500,   // Sample rate in Hz, only can be (1, 2, 5, 10, 20, 25, 50, 100, 200, 500) for FreeRTOS based sensing. Note can not be 1000Hz (no time to feed the watchdog).\n    .sample_duration = 1, // Sample duration in seconds\n    .printout = true      // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_4","title":"\u91c7\u6837\u6570\u636e\u7ed3\u6784\u4f53","text":"<pre><code>struct DataStruct\n{\n    int sample_rate;\n    int sample_duration;\n    float sensor_temperature;\n    TinyTimeMark_t start_time_stamp;\n    TinyTimeMark_t *time_stamp;\n    float *acc_data;\n    float *temperature;\n};\n</code></pre> <p>\u4f7f\u7528</p> <pre><code>// for data structure\nstruct DataStruct data_struct = {\n    .sample_rate = 0,     // Sample rate in Hz\n    .sample_duration = 0, // Sample duration in seconds\n    .sensor_temperature = 0.0,\n    .start_time_stamp = 0,\n    .acc_data = NULL}; \n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_5","title":"\u91c7\u6837\u539f\u7406","text":"<p>\u76ee\u524d\u91c7\u6837**\u57fa\u4e8eFreeRTOS\u5faa\u73af**\u800c\u975e\u57fa\u4e8e**\u5b9a\u65f6\u5668\u4e2d\u65ad**\uff0c\u5b9e\u73b0\u7b80\u5355\uff0c\u672a\u6765\u6216\u8bb8\u4f1a\u6dfb\u52a0\u5b9a\u65f6\u5668\u4e2d\u65ad\u91c7\u6837\u7684\u65b9\u5f0f\u3002</p>"},{"location":"zh/MEASUREMENT/notes/#_6","title":"\u91c7\u6837\u6a21\u5f0f\u4e0e\u91c7\u6837\u4efb\u52a1","text":"<p>\u76ee\u524d\u5171\u6709\u4e24\u79cd\u91c7\u6837\u6a21\u5f0f\uff1a - \u5b9e\u65f6\u91c7\u6837 - \u5e38\u89c4\u91c7\u6837</p>"},{"location":"zh/MEASUREMENT/notes/#_7","title":"\u5b9e\u65f6\u91c7\u6837","text":"<p>\u91c7\u6837\u4efb\u52a1\u5b9a\u4e49</p> <pre><code>/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters)\n{\n\n    // streamline variables\n    float acc_x, acc_y, acc_z, temperature;\n    TinyTimeMark_t time_stamp;\n\n    // MQTT publish buffer\n    char streamline_buff[256];\n\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n\n    if (config-&gt;sample_rate &gt; 100 &amp;&amp; config-&gt;printout)\n    {\n        ESP_LOGW(TAG, \"Printout is disabled for sample rate &gt; 100Hz.\");\n        config-&gt;printout = false;\n    }\n\n    while (1)\n    {\n        // get the time stamp\n        time_stamp = tiny_get_running_time();\n\n        // get accelerometer data\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        acc_x = acce.acce_x;\n        acc_y = acce.acce_y;\n        acc_z = acce.acce_z;\n\n        // get temperature\n        mpu6050_get_temp(mpu6050, &amp;temp);\n        temperature = temp.temp;\n\n        // sprintf\n        if (config-&gt;printout || config-&gt;mqtt_pub)\n        {\n            snprintf(streamline_buff, sizeof(streamline_buff), \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Sensor Temperature: %4.2f \u00b0C\", time_stamp, acc_x, acc_y, acc_z, temperature);\n        }\n\n        // print out the data - comment out for higher sample rate\n        if (config-&gt;printout)\n        {\n            ESP_LOGI(TAG, \"%s\", streamline_buff);\n        }\n\n        // MQTT publish\n        if (config-&gt;mqtt_pub)\n        {\n            esp_mqtt_client_publish(s_mqtt_client, MQTT_PUBLIC_TOPIC, streamline_buff, strlen(streamline_buff), 0, 0); // for streamline, data quality is not expected to be high, so QoS = 0; data retaintion is also not required, so 0.\n        }\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n    ESP_LOGI(TAG, \"Streamline terminated. Task will delete itself.\");\n    vTaskDelete(NULL);\n}\n</code></pre> <p>\u91c7\u6837\u4efb\u52a1\u4f7f\u7528: \u5728\u5e94\u7528\u7a0b\u5e8f\u90e8\u5206\u521b\u5efa\u4efb\u52a1\u5373\u53ef</p> <pre><code>xTaskCreate(acc_streamline_task, \"Accel_Streamline_Task\", 4096, &amp;streamline_config, 5, NULL);\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_8","title":"\u5e38\u89c4\u91c7\u6837","text":"<p>\u91c7\u6837\u4efb\u52a1\u5b9a\u4e49</p> <pre><code>/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters)\n{\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n    int total_samples = config-&gt;sample_rate * config-&gt;sample_duration;\n\n    // Fill global data_struct\n    data_struct.sample_rate = config-&gt;sample_rate;\n    data_struct.sample_duration = config-&gt;sample_duration;\n    mpu6050_get_temp(mpu6050, &amp;temp);\n    data_struct.sensor_temperature = temp.temp;\n    data_struct.start_time_stamp = tiny_get_running_time();\n\n    // Allocate memory\n    data_struct.acc_data = malloc(sizeof(float) * 3 * total_samples);\n    data_struct.temperature = malloc(sizeof(float) * total_samples);\n    data_struct.time_stamp = malloc(sizeof(TinyTimeMark_t) * total_samples);\n\n    if (data_struct.acc_data == NULL || data_struct.temperature == NULL || data_struct.time_stamp == NULL)\n    {\n        ESP_LOGE(TAG, \"Failed to allocate memory for sensing data.\");\n        if (data_struct.acc_data)\n            free(data_struct.acc_data);\n        if (data_struct.temperature)\n            free(data_struct.temperature);\n        if (data_struct.time_stamp)\n            free(data_struct.time_stamp);\n        vTaskDelete(NULL);\n    }\n\n    ESP_LOGI(TAG, \"Sampling started: %d Hz for %d seconds (%d samples)\",\n             config-&gt;sample_rate, config-&gt;sample_duration, total_samples);\n\n    for (int i = 0; i &lt; total_samples; i++)\n    {\n        TinyTimeMark_t now = tiny_get_running_time();\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        mpu6050_get_temp(mpu6050, &amp;temp);\n\n        // Store data\n        data_struct.time_stamp[i] = now;\n        data_struct.acc_data[i * 3 + 0] = acce.acce_x;\n        data_struct.acc_data[i * 3 + 1] = acce.acce_y;\n        data_struct.acc_data[i * 3 + 2] = acce.acce_z;\n        data_struct.temperature[i] = temp.temp;\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n\n    ESP_LOGI(TAG, \"Sampling complete.\");\n\n    // Print metadata\n    ESP_LOGI(TAG, \"-----------------------------\");\n    ESP_LOGI(TAG, \"Sensor Temperature : %.2f \u00b0C\", data_struct.sensor_temperature);\n    ESP_LOGI(TAG, \"Start Time Stamp   : %ld\", (long)data_struct.start_time_stamp);\n    ESP_LOGI(TAG, \"Sample Rate        : %d Hz\", data_struct.sample_rate);\n    ESP_LOGI(TAG, \"Sample Duration    : %d sec\", data_struct.sample_duration);\n    ESP_LOGI(TAG, \"Total Samples      : %d\", total_samples);\n    ESP_LOGI(TAG, \"Data Size          : %.2f KB\",\n             (sizeof(float) * 4 + sizeof(TinyTimeMark_t)) * total_samples / 1024.0f);\n    ESP_LOGI(TAG, \"-----------------------------\");\n\n    // Print collected data if enabled\n    if (config-&gt;printout)\n    {\n        for (int i = 0; i &lt; total_samples; i++)\n        {\n            ESP_LOGI(TAG, \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Temperature: %.2f \u00b0C\",\n                     (long)data_struct.time_stamp[i],\n                     data_struct.acc_data[i * 3 + 0],\n                     data_struct.acc_data[i * 3 + 1],\n                     data_struct.acc_data[i * 3 + 2],\n                     data_struct.temperature[i]);\n\n            // Release CPU for a short time to avoid blocking\n            if ((i % 10) == 0)\n            {\n                vTaskDelay(pdMS_TO_TICKS(10));\n            }\n        }\n    }\n\n    // Free allocated memory\n    if (data_struct.acc_data)\n    {\n        free(data_struct.acc_data);\n        data_struct.acc_data = NULL;\n    }\n    if (data_struct.temperature)\n    {\n        free(data_struct.temperature);\n        data_struct.temperature = NULL;\n    }\n    if (data_struct.time_stamp)\n    {\n        free(data_struct.time_stamp);\n        data_struct.time_stamp = NULL;\n    }\n\n    vTaskDelete(NULL);\n}\n</code></pre> <p>\u91c7\u6837\u4efb\u52a1\u4f7f\u7528: \u5728\u5e94\u7528\u7a0b\u5e8f\u90e8\u5206\u521b\u5efa\u4efb\u52a1\u5373\u53ef</p> <pre><code>xTaskCreate(acc_sense_task, \"Accel_Sense_Task\", 8192, &amp;sense_config, 5, NULL);\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_9","title":"\u5f85\u5f00\u53d1","text":"<ul> <li>\u6807\u51c6\u65f6\u95f4\u6233</li> <li>\u6821\u51c6</li> <li>\u5b9a\u65f6\u5668+\u4e2d\u65ad</li> <li>DMA</li> <li>ADC+\u6a21\u62df</li> <li>\u6570\u636e\u540e\u5904\u7406</li> <li>\u6279\u91cf\u6570\u636eMQTT\u4e0a\u4f20</li> <li>\u5b9e\u65f6\u5904\u7406\u529f\u80fd\u5f00\u53d1</li> </ul>"},{"location":"zh/RELEASES/releases/","title":"\u53d1\u5e03","text":""},{"location":"zh/RELEASES/releases/#dnesp32s3m-stable","title":"DNESP32S3M-STABLE","text":"<p>\u7a33\u5b9a\u7248</p>"},{"location":"zh/RELEASES/releases/#dnesp32s3m-latest","title":"DNESP32S3M-LATEST","text":"<p>\u6700\u65b0\u529f\u80fd\u7248</p>"},{"location":"zh/TOOLBOX/toolbox/","title":"\u5de5\u5177\u7bb1","text":"<p>tiny_toolbox</p> <p>\u5de5\u5177\u7bb1tiny_toolbox\u5b9a\u4f4d\u662f\u7528\u4e8e \u5e73\u53f0\u9002\u914d\u4e0e\u4f18\u5316 \u5e76\u63d0\u4f9b \u5404\u79cd\u5b9e\u7528\u5de5\u5177 \u7684\u5e93\uff0c\u670d\u52a1\u4e8e\u8fb9\u7f18\u8ba1\u7b97\u4e0e\u5e94\u7528\u5f00\u53d1\u3002\u6ce8\u610f\uff0c\u4e4b\u6240\u4ee5\u5c06\u9002\u914d\u548c\u5de5\u5177\u653e\u5728\u4e00\u4e2a\u5e93\u91cc\u9762\uff0c\u662f\u56e0\u4e3a\u5f88\u591a\u5de5\u5177\u5e95\u5c42\u5229\u7528\u7684\u662f\u5e73\u53f0\u63d0\u4f9b\u7684\u529f\u80fd\uff0c\u6240\u4ee5\u5c06\u5e73\u53f0\u9002\u914d\u548c\u5404\u7c7b\u5de5\u5177\u653e\u5728\u540c\u4e00\u4e2a\u5e93\u91cc\u9762\uff0c\u4fbf\u4e8e\u4f7f\u7528\u548c\u7ef4\u62a4\u3002</p> <p>Warning</p> <p>\u76ee\u524d\u5f00\u53d1\u4ee5ESP32\u4e3a\u57fa\u7840\uff0c\u5411STM32\u7b49\u5e73\u53f0\u7684\u8fc1\u79fb\u9700\u8981\u5bf9\u9002\u914d\u5c42\u8fdb\u884c\u4e00\u5b9a\u7684\u4fee\u6539\u3002</p>"},{"location":"zh/TOOLBOX/toolbox/#_2","title":"\u7ec4\u4ef6\u4f9d\u8d56","text":"<pre><code>set(src_dirs\n    .\n    time\n)\n\nset(include_dirs\n    .\n    time\n)\n\nset(requires\n    esp_timer\n    esp_rtc\n    espressif__esp-dsp\n    espressif__esp_jpeg\n    espressif__esp-dl\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"zh/TOOLBOX/toolbox/#_3","title":"\u67b6\u6784\u4e0e\u529f\u80fd\u76ee\u5f55","text":"<pre><code>    tiny_toolbox\n    \u251c\u2500\u2500 CMakeLists.txt\n    \u251c\u2500\u2500 tiny_toolbox.h // serves as a directory, integrating all submodules\n    \u251c\u2500\u2500 time\n    \u2502   \u251c\u2500\u2500 tiny_time.h // submodule for time management - header file\n    \u2502   \u251c\u2500\u2500 tiny_time.c // submodule for time management - source file\n    \u2502   \u2514\u2500\u2500 ...\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"zh/TOOLBOX/toolbox/#_4","title":"\u65f6\u95f4","text":"<ul> <li>\u83b7\u53d6\u8fd0\u884c\u65f6\u95f4\uff1a <code>tiny_get_running_time()</code></li> <li>SNTP\u5bf9\u65f6\uff1a <code>sync_time_with_timezone(\"CST-8\")</code></li> <li>\u83b7\u53d6\u4e16\u754c\u65f6\u95f4\uff1a <code>tiny_get_current_time(1)</code></li> </ul> <p>\u5f85\u5f00\u53d1:</p> <ul> <li>\u65e0\u7ebf\u4f20\u611f\u5668\u7f51\u7edc\u672c\u5730\u5bf9\u65f6-\u5fae\u79d2\u7ea7\u522b</li> </ul>"},{"location":"zh/TOOLBOX/toolbox/#_5","title":"\u4ee3\u7801","text":"<p>Tip</p> <p>tiny_toolbox.h \u53ea\u662f\u4f5c\u4e3a\u4e00\u4e2a\u76ee\u5f55\uff0c\u96c6\u6210\u4e86\u6240\u6709\u7684\u5b50\u6a21\u5757\uff0c\u5177\u4f53\u7684\u529f\u80fd\u5728\u5404\u4e2a\u5b50\u6a21\u5757\u4e2d\u5b9e\u73b0\u3002tiny_toolbox.c \u53ea\u662f\u5f62\u5f0f\u4e0a\u7684\u6e90\u6587\u4ef6\uff0c\u6ca1\u6709\u5177\u4f53\u7684\u529f\u80fd\u3002</p>"},{"location":"zh/TOOLBOX/TIME/log/","title":"LOG","text":"<p>2025-04-10</p> <ul> <li>\u83b7\u53d6\u8fd0\u884c\u65f6\u95f4\uff1a <code>tiny_get_running_time()</code></li> <li>SNTP\u5bf9\u65f6\uff1a <code>sync_time_with_timezone(\"CST-8\")</code></li> <li>\u83b7\u53d6\u4e16\u754c\u65f6\u95f4\uff1a <code>tiny_get_current_time(1)</code></li> </ul> <p>\u5f85\u5f00\u53d1:</p> <ul> <li>\u65e0\u7ebf\u4f20\u611f\u5668\u7f51\u7edc\u672c\u5730\u5bf9\u65f6-\u5fae\u79d2\u7ea7\u522b</li> </ul>"},{"location":"zh/TOOLBOX/TIME/notes/","title":"\u65f6\u95f4","text":"<p>\u65f6\u95f4</p> <p>\u65f6\u95f4\u76f8\u5173\u7684\u529f\u80fd\u5bf9\u4e8eMCU\u6765\u8bf4\u975e\u5e38\u91cd\u8981\uff0c\u672c\u8282\u63d0\u4f9b\u4e00\u7cfb\u5217\u65f6\u95f4\u76f8\u5173\u7684\u5b9a\u4e49\u548c\u51fd\u6570\uff0c\u4f9b\u5f00\u53d1\u8005\u4f7f\u7528\u3002</p> <p>MCU\u4e2d\u7684\u65f6\u95f4\u53ef\u4ee5\u5206\u4ee5\u4e0b\u51e0\u79cd\u7c7b\u578b\uff1a</p> <ul> <li> <p>\u8fd0\u884c\u65f6\u95f4\uff1a \u6307\u7684\u662fMCU\u4ece\u4e0a\u7535\u5230\u73b0\u5728\u7684\u65f6\u95f4\u3002</p> </li> <li> <p>\u4e16\u754c\u65f6\u95f4\uff1a \u6307\u7684\u662fMCU\u6240\u5728\u7684\u65f6\u533a\u7684\u65f6\u95f4\u3002\u4e16\u754c\u65f6\u95f4\u53ef\u4ee5\u901a\u8fc7\u6807\u51c6\u7684\u5e74\u6708\u65e5\u65f6\u5206\u79d2\u6765\u8868\u793a\uff0c\u4e5f\u53ef\u4ee5\u8868\u793a\u4e3aUNIX\u65f6\u95f4\u6233\u3002</p> </li> </ul>"},{"location":"zh/TOOLBOX/TIME/notes/#_2","title":"\u8fd0\u884c\u65f6\u95f4","text":"<p>ESP\u6709\u81ea\u5df1\u7684\u83b7\u53d6\u8fd0\u884c\u65f6\u95f4\u7684\u51fd\u6570<code>esp_timer_get_time</code>\uff0c\u4f9d\u8d56\u4e8e<code>esp_timer</code>\u5e93\u3002\u8be5\u51fd\u6570\u8fd4\u56de\u4ece\u4e0a\u7535\u5230\u73b0\u5728\u7684\u65f6\u95f4\uff0c\u5355\u4f4d\u4e3a\u5fae\u79d2\u3002</p> <p>\u4e3a\u4e86\u65b9\u4fbf\u4f7f\u7528\uff0cTinyToolbox\u91cd\u65b0\u5b9a\u4e49\u4e86\u6570\u636e\u7c7b\u578b<code>TinyTimeMark_t</code>\uff0c\u5e76\u63d0\u4f9b\u4e86\u4e00\u4e2a\u51fd\u6570<code>tiny_get_running_time</code>\u6765\u83b7\u53d6\u8fd0\u884c\u65f6\u95f4\u3002\u8be5\u51fd\u6570\u8fd4\u56de\u7684\u65f6\u95f4\u5355\u4f4d\u4e3aTickType_t\uff0cTickType_t\u662fFreeRTOS\u4e2d\u5b9a\u4e49\u7684\u65f6\u95f4\u5355\u4f4d\u3002</p> <pre><code>typedef TickType_t TinyTimeMark_t;\n</code></pre> <pre><code>/**\n * @brief Get the running time in microseconds\n * @return TinyTimeMark_t\n */\nTinyTimeMark_t tiny_get_running_time(void)\n{\n    return esp_timer_get_time();\n}\n</code></pre> <p>\u4f7f\u7528\u53c2\u8003\uff1a</p> <pre><code>void app_main(void)\n{\n    // Get running time\n    TinyTimeMark_t running_time = tiny_get_running_time();\n    ESP_LOGI(TAG_TIME, \"Running Time: %lld us\", running_time);\n}\n</code></pre>"},{"location":"zh/TOOLBOX/TIME/notes/#_3","title":"\u4e16\u754c\u65f6\u95f4","text":"<p>Warning</p> <p>\u6ce8\u610f\uff0c\u83b7\u53d6\u4e16\u754c\u65f6\u95f4\u9700\u8981\u5efa\u7acb\u5728\u5df2\u7ecf\u8054\u7f51\u7684\u57fa\u7840\u4e0a\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u83b7\u53d6\u4e16\u754c\u65f6\u95f4\u7684\u51fd\u6570\u9700\u8981\u5728\u8054\u7f51\u6210\u529f\u540e\u8c03\u7528\u3002</p>"},{"location":"zh/TOOLBOX/TIME/notes/#ntp","title":"NTP\u5bf9\u65f6","text":"<p>NTP\u5bf9\u65f6</p> <p>NTP\uff08Network Time Protocol\uff09\u662f\u7f51\u7edc\u65f6\u95f4\u534f\u8bae\u7684\u7f29\u5199\uff0c\u662f\u4e00\u79cd\u7528\u4e8e\u5728\u8ba1\u7b97\u673a\u7f51\u7edc\u4e2d\u540c\u6b65\u65f6\u95f4\u7684\u534f\u8bae\u3002\u5b83\u53ef\u4ee5\u901a\u8fc7\u4e92\u8054\u7f51\u6216\u5c40\u57df\u7f51\u83b7\u53d6\u51c6\u786e\u7684\u65f6\u95f4\u4fe1\u606f\u3002 NTP\u534f\u8bae\u4f7f\u7528UDP\u534f\u8bae\u8fdb\u884c\u901a\u4fe1\uff0c\u9ed8\u8ba4\u4f7f\u7528123\u7aef\u53e3\u3002NTP\u670d\u52a1\u5668\u4f1a\u5b9a\u671f\u5411\u5ba2\u6237\u7aef\u53d1\u9001\u65f6\u95f4\u4fe1\u606f\uff0c\u5ba2\u6237\u7aef\u6839\u636e\u8fd9\u4e9b\u4fe1\u606f\u6765\u6821\u6b63\u81ea\u5df1\u7684\u7cfb\u7edf\u65f6\u95f4\u3002</p> <pre><code>   Client                      Server\n     |-------------------&gt;      |     T1\uff1a\u8bf7\u6c42\u53d1\u51fa\n     |                          |\n     |         &lt;--------------- |     T2/T3\uff1a\u670d\u52a1\u5668\u6536\u5230 &amp; \u56de\u590d\n     |                          |\n     |-------------------&gt;      |     T4\uff1a\u5ba2\u6237\u7aef\u6536\u5230\u54cd\u5e94\n</code></pre> <p>NTP\u5bf9\u65f6\u539f\u7406</p> <p>NTP\u5bf9\u65f6\u662f\u57fa\u4e8e\u56db\u4e2a\u65f6\u95f4\u6233\uff1a1. \u5ba2\u6237\u7aef\u53d1\u9001\u8bf7\u6c42\u65f6\u7684\u65f6\u95f4\u6233T1 2. \u670d\u52a1\u5668\u63a5\u6536\u5230\u8bf7\u6c42\u65f6\u7684\u65f6\u95f4\u6233T2 3. \u670d\u52a1\u5668\u53d1\u9001\u54cd\u5e94\u65f6\u7684\u65f6\u95f4\u6233T3 4. \u5ba2\u6237\u7aef\u63a5\u6536\u5230\u54cd\u5e94\u65f6\u7684\u65f6\u95f4\u6233T4\u3002\u6839\u636e\u8fd9\u56db\u4e2a\u65f6\u95f4\u6233\uff0c\u53ef\u4ee5\u8ba1\u7b97 \u7f51\u7edc\u5ef6\u8fdf Delay = (T4 - T1) - (T3 - T2)\uff0c\u4ee5\u53ca \u65f6\u95f4\u504f\u79fb Offset = ((T2 - T1) + (T3 - T4)) / 2\u3002</p> <p>ESP32 SNTP\u5bf9\u65f6</p> <p>ESP32\u4e2d\u4f7f\u7528\u7684\u662fSNTP\uff0c\u4e5f\u5c31\u662fSimple Network Time Protocol\u3002SNTP\u662fNTP\u7684\u7b80\u5316\u7248\uff0c\u9002\u7528\u4e8e\u5bf9\u65f6\u95f4\u7cbe\u5ea6\u8981\u6c42\u4e0d\u9ad8\u7684\u573a\u666f\u3002ESP32\u4e2d\u5bf9\u65f6\u4f9d\u8d56\u4e8e<code>esp_sntp</code>\u5e93\u3002SNTP\u7684\u5de5\u4f5c\u539f\u7406\u4e0eNTP\u7c7b\u4f3c\uff0c\u4f46SNTP\u7684\u5b9e\u73b0\u76f8\u5bf9\u7b80\u5355\uff0c\u9002\u5408\u5d4c\u5165\u5f0f\u8bbe\u5907\u4f7f\u7528\u3002\u5176\u7cbe\u5ea6\u901a\u5e38\u5728ms\u7ea7\u522b\uff0c\u9002\u7528\u4e8e\u5927\u591a\u6570\u5e94\u7528\u573a\u666f\u3002</p> <p>\u9996\u5148\u5b9a\u4e49\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff0c\u7528\u4e8e\u63a5\u6536\u5bf9\u65f6\u901a\u77e5\uff1a</p> <p><pre><code>/* WORLD CURRENT TIME - SNTP */\n/**\n * @brief Callback function for time synchronization notification\n * @param tv Pointer to the timeval structure containing the synchronized time\n * @return None\n */\nvoid time_sync_notification_cb(struct timeval *tv)\n{\n    ESP_LOGI(TAG_SNTP, \"Time synchronized!\");\n}\n</code></pre> \u63a5\u4e0b\u6765\u662fSNTP\u7684\u521d\u59cb\u5316\u51fd\u6570\uff0c\u4e5f\u662f\u5bf9\u65f6\u7684\u6838\u5fc3\u51fd\u6570\uff0c\u901a\u5e38\u5728\u7cfb\u7edf\u521d\u59cb\u5316\u65f6\uff0c\u5b8c\u6210\u8054\u7f51\u540e\u8c03\u7528\u3002\u6ce8\u610f\u5176\u4e2d\u7684\u5bf9\u65f6\u670d\u52a1\u5668\u5730\u5740\u53ef\u4ee5\u6839\u636e\u9700\u8981\u8fdb\u884c\u4fee\u6539\u3002\u5bf9\u65f6\u5b8c\u6210\u540e\uff0cESP32\u4f1a\u5728\u5e95\u5c42\u5bf9\u672c\u673a\u65f6\u95f4\u8fdb\u884c\u8bbe\u7f6e\u3002</p> <pre><code>/**\n * @brief Initialize SNTP\n * @return None\n */\nvoid initialize_sntp(void)\n{\n    ESP_LOGI(TAG_SNTP, \"Initializing SNTP\");\n    sntp_setoperatingmode(SNTP_OPMODE_POLL);\n    sntp_setservername(0, \"pool.ntp.org\"); // NTP server // pool.ntp.org // ntp.aliyun.com\n    sntp_set_time_sync_notification_cb(time_sync_notification_cb);\n    sntp_init();\n}\n</code></pre> <p>\u518d\u63a5\u4e0b\u6765\u662f\u5bf9\u4ee5\u4e0a\u51fd\u6570\u7684\u8fdb\u4e00\u6b65\u5c01\u88c5\uff0c\u5305\u542b\u4e86\u65f6\u533a\u8bbe\u7f6e\u3002\u6ce8\u610f\u4ee5\u4e0b\u51fd\u6570\u4e2d\u5305\u62ec\u4e86\u5bf9RTC\u7684\u8bbe\u7f6e<code>rtc_set_time</code>\uff0c\u4f9d\u8d56\u4e8edriver\u5c42\u7684RTC\u9a71\u52a8\u3002\u6b64\u5904\u4f7f\u7528\u7684\u662f\u6211\u81ea\u5b9a\u4e49\u7684rtc\u9a71\u52a8\uff0c\u82e5\u6ca1\u6709\u76f8\u5173\u529f\u80fd\u53ef\u4ee5\u76f4\u63a5\u6ce8\u91ca\u6389\u3002</p> <pre><code>/**\n * @brief Obtain the current time with timezone\n * @param timezone_str Timezone string (e.g., \"CST-8\")\n * @note The timezone string should be in the format \"TZ=GMT+/-HH:MM\"\n * @note To use this function, in application, after internet connection, insert \"sync_time_with_timezone(\"CST-8\");\" will do\n * @return None\n */\nvoid sync_time_with_timezone(const char *timezone_str)\n{\n    // Set system timezone\n    setenv(\"TZ\", timezone_str, 1);\n    tzset();\n\n    // Initialize SNTP and start time sync\n    initialize_sntp();\n\n    // Wait for system time to be set\n    time_t now = 0;\n    struct tm timeinfo = { 0 };\n    int retry = 0;\n    const int retry_count = 15;\n\n    while (timeinfo.tm_year &lt; (2020 - 1900) &amp;&amp; ++retry &lt; retry_count) {\n        ESP_LOGI(TAG_SNTP, \"Waiting for system time to be set... (%d/%d)\", retry, retry_count);\n        vTaskDelay(2000 / portTICK_PERIOD_MS);\n        time(&amp;now);\n        localtime_r(&amp;now, &amp;timeinfo);\n    }\n\n    if (timeinfo.tm_year &gt;= (2020 - 1900)) {\n        rtc_set_time(timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday,\n                    timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec); // defined in esp_rtc.c\n        ESP_LOGI(TAG_SNTP, \"System time is set.\");\n    } else {\n        ESP_LOGW(TAG_SNTP, \"Failed to sync time.\");\n        return;\n    }\n\n    // Log current local time\n    ESP_LOGI(TAG_SNTP, \"Current time: %s\", asctime(&amp;timeinfo));\n\n    // vTaskDelay(10000 / portTICK_PERIOD_MS); // Wait for 10 second\n    // rtc_get_time(); // uncomment to check the RTC time\n    // ESP_LOGI(TAG_SNTP, \"Current RTC time: %04d-%02d-%02d %02d:%02d:%02d\",\n    //          calendar.year, calendar.month, calendar.date,\n    //          calendar.hour, calendar.min, calendar.sec); // uncomment to check the RTC time\n\n}\n</code></pre>"},{"location":"zh/TOOLBOX/TIME/notes/#_4","title":"\u4e16\u754c\u65f6\u95f4\u83b7\u53d6","text":"<p>\u4e3a\u4e86\u65b9\u4fbf\u4e16\u754c\u65f6\u95f4\u7684\u83b7\u53d6\uff0c\u6211\u4eec\u9996\u5148\u5b9a\u4e49\u4e86\u4e00\u4e2a\u6570\u636e\u7ed3\u6784<code>DateTime_t</code>\uff0c\u7528\u4e8e\u5b58\u50a8\u5e74\u6708\u65e5\u65f6\u5206\u79d2\u7b49\u4fe1\u606f\u3002\u7136\u540e\u5b9a\u4e49\u4e86\u4e00\u4e2a\u51fd\u6570<code>tiny_get_current_time</code>\uff0c\u7528\u4e8e\u83b7\u53d6\u5f53\u524d\u7684\u4e16\u754c\u65f6\u95f4\u3002\u8be5\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a<code>DateTime_t</code>\u7ed3\u6784\u4f53\uff0c\u5305\u542b\u4e86\u5f53\u524d\u7684\u5e74\u6708\u65e5\u65f6\u5206\u79d2\u7b49\u4fe1\u606f\u3002\u5728\u4f7f\u7528\u65f6\uff0c\u4f20\u5165\u4e00\u4e2a\u5e03\u5c14\u503c<code>print_flag</code>\uff0c\u7528\u4e8e\u63a7\u5236\u662f\u5426\u6253\u5370\u5f53\u524d\u65f6\u95f4\u3002</p> <pre><code>/**\n * @brief Structure to hold date and time\n */\ntypedef struct TinyDateTime_t\n{\n    int year;\n    int month;\n    int day;\n    int hour;\n    int minute;\n    int second;\n    long microsecond;\n} TinyDateTime_t; \n</code></pre> <p><pre><code>/* WORLD CURRENT TIME - GET TIME */\n/**\n * @name tiny_get_current_time\n * @brief Get the current time as a TinyDateTime_t struct\n * @param print_flag Flag to indicate whether to print the time\n * @return TinyDateTime_t structure containing the current date and time\n */\nTinyDateTime_t tiny_get_current_time(bool print_flag)\n{\n    struct timeval tv;\n    gettimeofday(&amp;tv, NULL);  // Get current time (seconds + microseconds)\n\n    time_t now = tv.tv_sec;\n    struct tm timeinfo;\n    localtime_r(&amp;now, &amp;timeinfo);  // Convert to local time\n\n    TinyDateTime_t result;\n    result.year   = timeinfo.tm_year + 1900;\n    result.month  = timeinfo.tm_mon + 1;\n    result.day    = timeinfo.tm_mday;\n    result.hour   = timeinfo.tm_hour;\n    result.minute = timeinfo.tm_min;\n    result.second = timeinfo.tm_sec;\n    result.microsecond = tv.tv_usec;\n\n    if (print_flag)\n    {\n        ESP_LOGI(TAG_TIME, \"Current Time: %04d-%02d-%02d %02d:%02d:%02d.%06ld\",\n                 result.year, result.month, result.day,\n                 result.hour, result.minute, result.second, tv.tv_usec);\n    }\n\n    return result;\n}\n</code></pre> \u4f7f\u7528\u53c2\u8003\uff1a</p> <pre><code>void app_main(void)\n{\n    // Initialize SNTP and sync time\n    sync_time_with_timezone(\"CST-8\");\n\n    // Get current time\n    TinyDateTime_t current_time = tiny_get_current_time(true);\n\n    // Print current time\n    ESP_LOGI(TAG_TIME, \"Current Time: %04d-%02d-%02d %02d:%02d:%02d.%06ld\",\n             current_time.year, current_time.month, current_time.day,\n             current_time.hour, current_time.minute, current_time.second, current_time.microsecond);\n}\n</code></pre> <p>\u4f7f\u7528\u6548\u679c\uff1a</p> <p></p> <p>Danger</p> <p>SNTP\u7684\u5bf9\u65f6\u7cbe\u5ea6\u5728 ms \u6c34\u5e73\u3002</p>"}]}