{"config":{"lang":["en","zh"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TinySHM: Microcontroller-oriented Distributed Intelligence Enabling Framework for Structural Health Monitoring","text":""},{"location":"#project-overview","title":"PROJECT OVERVIEW","text":"<p>This project aims to develop an empowering framework that equips MCU-level IoT devices with distributed computing and intelligence capabilities to facilitate structural health monitoring applications. If you think this project is interesting, please give it a star and stay tuned.</p> <p>TinySHM</p> <p>\"TinySHM\" is a combination of \"Tiny\" and \"SHM\". \"Tiny\" means the codes are designed to run on MCU devices, while \"SHM\" stands for \"Structural Health Monitoring\".</p>"},{"location":"#target-hardware","title":"TARGET HARDWARE","text":"<ul> <li>MCU devices (currently targeting ESP32 as the main platform)</li> </ul>"},{"location":"#scope","title":"SCOPE","text":"<ul> <li>Platform adaptation and various tools (time, communication, etc.)</li> <li>Basic Math Operations</li> <li>Digital Signal Processing</li> <li>TinyML / Edge AI</li> <li>Measurement</li> <li>System Identification</li> <li>Damage Monitoring, Localization, and Assessment</li> </ul>"},{"location":"#host-devkits","title":"HOST DEVKITS","text":"<p>Tip</p> <p>The following hardwares are for demonstration purposes only. This project is not limited to these and can be ported to other types of hardwares.</p> <ul> <li>DNESP32S3M from Alientek (ESP32-S3)</li> </ul> <ul> <li> <p> NexNode</p> <p>  Repo </p> <p>  Online Doc </p> </li> </ul>"},{"location":"#project-architecture","title":"PROJECT ARCHITECTURE","text":"<pre><code>+------------------------------+\n|   - damage_detection         | &lt;-- damage detection, localization, and assessment\n|   - system_identification    | &lt;-- system identification\n|   - measurement              | &lt;-- measurement / sensing\n| APPLICATION                  |\n+------------------------------+\n|   - TinyAI                   | &lt;-- AI Functions\n|   - TinyDSP                  | &lt;-- DSP Functions\n|   - TinyMath                 | &lt;-- Common Math Functions\n|   - TinyToolbox              | &lt;-- Platform-specific Low-level Optimization + Various Utilities\n| MIDDLEWARE                   |\n+------------------------------+\n| DRIVERS                      |\n+------------------------------+\n| HARDWARE                     |\n+------------------------------+\n</code></pre>"},{"location":"ABOUT/about/","title":"TinySHM: Microcontroller-oriented Distributed Intelligence Enabling Framework for Structural Health Monitoring","text":""},{"location":"ABOUT/about/#project-overview","title":"PROJECT OVERVIEW","text":"<p>This project aims to develop an empowering framework that equips MCU-level IoT devices with distributed computing and intelligence capabilities to facilitate structural health monitoring applications. If you think this project is interesting, please give it a star and stay tuned.</p> <p>TinySHM</p> <p>\"TinySHM\" is a combination of \"Tiny\" and \"SHM\". \"Tiny\" means the codes are designed to run on MCU devices, while \"SHM\" stands for \"Structural Health Monitoring\".</p>"},{"location":"ABOUT/about/#target-hardware","title":"TARGET HARDWARE","text":"<ul> <li>MCU devices (currently targeting ESP32 as the main platform)</li> </ul>"},{"location":"ABOUT/about/#scope","title":"SCOPE","text":"<ul> <li>Platform adaptation and various tools (time, communication, etc.)</li> <li>Basic Math Operations</li> <li>Digital Signal Processing</li> <li>TinyML / Edge AI</li> <li>Measurement</li> <li>System Identification</li> <li>Damage Monitoring, Localization, and Assessment</li> </ul>"},{"location":"ABOUT/about/#host-devkits","title":"HOST DEVKITS","text":"<p>Tip</p> <p>The following hardwares are for demonstration purposes only. This project is not limited to these and can be ported to other types of hardwares.</p> <ul> <li>DNESP32S3M from Alientek (ESP32-S3)</li> </ul> <p></p> <p></p> <ul> <li> <p> NexNode</p> <p>  Repo </p> <p>  Online Doc </p> </li> </ul>"},{"location":"ABOUT/about/#project-architecture","title":"PROJECT ARCHITECTURE","text":"<pre><code>+------------------------------+\n|   - damage_detection         | &lt;-- damage detection, localization, and assessment\n|   - system_identification    | &lt;-- system identification\n|   - measurement              | &lt;-- measurement / sensing\n| APPLICATION                  |\n+------------------------------+\n|   - TinyAI                   | &lt;-- AI Functions\n|   - TinyDSP                  | &lt;-- DSP Functions\n|   - TinyMath                 | &lt;-- Common Math Functions\n|   - TinyToolbox              | &lt;-- Platform-specific Low-level Optimization + Various Utilities\n| MIDDLEWARE                   |\n+------------------------------+\n| DRIVERS                      |\n+------------------------------+\n| HARDWARE                     |\n+------------------------------+\n</code></pre>"},{"location":"ABOUT/about/#dev-schedule","title":"DEV SCHEDULE","text":"<p>\u2705 - Finished</p> <p>\ud83c\udfd7\ufe0f - Ongoing</p> <p>\ud83d\udcc6 - In Plan</p> <pre><code>&lt;tiny_toolbox&gt;\n- time \u2705\n- command \ud83d\udcc6\n\n&lt;tiny_math&gt;\n- vector \u2705\n- matrix \u2705\n\n&lt;tiny_dsp&gt;\n- signal \ud83c\udfd7\ufe0f\n    - convolution \u2705\n    - correlation \u2705\n- filter \ud83d\udcc6\n- transform \ud83d\udcc6\n- support \ud83d\udcc6\n\n&lt;tiny_ai&gt;\n</code></pre>"},{"location":"AI/ai/","title":"ARTIFICIAL INTELLIGENCE","text":"<ul> <li> <p> ESP-DL</p> <p>  Online Doc </p> </li> </ul>"},{"location":"DSP/dsp/","title":"DIGITAL SIGNAL PROCESSING","text":"<p>Note</p> <p>This component provides a set of functions designed for signal processing on edge devices, with a focus on lightweight and efficient implementations of commonly used signal processing algorithms.</p> <p>Note</p> <p>This component is a wrapper and extension of the official ESP32 digital signal processing library ESP-DSP, providing higher-level API interfaces. In simple terms, the TinyMath library corresponds to the Math, Matrix, and DotProduct modules in ESP-DSP, while the other modules in ESP-DSP correspond to the TinyDSP library. Additionally, TinyDSP provides some functionalities not available in ESP-DSP, focusing on scenarios such as structural health monitoring.</p>"},{"location":"DSP/dsp/#component-dependencies","title":"COMPONENT DEPENDENCIES","text":"<pre><code>set(src_dirs\n    .\n    signal\n    filter\n    transform\n    support\n)\n\nset(include_dirs\n    .\n    include\n    signal\n    filter\n    transform\n    support\n)\n\nset(requires\n    tiny_math\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"DSP/dsp/#architecture-and-directory","title":"ARCHITECTURE AND DIRECTORY","text":""},{"location":"DSP/dsp/#dependency-diagram","title":"Dependency Diagram","text":""},{"location":"DSP/dsp/#code-tree","title":"Code Tree","text":"<pre><code>tiny_dsp/\n\u251c\u2500\u2500 include/                     \n\u2502   \u251c\u2500\u2500 tiny_dsp.h               # entrance header file\n\u2502   \u2514\u2500\u2500 tiny_dsp_config.h        # dsp module configuration file\n\u2502\n\u251c\u2500\u2500 signal/\n\u2502   \u251c\u2500\u2500 tiny_conv.h              # convolution - header file\n\u2502   \u251c\u2500\u2500 tiny_conv.c              # convolution - source file\n\u2502   \u251c\u2500\u2500 tiny_corr.h              # correlation - header file\n\u2502   \u2514\u2500\u2500 tiny_corr.c              # correlation - source file\n\u2502\n\u251c\u2500\u2500 filter/\n\u2502\n\u251c\u2500\u2500 transform/\n\u2502\n\u2514\u2500\u2500 support/\n</code></pre>"},{"location":"DSP/HEADER-FILE/tiny_dsp/","title":"TinyDSP HEADER FILE","text":"<p>Info</p> <p>This is the main header file of the TinyDSP library. It includes all necessary header files and provides a unified interface to use the functions of the library. After completing the porting of this library in the project, you can insert this header file where you want to use the relevant functions to use all functions in the library. The documentation update speed is slow and may not be consistent with the actual code, please refer to the actual code.</p> <pre><code>/**\n * @file tiny_dsp.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief tiny_dsp | entrance file\n * @version 1.0\n * @date 2025-04-28\n * @copyright Copyright (c) 2025\n *\n */\n\n#pragma once\n\n/* DEPENDENCIES */\n\n// tiny_dsp configuration file\n#include \"tiny_dsp_config.h\"\n\n// [signal]\n\n// signal - tiny_conv\n#include \"tiny_conv.h\"\n#include \"tiny_conv_test.h\"\n\n// signal - correlation &amp; crosss correlation\n#include \"tiny_corr.h\"\n#include \"tiny_corr_test.h\"\n\n// [filter]\n\n// [transform]\n\n// [support]\n\n\n\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>"},{"location":"DSP/HEADER-FILE/tiny_dsp_config/","title":"TinyDSP CONFIGURATION","text":"<p>Info</p> <p>This header file configures the entire TinyDSP module, and each submodule includes this header file. It defines the configuration options and macros for TinyDSP, allowing users to customize settings as needed. By modifying the configuration options in this header file, users can easily adjust the behavior and functionality of TinyDSP to meet specific requirements. The documentation update speed is slow and may not be consistent with the actual code, please refer to the actual code.</p> <p>Tip</p> <p>For platform acceleration options, please set them in the TinyMath configuration file.</p> <pre><code>/**\n * @file tiny_dsp_config.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief The configuration file for the tiny_dsp middleware.\n * @version 1.0\n * @date 2025-04-27\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_DSPP_CONFIG__\n#define __TINY_DSPP_CONFIG__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* DEPENDENCIES */\n#include \"tiny_math.h\"\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_DSPP_CONFIG__ */\n</code></pre>"},{"location":"DSP/SIGNAL/CONVOLUTION/code/","title":"CODE","text":""},{"location":"DSP/SIGNAL/CONVOLUTION/code/#tiny_convh","title":"tiny_conv.h","text":"<pre><code>/**\n * @file tiny_conv.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief tiny_conv | code | header \n * @version 1.0\n * @date 2025-04-27\n * @copyright Copyright (c) 2025\n *\n */\n\n#pragma once\n\n/* DEPENDENCIES */\n// tiny_dsp configuration file\n#include \"tiny_dsp_config.h\"\n\n// ESP32 DSP Library for Acceleration\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32 // ESP32 DSP library\n\n#include \"dsps_conv.h\"\n#include \"dspi_conv.h\"\n\n#endif\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/**\n * @name: tiny_conv_f32\n * @brief Convolution function\n * \n * @param Signal The input signal array\n * @param siglen The length of the input signal array\n * @param Kernel The input kernel array\n * @param kernlen The length of the input kernel array\n * @param convout The output array for the convolution result\n * \n * @return tiny_error_t \n */\ntiny_error_t tiny_conv_f32(const float *Signal, const int siglen, const float *Kernel, const int kernlen, float *convout);\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>"},{"location":"DSP/SIGNAL/CONVOLUTION/code/#tiny_convc","title":"tiny_conv.c","text":"<pre><code>/**\n * @file tiny_conv.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief tiny_conv | code | source\n * @version 1.0\n * @date 2025-04-27\n * @copyright Copyright (c) 2025\n *\n */\n\n/* DEPENDENCIES */\n#include \"tiny_conv.h\"\n\n/**\n * @name: tiny_conv_f32\n * @brief Convolution function\n * \n * @param Signal The input signal array\n * @param siglen The length of the input signal array\n * @param Kernel The input kernel array\n * @param kernlen The length of the input kernel array\n * @param convout The output array for the convolution result\n * \n * @return tiny_error_t \n */\ntiny_error_t tiny_conv_f32(const float *Signal, const int siglen, const float *Kernel, const int kernlen, float *convout)\n{\n    if (NULL == Signal || NULL == Kernel || NULL == convout)\n    {\n        return TINY_ERR_DSP_NULL_POINTER;\n    }\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // ESP32 DSP library\n    dsps_conv_f32(Signal, siglen, Kernel, kernlen, convout);\n#else\n    float *sig = (float *)Signal;\n    float *kern = (float *)Kernel;\n    int lsig = siglen;\n    int lkern = kernlen;\n\n    // swap the signal and kernel to ensure the signal is longer than the kernel\n    if (siglen &lt; kernlen)\n    {\n        sig = (float *)Kernel;\n        kern = (float *)Signal;\n        lsig = kernlen;\n        lkern = siglen;\n    }\n\n    // stage I\n    for (int n = 0; n &lt; lkern; n++)\n    {\n        size_t k;\n\n        convout[n] = 0;\n\n        for (k = 0; k &lt;= n; k++)\n        {\n            convout[n] += sig[k] * kern[n - k];\n        }\n    }\n\n    // stage II\n    for (int n = lkern; n &lt; lsig; n++)\n    {\n        size_t kmin, kmax, k;\n\n        convout[n] = 0;\n\n        kmin = n - lkern + 1;\n        kmax = n;\n        for (k = kmin; k &lt;= kmax; k++)\n        {\n            convout[n] += sig[k] * kern[n - k];\n        }\n    }\n\n    // stage III\n    for (int n = lsig; n &lt; lsig + lkern - 1; n++)\n    {\n        size_t kmin, kmax, k;\n\n        convout[n] = 0;\n\n        kmin = n - lkern + 1;\n        kmax = lsig - 1;\n        for (k = kmin; k &lt;= kmax; k++)\n        {\n            convout[n] += sig[k] * kern[n - k];\n        }\n    }\n#endif\n\n    return TINY_OK;\n}\n</code></pre>"},{"location":"DSP/SIGNAL/CONVOLUTION/notes/","title":"NOTES","text":""},{"location":"DSP/SIGNAL/CONVOLUTION/notes/#mathematical-principle-of-convolution","title":"Mathematical Principle of Convolution","text":"<p>Convolution is an important operation in signal processing, which is used to describe the relationship between two signals. It can be regarded as the weighted average of one signal and another signal. The mathematical definition of convolution is as follows:</p> \\[y(t) = \\int_{-\\infty}^{\\infty} x(\\tau) h(t - \\tau) d\\tau\\] <p>Where \\(x(t)\\) is the input signal, \\(h(t)\\) is the impulse response of the system, and \\(y(t)\\) is the output signal. The result of convolution is a new signal that contains all the information between the input signal and the impulse response of the system.</p> <p></p>"},{"location":"DSP/SIGNAL/CONVOLUTION/notes/#programming-philosophy","title":"Programming Philosophy","text":"<p>The convolution operation in this library actually reverses the direction of the convolution kernel and then multiplies it point by point with the input signal and sums it.</p>"},{"location":"DSP/SIGNAL/CONVOLUTION/notes/#tiny_conv_f32","title":"tiny_conv_f32","text":"<pre><code>/**\n * @name: tiny_conv_f32\n * @brief Convolution function\n * \n * @param Signal The input signal array\n * @param siglen The length of the input signal array\n * @param Kernel The input kernel array\n * @param kernlen The length of the input kernel array\n * @param convout The output array for the convolution result\n * \n * @return tiny_error_t \n */\ntiny_error_t tiny_conv_f32(const float *Signal, const int siglen, const float *Kernel, const int kernlen, float *convout)\n{\n    if (NULL == Signal || NULL == Kernel || NULL == convout)\n    {\n        return TINY_ERR_DSP_NULL_POINTER;\n    }\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // ESP32 DSP library\n    dsps_conv_f32(Signal, siglen, Kernel, kernlen, convout);\n#else\n    float *sig = (float *)Signal;\n    float *kern = (float *)Kernel;\n    int lsig = siglen;\n    int lkern = kernlen;\n\n    // swap the signal and kernel to ensure the signal is longer than the kernel\n    if (siglen &lt; kernlen)\n    {\n        sig = (float *)Kernel;\n        kern = (float *)Signal;\n        lsig = kernlen;\n        lkern = siglen;\n    }\n\n    // stage I\n    for (int n = 0; n &lt; lkern; n++)\n    {\n        size_t k;\n\n        convout[n] = 0;\n\n        for (k = 0; k &lt;= n; k++)\n        {\n            convout[n] += sig[k] * kern[n - k];\n        }\n    }\n\n    // stage II\n    for (int n = lkern; n &lt; lsig; n++)\n    {\n        size_t kmin, kmax, k;\n\n        convout[n] = 0;\n\n        kmin = n - lkern + 1;\n        kmax = n;\n        for (k = kmin; k &lt;= kmax; k++)\n        {\n            convout[n] += sig[k] * kern[n - k];\n        }\n    }\n\n    // stage III\n    for (int n = lsig; n &lt; lsig + lkern - 1; n++)\n    {\n        size_t kmin, kmax, k;\n\n        convout[n] = 0;\n\n        kmin = n - lkern + 1;\n        kmax = lsig - 1;\n        for (k = kmin; k &lt;= kmax; k++)\n        {\n            convout[n] += sig[k] * kern[n - k];\n        }\n    }\n#endif\n\n    return TINY_OK;\n}\n</code></pre> <p>Description: This function performs the convolution operation between the input signal and the kernel. It first checks whether the input parameters are <code>NULL</code>, and then selects either the ESP32 DSP library or a standard C implementation for the convolution calculation based on the platform. The function returns the convolution result.</p> <p>Features:</p> <ul> <li>Supports acceleration with the ESP32 DSP library.</li> <li>Supports swapping the signal and kernel to ensure the signal length is greater than the kernel length.</li> </ul> <p>Parameters:</p> <ul> <li><code>Signal</code>: Input signal array.</li> <li><code>siglen</code>: Length of the input signal array.</li> <li><code>Kernel</code>: Input kernel array.</li> <li><code>kernlen</code>: Length of the input kernel array.</li> <li><code>convout</code>: Output array to store the convolution result.</li> </ul> <p>Return Value:</p> <ul> <li><code>TINY_OK</code>: Convolution completed successfully.</li> <li><code>TINY_ERR_DSP_NULL_POINTER</code>: One or more input parameters are <code>NULL</code>.</li> </ul>"},{"location":"DSP/SIGNAL/CONVOLUTION/test/","title":"TESTS","text":""},{"location":"DSP/SIGNAL/CONVOLUTION/test/#tiny_conv_testh","title":"tiny_conv_test.h","text":"<pre><code>/**\n * @file tiny_conv_test.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief tiny_conv | test | header\n * @version 1.0\n * @date 2025-04-28\n * @copyright Copyright (c) 2025\n *\n */\n\n#pragma once\n\n/* DEPENDENCIES */\n// tiny_conv\n#include \"tiny_conv.h\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\nvoid tiny_signal_conv_test(void);\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>"},{"location":"DSP/SIGNAL/CONVOLUTION/test/#tiny_conv_testc","title":"tiny_conv_test.c","text":"<pre><code>/**\n * @file tiny_conv_test.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief tiny_conv | test | header\n * @version 1.0\n * @date 2025-04-28\n * @copyright Copyright (c) 2025\n *\n */\n\n/* DEPENDENCIES */\n// tiny_conv\n#include \"tiny_conv_test.h\"\n\nvoid tiny_signal_conv_test(void)\n{\n    // 1. definition\n    const float test_signal[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f};\n    const int siglen = sizeof(test_signal) / sizeof(test_signal[0]);\n\n    const float test_kernel[] = {0.5f, 1.0f};\n    const int kernlen = sizeof(test_kernel) / sizeof(test_kernel[0]);\n\n    // 2. compute output length\n    const int conv_len = siglen + kernlen - 1;\n    float conv_output[conv_len];\n\n    // 3. call the convolution function\n    tiny_error_t status = tiny_conv_f32(test_signal, siglen, test_kernel, kernlen, conv_output);\n\n    // 4. return status;\n    if (status != TINY_OK) {\n        printf(\"[Test Failed] tiny_conv_f32 returned error code: %d\\n\", status);\n        return;\n    }\n\n    // 5. printf(\"Convolution Test:\\n\");\n    printf(\"Convolution Output:\\n\");\n    for (int i = 0; i &lt; conv_len; i++) {\n        printf(\"  conv_output[%d] = %.3f\\n\", i, conv_output[i]);\n    }\n\n    // 6. verify the output\n    const float expected_output[] = {0.5f, 2.0f, 3.5f, 5.0f, 6.5f, 5.0f};\n    int pass = 1;\n    for (int i = 0; i &lt; conv_len; i++) {\n        if ( (conv_output[i] - expected_output[i]) &gt; 1e-5f || (conv_output[i] - expected_output[i]) &lt; -1e-5f ) {\n            pass = 0;\n            break;\n        }\n    }\n\n    if (pass) {\n        printf(\"[Test Passed] tiny_conv_f32 output matches expected results.\\n\");\n    } else {\n        printf(\"[Test Failed] tiny_conv_f32 output mismatch.\\n\");\n    }\n}\n</code></pre>"},{"location":"DSP/SIGNAL/CONVOLUTION/test/#test-results","title":"test results","text":"<pre><code>Convolution Output:\n  conv_output[0] = 0.500\n  conv_output[1] = 2.000\n  conv_output[2] = 3.500\n  conv_output[3] = 5.000\n  conv_output[4] = 6.500\n  conv_output[5] = 5.000\n[Test Passed] tiny_conv_f32 output matches expected results.\n</code></pre>"},{"location":"DSP/SIGNAL/CORRELATION/code/","title":"CODE","text":""},{"location":"DSP/SIGNAL/CORRELATION/code/#tiny_corrh","title":"tiny_corr.h","text":"<pre><code>/**\n * @file tiny_corr.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief tiny_corr | code | header\n * @version 1.0\n * @date 2025-04-27\n * @copyright Copyright (c) 2025\n *\n */\n\n#pragma once\n\n/* DEPENDENCIES */\n// tiny_dsp configuration file\n#include \"tiny_dsp_config.h\"\n\n// ESP32 DSP Library for Acceleration\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32 // ESP32 DSP library\n\n#include \"dsps_corr.h\"\n#include \"dsps_ccorr.h\"\n\n#endif\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n    /**\n     * @name: tiny_corr_f32\n     * @brief Correlation function\n     *\n     * @param Signal: input signal array\n     * @param siglen: length of the signal array\n     * @param Pattern: input pattern array\n     * @param patlen: length of the pattern array\n     * @param dest: output array for the correlation result\n     *\n     * @return tiny_error_t\n     */\n    tiny_error_t tiny_corr_f32(const float *Signal, const int siglen, const float *Pattern, const int patlen, float *dest);\n\n    /**\n     * @name: tiny_ccorr_f32\n     * @brief Cross-correlation function\n     *\n     * @param Signal: input signal array\n     * @param siglen: length of the signal array\n     * @param Kernel: input kernel array\n     * @param kernlen: length of the kernel array\n     * @param corrvout: output array for the cross-correlation result\n     *\n     * @return tiny_error_t\n     */\n    tiny_error_t tiny_ccorr_f32(const float *Signal, const int siglen, const float *Kernel, const int kernlen, float *corrvout);\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>"},{"location":"DSP/SIGNAL/CORRELATION/code/#tiny_corrc","title":"tiny_corr.c","text":"<pre><code>/**\n * @file tiny_corr.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief tiny_corr | code | source\n * @version 1.0\n * @date 2025-04-27\n * @copyright Copyright (c) 2025\n *\n */\n/* DEPENDENCIES */\n#include \"tiny_corr.h\"\n\n/**\n * @name: tiny_corr_f32\n * @brief Correlation function\n *\n * @param Signal: input signal array\n * @param siglen: length of the signal array\n * @param Pattern: input pattern array\n * @param patlen: length of the pattern array\n * @param dest: output array for the correlation result\n *\n * @return tiny_error_t\n */\ntiny_error_t tiny_corr_f32(const float *Signal, const int siglen, const float *Pattern, const int patlen, float *dest)\n{\n    if (NULL == Signal || NULL == Pattern || NULL == dest)\n    {\n        return TINY_ERR_DSP_NULL_POINTER;\n    }\n\n    if (siglen &lt; patlen) // signal length shoudl be greater than pattern length\n    {\n        return TINY_ERR_DSP_MISMATCH;\n    }\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    dsps_corr_f32(Signal, siglen, Pattern, patlen, dest);\n#else\n\n    for (size_t n = 0; n &lt;= (siglen - patlen); n++)\n    {\n        float k_corr = 0;\n        for (size_t m = 0; m &lt; patlen; m++)\n        {\n            k_corr += Signal[n + m] * Pattern[m];\n        }\n        dest[n] = k_corr;\n    }\n\n#endif\n\n    return TINY_OK;\n}\n\n/**\n * @name: tiny_ccorr_f32\n * @brief Cross-correlation function\n *\n * @param Signal: input signal array\n * @param siglen: length of the signal array\n * @param Kernel: input kernel array\n * @param kernlen: length of the kernel array\n * @param corrvout: output array for the cross-correlation result\n *\n * @return tiny_error_t\n */\ntiny_error_t tiny_ccorr_f32(const float *Signal, const int siglen, const float *Kernel, const int kernlen, float *corrvout)\n{\n    if (NULL == Signal || NULL == Kernel || NULL == corrvout)\n    {\n        return TINY_ERR_DSP_NULL_POINTER;\n    }\n\n    float *sig = (float *)Signal;\n    float *kern = (float *)Kernel;\n    int lsig = siglen;\n    int lkern = kernlen;\n\n    // swap signal and kernel if needed\n    if (siglen &lt; kernlen)\n    {\n        sig = (float *)Kernel;\n        kern = (float *)Signal;\n        lsig = kernlen;\n        lkern = siglen;\n    }\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    dsps_ccorr_f32(Signal, siglen, Kernel, kernlen, corrvout);\n#else\n    // stage I\n    for (int n = 0; n &lt; lkern; n++)\n    {\n        size_t k;\n        size_t kmin = lkern - 1 - n;\n        corrvout[n] = 0;\n\n        for (k = 0; k &lt;= n; k++)\n        {\n            corrvout[n] += sig[k] * kern[kmin + k];\n        }\n    }\n\n    // stage II\n    for (int n = lkern; n &lt; lsig; n++)\n    {\n        size_t kmin, kmax, k;\n\n        corrvout[n] = 0;\n\n        kmin = n - lkern + 1;\n        kmax = n;\n        for (k = kmin; k &lt;= kmax; k++)\n        {\n            corrvout[n] += sig[k] * kern[k - kmin];\n        }\n    }\n\n    // stage III\n    for (int n = lsig; n &lt; lsig + lkern - 1; n++)\n    {\n        size_t kmin, kmax, k;\n\n        corrvout[n] = 0;\n\n        kmin = n - lkern + 1;\n        kmax = lsig - 1;\n\n        for (k = kmin; k &lt;= kmax; k++)\n        {\n            corrvout[n] += sig[k] * kern[k - kmin];\n        }\n    }\n#endif\n    return TINY_OK;\n}\n</code></pre>"},{"location":"DSP/SIGNAL/CORRELATION/notes/","title":"NOTES","text":"<p>Note</p> <p>Correlation is an important concept in signal processing, often used to analyze similarities or dependencies between signals. It is useful in many applications, such as pattern recognition, time series analysis, and signal detection.</p>"},{"location":"DSP/SIGNAL/CORRELATION/notes/#correlation-function","title":"CORRELATION FUNCTION","text":""},{"location":"DSP/SIGNAL/CORRELATION/notes/#mathematical-principle","title":"Mathematical Principle","text":"<p>The correlation is computed as:</p> \\[ \\text{Correlation}[n] = \\sum_{m=0}^{L_p - 1} S[n + m] \\cdot P[m] \\] <p>Where:</p> <ul> <li> <p>\\( S \\) is the input signal of length \\( L_s \\)</p> </li> <li> <p>\\( P \\) is the pattern of length \\( L_p \\)</p> </li> <li> <p>\\( n \\in [0, L_s - L_p] \\)</p> </li> </ul> <p>Output Length:</p> \\[ L_{\\text{out}} = L_s - L_p + 1 \\]"},{"location":"DSP/SIGNAL/CORRELATION/notes/#tiny_corr_f32","title":"tiny_corr_f32","text":"<pre><code>/**\n * @name: tiny_corr_f32\n * @brief Correlation function\n *\n * @param Signal: input signal array\n * @param siglen: length of the signal array\n * @param Pattern: input pattern array\n * @param patlen: length of the pattern array\n * @param dest: output array for the correlation result\n *\n * @return tiny_error_t\n */\ntiny_error_t tiny_corr_f32(const float *Signal, const int siglen, const float *Pattern, const int patlen, float *dest)\n{\n    if (NULL == Signal || NULL == Pattern || NULL == dest)\n    {\n        return TINY_ERR_DSP_NULL_POINTER;\n    }\n\n    if (siglen &lt; patlen) // signal length shoudl be greater than pattern length\n    {\n        return TINY_ERR_DSP_MISMATCH;\n    }\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    dsps_corr_f32(Signal, siglen, Pattern, patlen, dest);\n#else\n\n    for (size_t n = 0; n &lt;= (siglen - patlen); n++)\n    {\n        float k_corr = 0;\n        for (size_t m = 0; m &lt; patlen; m++)\n        {\n            k_corr += Signal[n + m] * Pattern[m];\n        }\n        dest[n] = k_corr;\n    }\n\n#endif\n\n    return TINY_OK;\n}\n</code></pre> <p>Description: Computes the correlation between a signal and a pattern.</p> <p>Features:</p> <ul> <li>Platform-specific optimization enabled.</li> </ul> <p>Parameters:</p> <ul> <li> <p><code>Signal</code>: Pointer to the input signal array.</p> </li> <li> <p><code>siglen</code>: Length of the signal array.</p> </li> <li> <p><code>Pattern</code>: Pointer to the input pattern array.</p> </li> <li> <p><code>patlen</code>: Length of the pattern array.</p> </li> <li> <p><code>dest</code>: Pointer to the output array for the correlation result.</p> </li> </ul> <p>Return Value: Returns success or error code.</p>"},{"location":"DSP/SIGNAL/CORRELATION/notes/#cross-correlation-function","title":"CROSS-CORRELATION FUNCTION","text":""},{"location":"DSP/SIGNAL/CORRELATION/notes/#mathematical-principle_1","title":"Mathematical Principle","text":"<p>The cross-correlation is computed as:</p> \\[ R_{xy}[n] = \\sum_{k} x[k] \\cdot y[k + n] \\] <p>Where:</p> <ul> <li> <p>\\( x \\) is the signal of length \\( L_x \\)</p> </li> <li> <p>\\( y \\) is the kernel of length \\( L_y \\)</p> </li> <li> <p>\\( n \\in [0, L_x + L_y - 2] \\)</p> </li> </ul> <p>Output Length:</p> \\[ L_{\\text{out}} = L_x + L_y - 1 \\]"},{"location":"DSP/SIGNAL/CORRELATION/test/","title":"TESTS","text":""},{"location":"DSP/SIGNAL/CORRELATION/test/#tiny_corr_testh","title":"tiny_corr_test.h","text":"<pre><code>/**\n * @file tiny_corr_test.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief tiny_corr | test | header\n * @version 1.0\n * @date 2025-04-27\n * @copyright Copyright (c) 2025\n *\n */\n\n#pragma once\n\n/* DEPENDENCIES */\n#include \"tiny_corr.h\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\nvoid tiny_signal_corr_ccorr_test(void);\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>"},{"location":"DSP/SIGNAL/CORRELATION/test/#tiny_corr_testc","title":"tiny_corr_test.c","text":"<pre><code>/**\n * @file tiny_corr_test.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief tiny_corr | test | source\n * @version 1.0\n * @date 2025-04-27\n * @copyright Copyright (c) 2025\n *\n */\n\n/* DEPENDENCIES */\n#include \"tiny_corr_test.h\"\n\n#define EPSILON 1e-3f // Tolerance for floating-point comparison\n\n// Helper function to print float arrays\nstatic void print_float_array(const char *label, const float *array, int length) {\n    printf(\"%s: [\", label);\n    for (int i = 0; i &lt; length; i++) {\n        printf(\"%.2f\", array[i]);\n        if (i != length -1) {\n            printf(\", \");\n        }\n    }\n    printf(\"]\\n\");\n}\n\nvoid tiny_signal_corr_ccorr_test(void)\n{\n    printf(\"\\n========== Correlation &amp; Cross-Correlation Test ==========\\n\");\n\n    /*** Test 1: Correlation Function - tiny_corr_f32 ***/\n    const float signal[]  = {1.0f, 2.0f, 3.0f, 4.0f, 2.0f, 1.0f};\n    const float pattern[] = {2.0f, 1.0f, 0.0f};\n    const int siglen  = sizeof(signal) / sizeof(signal[0]);\n    const int patlen  = sizeof(pattern) / sizeof(pattern[0]);\n    const int corr_len = siglen - patlen + 1;\n\n    float corr_output[corr_len];\n    const float expected_corr[] = {4.0f, 7.0f, 10.0f, 10.0f};\n\n    printf(\"\\n--- Test 1: tiny_corr_f32 ---\\n\");\n    print_float_array(\"Input Signal \", signal, siglen);\n    print_float_array(\"Pattern      \", pattern, patlen);\n\n    tiny_error_t status_corr = tiny_corr_f32(signal, siglen, pattern, patlen, corr_output);\n\n    if (status_corr != TINY_OK) {\n        printf(\"[tiny_corr_f32 Test] Failed with error code: %d\\n\", status_corr);\n    } else {\n        printf(\"Output vs Expected:\\n\");\n        int pass = 1;\n        for (int i = 0; i &lt; corr_len; i++) {\n            printf(\"  [%d] Output = %.3f | Expected = %.3f\\n\", i, corr_output[i], expected_corr[i]);\n            if (fabs(corr_output[i] - expected_corr[i]) &gt; EPSILON) {\n                pass = 0;\n            }\n        }\n        printf(\"[tiny_corr_f32 Test] [%s]\\n\", pass ? \"PASS\" : \"FAIL\");\n    }\n\n    /*** Test 2: Cross-Correlation Function - tiny_ccorr_f32 ***/\n    const float x[] = {1.0f, 3.0f, 2.0f, 0.0f, 1.0f, 2.0f};\n    const float y[] = {2.0f, 1.0f, 0.0f, -1.0f};\n    const int len_x = sizeof(x) / sizeof(x[0]);\n    const int len_y = sizeof(y) / sizeof(y[0]);\n    const int ccorr_len = len_x + len_y - 1;\n\n    float ccorr_output[ccorr_len];\n    const float expected_ccorr[] = {-1.0f, -3.0f, -1.0f, 5.0f, 7.0f, 2.0f, 1.0f, 4.0f, 4.0f};\n\n    printf(\"\\n--- Test 2: tiny_ccorr_f32 ---\\n\");\n    print_float_array(\"Input Signal X\", x, len_x);\n    print_float_array(\"Input Signal Y\", y, len_y);\n\n    tiny_error_t status_ccorr = tiny_ccorr_f32(x, len_x, y, len_y, ccorr_output);\n\n    if (status_ccorr != TINY_OK) {\n        printf(\"[tiny_ccorr_f32 Test] Failed with error code: %d\\n\", status_ccorr);\n    } else {\n        printf(\"Output vs Expected:\\n\");\n        int pass = 1;\n        for (int i = 0; i &lt; ccorr_len; i++) {\n            printf(\"  [%d] Output = %.3f | Expected = %.3f\\n\", i, ccorr_output[i], expected_ccorr[i]);\n            if (fabs(ccorr_output[i] - expected_ccorr[i]) &gt; EPSILON) {\n                pass = 0;\n            }\n        }\n        printf(\"[tiny_ccorr_f32 Test] [%s]\\n\", pass ? \"PASS\" : \"FAIL\");\n    }\n\n    printf(\"==========================================================\\n\");\n}\n</code></pre>"},{"location":"DSP/SIGNAL/CORRELATION/test/#test-results","title":"TEST RESULTS","text":"<pre><code>========== Correlation &amp; Cross-Correlation Test ==========\n\n--- Test 1: tiny_corr_f32 ---\nInput Signal : [1.00, 2.00, 3.00, 4.00, 2.00, 1.00]\nPattern      : [2.00, 1.00, 0.00]\nOutput vs Expected:\n  [0] Output = 4.000 | Expected = 4.000\n  [1] Output = 7.000 | Expected = 7.000\n  [2] Output = 10.000 | Expected = 10.000\n  [3] Output = 10.000 | Expected = 10.000\n[tiny_corr_f32 Test] [PASS]\n\n--- Test 2: tiny_ccorr_f32 ---\nInput Signal X: [1.00, 3.00, 2.00, 0.00, 1.00, 2.00]\nInput Signal Y: [2.00, 1.00, 0.00, -1.00]\nOutput vs Expected:\n  [0] Output = -1.000 | Expected = -1.000\n  [1] Output = -3.000 | Expected = -3.000\n  [2] Output = -1.000 | Expected = -1.000\n  [3] Output = 5.000 | Expected = 5.000\n  [4] Output = 7.000 | Expected = 7.000\n  [5] Output = 2.000 | Expected = 2.000\n  [6] Output = 1.000 | Expected = 1.000\n  [7] Output = 4.000 | Expected = 4.000\n  [8] Output = 4.000 | Expected = 4.000\n[tiny_ccorr_f32 Test] [PASS]\n==========================================================\n</code></pre>"},{"location":"DSP/USAGE/usage/","title":"USAGE INSTRUCTIONS","text":"<p>Usage Instructions</p> <p>This document provides usage instructions for the <code>tiny_dsp</code> module. </p>"},{"location":"DSP/USAGE/usage/#import-tinymath-as-a-whole","title":"Import TinyMath as a Whole","text":"<p>Info</p> <p>Suitable for C projects or projects with a simple structure in C++.</p> <pre><code>#include \"tiny_dsp.h\"\n</code></pre>"},{"location":"DSP/USAGE/usage/#import-tinymath-by-module","title":"Import TinyMath by Module","text":"<p>Info</p> <p>Suitable for projects that require precise control over module imports or complex C++ projects.</p> <pre><code>#include \"tiny_conv.h\" // import convolution module\n#include \"tiny_corr.h\" // import correlation module\n...\n</code></pre> <p>Tip</p> <p>For specific usage methods, please refer to the test code.</p>"},{"location":"MATH/math/","title":"MATH OPERATIONS","text":"<p>Note</p> <p>This component is designed for mathematical operations. It is a lightweight library that provides basic mathematical functions to facilitate onboard computation and AI model inference. The library is designed to be lightweight and efficient, making it suitable for edge computing applications.</p> <p>Note</p> <p>This component is a wrapper and extension of the official ESP32 digital signal processing library ESP-DSP, providing higher-level API interfaces. In simple terms, the TinyMath library corresponds to the Math, Matrix, and DotProduct modules in ESP-DSP, while the other modules in ESP-DSP correspond to the TinyDSP library.</p>"},{"location":"MATH/math/#component-dependencies","title":"COMPONENT DEPENDENCIES","text":"<pre><code>set(src_dirs\n    .\n    vec\n    mat\n)\n\nset(include_dirs\n    .\n    include\n    vec\n    mat\n)\n\nset(requires\n    tiny_toolbox\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"MATH/math/#architecture-and-directory","title":"ARCHITECTURE AND DIRECTORY","text":""},{"location":"MATH/math/#dependency-diagram","title":"Dependency Diagram","text":""},{"location":"MATH/math/#code-tree","title":"Code Tree","text":"<pre><code>TinyMath\n    \u251c\u2500\u2500 CMakeLists.txt\n    \u251c\u2500\u2500 include\n    |   \u251c\u2500\u2500 tiny_error_type.h // error type header file\n    |   \u251c\u2500\u2500 tiny_constant.h // constant header file\n    |   \u251c\u2500\u2500 tiny_math_config.h // configuration header file\n    |   \u2514\u2500\u2500 tiny_math.h // main header file, include this file where you want to use the library\n    \u251c\u2500\u2500 vec\n    |   \u251c\u2500\u2500 tiny_vec.h // vector header file\n    |   \u251c\u2500\u2500 tiny_vec.c // vector source file\n    |   \u251c\u2500\u2500 tiny_vec_test.c // vector test file\n    |   \u2514\u2500\u2500 tiny_vec_test.h // vector test header file\n    \u251c\u2500\u2500 mat\n    |   \u251c\u2500\u2500 tiny_mat.h // matrix header file - c\n    |   \u251c\u2500\u2500 tiny_mat.c // matrix source file - c\n    |   \u251c\u2500\u2500 tiny_mat_test.c // matrix test file - c \n    |   \u251c\u2500\u2500 tiny_mat_test.h // matrix test header file - c\n    |   \u251c\u2500\u2500 tiny_matrix.hpp // matrix header file - cpp\n    |   \u251c\u2500\u2500 tiny_matrix.cpp // matrix source file - cpp\n    |   \u251c\u2500\u2500 tiny_matrix_test.cpp // matrix test file - cpp\n    |   \u2514\u2500\u2500 tiny_matrix_test.hpp // matrix test header file - cpp\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"MATH/ESP-DSP/esp-dsp/","title":"ESP-DSP","text":"<ul> <li> <p> ESP-DSP</p> <p>An Espressif DSP Library (esp-dsp) it\u2019s library of functions, modules and components that provides possibility to use Espressif\u2019s CPUs as DSPs in efficient way.</p> <p>  Online Doc </p> </li> </ul>"},{"location":"MATH/ESP-DSP/esp-dsp/#function-naming","title":"Function Naming","text":"<p>Naming conventions for the Library functions are similar for all covered domains. You can distinguish signal processing functions by the dsps prefix, while image and video processing functions have dspi prefix, and functions that are specific for operations on small matrices have dspm prefix in their names. Function names in Library have the following general format:</p> <pre><code>dsp&lt;data-domain&gt;_&lt;name&gt;_&lt;datatype1&gt;&lt;datatype_ext&gt;_&lt;datatype2&gt;&lt;datatype_ext&gt;[_&lt;descriptor&gt;]&lt;_impl&gt;(&lt;parameters&gt;);\n</code></pre> <p>Where:</p> <ul> <li> <p><code>&lt;data-domain&gt;</code> is the domain of the function, e.g. <code>s</code> for signal processing, <code>i</code> for image processing, <code>v</code> for video processing, and <code>m</code> for small matrix operations.</p> </li> <li> <p><code>&lt;name&gt;</code> is the name of the function.</p> </li> <li> <p><code>&lt;datatype1&gt;</code> is the type of the first input parameter.</p> </li> <li> <p><code>&lt;datatype_ext&gt;</code> is the type of the first input parameter extended with a suffix that indicates the type of the data, e.g. <code>f</code> for float, <code>i</code> for integer, <code>c</code> for complex, etc.</p> </li> <li> <p><code>&lt;datatype2&gt;</code> is the type of the second input parameter.</p> </li> <li> <p><code>&lt;descriptor&gt;</code> is an optional descriptor that provides additional information about the function.</p> </li> <li> <p><code>&lt;impl&gt;</code> is an optional implementation descriptor that provides additional information about the implementation of the function.</p> </li> <li> <p><code>&lt;parameters&gt;</code> are the parameters of the function.</p> </li> </ul>"},{"location":"MATH/ESP-DSP/esp-dsp/#data-domain","title":"Data Domain","text":"<p>The data-domain is a single character that expresses the subset of functionality to which a given function belongs. The Library designed to supports the following data-domains:</p> <ul> <li> <p>s - for signals (expected data type is a 1D signal)</p> </li> <li> <p>i - for images and video (expected data type is a 2D image)</p> </li> <li> <p>m - for matrices (expected data type is a matrix)</p> </li> <li> <p>r - for realistic rendering functionality and 3D data processing (expected data type depends on supported rendering techniques)</p> </li> <li> <p>q - for signals of fixed length</p> </li> </ul> <p>For example, function names that begin with dspi signify that respective functions are used for image or video processing.</p>"},{"location":"MATH/ESP-DSP/esp-dsp/#name","title":"Name","text":"<p>The name is an abbreviation for the core operation that the function really does, for example Add, Sqrt, followed in some cases by a function-specific modifier: = [_modifier]</p> <p>This modifier, if present, denotes a slight modification or variation of the given function.</p>"},{"location":"MATH/ESP-DSP/esp-dsp/#data-types","title":"Data Types","text":"<p>The library supports two main data types \u2013 int16 for fixed point arithmetic and float for floating point arithmetic. The datatype described as:</p>"},{"location":"MATH/ESP-DSP/esp-dsp/#data-type-suffices","title":"Data type suffices:","text":"<ul> <li> <p>s - signed</p> </li> <li> <p>u - unsigned</p> </li> <li> <p>f - float</p> </li> </ul>"},{"location":"MATH/ESP-DSP/esp-dsp/#data-type-extensions","title":"Data type extensions:","text":"<ul> <li>c - complex</li> </ul>"},{"location":"MATH/ESP-DSP/esp-dsp/#data-type-bits-resolution","title":"Data type Bits resolution:","text":"<ul> <li> <p>16</p> </li> <li> <p>32</p> </li> </ul> <p>For example: dsps_mac_sc16 defines that mac operation with 1d array will be made with 16 bit signed complex data.</p>"},{"location":"MATH/ESP-DSP/esp-dsp/#implementation-type","title":"Implementation Type","text":"<p>Each function could be implemented different for different platform and could use different style and resources. That\u2019s why every implemented function will have name extension &lt;_impl&gt; that will define which kind of implementation it is. User can use universal function without extension.</p>"},{"location":"MATH/ESP-DSP/esp-dsp/#implementation-extensions","title":"Implementation extensions:","text":"<p>By default all functions could be used without extensions. The option that select optimized/ansi can be chosen in menuconfig.</p> <p>Inside library the extensions means:</p> <ul> <li> <p>_ansi - a universal function where body of function implemented on ANSI C. This implementation not includes any hardware optimization</p> </li> <li> <p>_ae32 - written on ESP32 assembler and optimized for ESP32</p> </li> <li> <p>_aes3 - written on ESP32S3 assembler and optimized for ESP32S3</p> </li> <li> <p>_arp4 - written on ESP32P4 assembler and optimized for ESP32P4</p> </li> <li> <p>_platform - header file with definitions of available CPUs instructions for different functions</p> </li> <li> <p>others- depends on amount of supported CPUs. This list will be extended in future</p> </li> </ul>"},{"location":"MATH/ESP-DSP/examples/","title":"ESP-DSP EXAMPLES","text":""},{"location":"MATH/ESP-DSP/examples/#list-of-esp-dsp-examples","title":"List of esp-dsp Examples","text":"<p>Signal processing APIs use dsps prefix. The following modules are available:</p> <ul> <li> <p>Basic math - the example shows how to use basic vector math operations</p> </li> <li> <p>Dot-product - the example demonstrates how to use dot product functions</p> </li> <li> <p>FFT - the example demonstrates how to use FFT functionality</p> </li> <li> <p>FFT Window - the example demonstrates how to use Window and FFT functionality</p> </li> <li> <p>FFT 4 Real - the example demonstrates how to use FFT functionality for real input signals</p> </li> <li> <p>IIR - the example demonstrates how to use IIR filters functionality</p> </li> <li> <p>FIR - the example demonstrates how to use FIR filter functionality</p> </li> <li> <p>Kalman Filter - Extended Kalman Filter (EKF) example</p> </li> <li> <p>Matrix - example demonstrates how to use Mat class functionality</p> </li> </ul>"},{"location":"MATH/ESP-DSP/examples/#basic-math","title":"Basic math","text":"<p>This example demonstrates how to use basic math functions from esp-dsp library. The example does the following steps:</p> <ul> <li> <p>Initialize the library</p> </li> <li> <p>Initialize input signals with 1024 samples</p> </li> <li> <p>Apply window to input signal by standard C loop.</p> </li> <li> <p>Calculate FFT for 1024 complex samples and show the result</p> </li> <li> <p>Show results on the plots</p> </li> <li> <p>Apply window to input signal by basic math functions dsps_mul_f32 and dsps_mulc_f32.</p> </li> <li> <p>Calculate FFT for 1024 complex samples</p> </li> <li> <p>Show results on the plots</p> </li> </ul> <p>For more details please look to the examples/basic_math/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#dot-product","title":"Dot-product","text":"<p>The example demonstrates how to use dotprod dsps_dotprod_f32 from esp-dsp library. Example does the following steps:</p> <ul> <li> <p>Initialize the input arrays</p> </li> <li> <p>Calculate dot product of two arrays</p> </li> <li> <p>Compare results and calculate execution time in cycles.</p> </li> </ul> <p>For more details please look to the examples/dotprod/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#fft","title":"FFT","text":"<p>This example demonstrates how to use FFT functionality from esp-dsp library. Example does the following steps:</p> <ul> <li> <p>Initialize the library</p> </li> <li> <p>Initialize input signals with 1024 samples: one 0 dB, second with -20 dB</p> </li> <li> <p>Combine two signals as one complex input signal and apply window to input signals paar.</p> </li> <li> <p>Calculate FFT for 1024 complex samples</p> </li> <li> <p>Apply bit reverse operation for output complex vector</p> </li> <li> <p>Split one complex FFT output spectrum to two real signal spectrums</p> </li> <li> <p>Show results on the plots</p> </li> <li> <p>Show execution time of FFT</p> </li> </ul> <p>For more details please look to the examples/fft/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#fft-window","title":"FFT Window","text":"<p>This example demonstrates how to use Window and FFT functionality from esp-dsp library. Example does the following steps:</p> <ul> <li> <p>Initialize the library</p> </li> <li> <p>Initialize input signals with 1024 samples</p> </li> <li> <p>Apply window to input signal.</p> </li> <li> <p>Calculate FFT for 1024 complex samples</p> </li> <li> <p>Apply bit reverse operation for output complex vector</p> </li> <li> <p>Split one complex FFT output spectrum to two real signal spectrums</p> </li> <li> <p>Show results on the plots</p> </li> </ul> <p>For more details please look to the examples/fft_window/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#fft-4-real","title":"FFT 4 Real","text":"<p>This example demonstrates how to use FFT functionality from esp-dsp library. Example does the following steps:</p> <ul> <li> <p>Initialize the library</p> </li> <li> <p>Initialize input signals with 1024 samples: one 0 dB, second with -20 dB</p> </li> <li> <p>Calculate FFT Radix-2 for 1024 complex samples</p> </li> <li> <p>Calculate FFT Radix-4 for 1024 complex samples</p> </li> <li> <p>Apply bit reverse operation for output complex vectors</p> </li> <li> <p>Show results on the plots</p> </li> <li> <p>Show execution time of FFTs</p> </li> </ul> <p>For more details please look to the examples/fft4real/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#iir","title":"IIR","text":"<p>This example demonstrates how to use IIR filters functionality from esp-dsp library. Example does the following steps:</p> <ul> <li> <p>Initialize the library</p> </li> <li> <p>Initialize input signal</p> </li> <li> <p>Show LPF filter with Q factor 1</p> <ul> <li> <p>Calculate iir filter coefficients</p> </li> <li> <p>Filter the input test signal (delta function)</p> </li> <li> <p>Shows impulse response on the plot</p> </li> <li> <p>Shows frequency response on the plot</p> </li> </ul> </li> <li> <p>Calculate execution performance</p> </li> <li> <p>The same for LPF filter with Q factor 10</p> </li> </ul> <p>For more details please look to the examples/fir/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#fir","title":"FIR","text":"<p>This example demonstrates how to use FIR filter functionality from esp-dsp library. Example does the following steps:</p> <ul> <li> <p>Initialize the FFT library</p> </li> <li> <p>Initialize input signal</p> </li> <li> <p>Show input signal</p> </li> <li> <p>Show filtered signal</p> </li> </ul> <p>For more details please look to the examples/fir/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#kalman-filter","title":"Kalman Filter","text":"<p>This example emulate system with IMU sensors and show how to use Extended Kalman Filter (EKF), with 13 values states vector, to estimate gyroscope errors and calculate system attitude. Also, this example show how to use esp-dsp library to operate with matrices and vectors.</p> <p>In real system, the emulated sensors values should be replace by the real sensors values. Then, in real system, a calibration phase should be implemented and after the calibration phase the state vector X and covariance matrix P should be saved and restored next time, when filter called. It will save time for initial phase.</p> <p>For more details please look to the examples/kalman/README.md</p>"},{"location":"MATH/ESP-DSP/examples/#matrix","title":"Matrix","text":"<p>This example demonstrates how to use Mat class functionality from esp-dsp library. Example does the following steps:</p> <ul> <li> <p>Initialize a matrix A and matirx x</p> </li> <li> <p>Calculate matrix b: b = A*x</p> </li> <li> <p>Find roots x1: A*x1 = b, with different methods</p> </li> <li> <p>Print result</p> </li> </ul>"},{"location":"MATH/HEADER-FILE/tiny_constants/","title":"CONSTANTS","text":"<p>Info</p> <p>This file contains the definition of some constants, which are used for upper-level calculations and applications. The documentation update speed is slow and may not be consistent with the actual code. Please refer to the code for accuracy.</p> <pre><code>/**\n * @file tiny_constants.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file contains the constants used in the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n */\n\n#ifndef __TINY_CONSTANTS_H__\n#define __TINY_CONSTANTS_H__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n// =======================================\n//  Logical Constants\n// =======================================\n#ifndef TRUE\n#define TRUE 1\n#endif\n\n#ifndef FALSE\n#define FALSE 0\n#endif\n\n#ifndef NULL\n#define NULL ((void *)0)\n#endif\n\n// =======================================\n//  Math Constants (float/double safe)\n// =======================================\n#define TINY_PI 3.14159265358979323846f\n#define TINY_TWO_PI 6.28318530717958647692f\n#define TINY_HALF_PI 1.57079632679489661923f\n#define TINY_E 2.71828182845904523536f\n#define TINY_SQRT2 1.41421356237309504880f\n#define TINY_INV_SQRT2 0.70710678118654752440f\n\n#define TINY_DEG2RAD(x) ((x) * TINY_PI / 180.0f)\n#define TINY_RAD2DEG(x) ((x) * 180.0f / TINY_PI)\n\n// =======================================\n//  Bitmask &amp; Bit Manipulation\n// =======================================\n\n// Bitwise operations\n#define TINY_BIT(n) (1U &lt;&lt; (n)) // e.g. TINY_BIT(3) = 0b00001000\n#define TINY_BIT_SET(x, n) ((x) |= TINY_BIT(n))\n#define TINY_BIT_CLEAR(x, n) ((x) &amp;= ~TINY_BIT(n))\n#define TINY_BIT_TOGGLE(x, n) ((x) ^= TINY_BIT(n))\n#define TINY_BIT_CHECK(x, n) (((x) &gt;&gt; (n)) &amp; 0x1U)\n\n// Common bit masks\n#define TINY_MASK_4BIT 0x0FU\n#define TINY_MASK_8BIT 0xFFU\n#define TINY_MASK_16BIT 0xFFFFU\n#define TINY_MASK_32BIT 0xFFFFFFFFU\n\n// =======================================\n//  Fixed-Point Scaling Factors\n// =======================================\n#define TINY_Q7_SCALE 128          // 2^7\n#define TINY_Q15_SCALE 32768       // 2^15\n#define TINY_Q31_SCALE 2147483648U // 2^31\n\n// =======================================\n//  User-Defined Constants (Optional)\n// =======================================\n#define TINY_MATH_MIN_DENOMINATOR 1e-6f // Minimum denominator for safe division\n#define TINY_MATH_MIN_POSITIVE_INPUT_F32 1e-12f // Minimum positive input for float operations\n\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_CONSTANTS_H__ */\n</code></pre>"},{"location":"MATH/HEADER-FILE/tiny_error_type/","title":"ERROR TYPES DEFINITION","text":"<p>Info</p> <p>This file defines some common error types in calculations to assist in determining the cause of errors. The documentation update speed is slow and may not match the actual code, please refer to the code for accuracy.</p> <pre><code>/**\n * @file tiny_error_type.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief The configuration file for the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_ERROR_TYPE__\n#define __TINY_ERROR_TYPE__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* TYPE DEFINITIONS */\ntypedef int tiny_error_t; // Error type for the tiny_math middleware\n\n/* MACROS */\n/* Definitions for error constants. */\n#define TINY_OK          0       /*!&lt; tiny_err_t value indicating success (no error) */\n#define TINY_FAIL        -1      /*!&lt; Generic tiny_err_t code indicating failure */\n\n#define TINY_ERR_NO_MEM              0x101   /*!&lt; Out of memory */\n#define TINY_ERR_INVALID_ARG         0x102   /*!&lt; Invalid argument */\n#define TINY_ERR_INVALID_STATE       0x103   /*!&lt; Invalid state */\n#define TINY_ERR_INVALID_SIZE        0x104   /*!&lt; Invalid size */\n#define TINY_ERR_NOT_FOUND           0x105   /*!&lt; Requested resource not found */\n#define TINY_ERR_NOT_SUPPORTED       0x106   /*!&lt; Operation or feature not supported */\n#define TINY_ERR_TIMEOUT             0x107   /*!&lt; Operation timed out */\n#define TINY_ERR_INVALID_RESPONSE    0x108   /*!&lt; Received response was invalid */\n#define TINY_ERR_INVALID_CRC         0x109   /*!&lt; CRC or checksum was invalid */\n#define TINY_ERR_INVALID_VERSION     0x10A   /*!&lt; Version was invalid */\n#define TINY_ERR_INVALID_MAC         0x10B   /*!&lt; MAC address was invalid */\n#define TINY_ERR_NOT_FINISHED        0x10C   /*!&lt; Operation has not fully completed */\n#define TINY_ERR_NOT_ALLOWED         0x10D   /*!&lt; Operation is not allowed */\n\n#define TINY_ERR_WIFI_BASE           0x3000  /*!&lt; Starting number of WiFi error codes */\n#define TINY_ERR_MESH_BASE           0x4000  /*!&lt; Starting number of MESH error codes */\n#define TINY_ERR_FLASH_BASE          0x6000  /*!&lt; Starting number of flash error codes */\n#define TINY_ERR_HW_CRYPTO_BASE      0xc000  /*!&lt; Starting number of HW cryptography module error codes */\n#define TINY_ERR_MEMPROT_BASE        0xd000  /*!&lt; Starting number of Memory Protection API error codes */\n\n#define TINY_ERR_MATH_BASE                0x70000\n#define TINY_ERR_MATH_INVALID_LENGTH      (TINY_ERR_MATH_BASE + 1)\n#define TINY_ERR_MATH_INVALID_PARAM       (TINY_ERR_MATH_BASE + 2)\n#define TINY_ERR_MATH_PARAM_OUTOFRANGE    (TINY_ERR_MATH_BASE + 3)\n#define TINY_ERR_MATH_UNINITIALIZED       (TINY_ERR_MATH_BASE + 4)\n#define TINY_ERR_MATH_REINITIALIZED       (TINY_ERR_MATH_BASE + 5)\n#define TINY_ERR_MATH_ARRAY_NOT_ALIGNED   (TINY_ERR_MATH_BASE + 6)\n#define TINY_ERR_MATH_NULL_POINTER        (TINY_ERR_MATH_BASE + 7)\n#define TINY_ERR_MATH_ZERO_DIVISION       (TINY_ERR_MATH_BASE + 8)\n#define TINY_ERR_MATH_NEGATIVE_SQRT        (TINY_ERR_MATH_BASE + 9)\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_ERROR_TYPE__ */\n</code></pre>"},{"location":"MATH/HEADER-FILE/tiny_math/","title":"TinyMath HEADER FILE","text":"<p>Info</p> <p>This is the main header file of the TinyMath library. It includes all necessary header files and provides a unified interface to use the functions of the library. After completing the porting of this library in the project, you can insert this header file where you want to use the relevant functions to use all functions in the library. The documentation update speed is slow and may not be consistent with the actual code, please refer to the actual code.</p> <pre><code>/**\n * @file tiny_math.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the tiny_math middleware.\n * @version 1.0\n * @date 2025-03-26\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_MATH__\n#define __TINY_MATH__\n\n/* DEPENDENCIES */\n\n// this layer\n#include \"tiny_math_config.h\"\n\n/* SUBMODULES */\n\n// vector operations\n#include \"tiny_vec.h\"\n\n// matrix operations\n#include \"tiny_mat.h\"\n\n// advanced matrix operations\n#ifdef __cplusplus\n\n#include \"tiny_matrix.hpp\"\n\n#endif\n\n/* TEST */ // NOTE: test files are platform specific and should not be included in the library\n\n// vector operations\n#include \"tiny_vec_test.h\"\n\n// matrix operations\n#include \"tiny_mat_test.h\"\n\n// advanced matrix operations\n#ifdef __cplusplus\n\n#include \"tiny_matrix_test.hpp\"\n\n#endif\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_MATH__ */\n</code></pre>"},{"location":"MATH/HEADER-FILE/tiny_math_config/","title":"TinyMath CONFIGURATION","text":"<p>Info</p> <p>This header file serves to configure the entire TinyMath module, and each submodule includes this header file. It defines the configuration options and macros for TinyMath, allowing users to customize settings as needed. By modifying the configuration options in this header file, users can easily adjust the behavior and functionality of TinyMath to meet specific requirements. The documentation may be updated slowly and may not match the actual code, so please refer to the code for accuracy.</p> <p>Tip</p> <p>This component includes macro definitions for selecting platforms, allowing users to choose different platforms for compilation as needed. By switching to the corresponding platform macro, users can leverage platform acceleration features to enhance performance. For example, for the ESP32 platform, TinyMath will automatically select the ESP32 DSP library for compilation, achieving more efficient mathematical operations.</p> <pre><code>/**\n * @file tiny_math_config.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief The configuration file for the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-14\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_MATH_CONFIG__\n#define __TINY_MATH_CONFIG__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* DEPENDENCIES */\n\n// ANSI C\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdint.h&gt;\n\n// lower level\n#include \"tiny_toolbox.h\"\n\n// this level\n#include \"tiny_error_type.h\"\n#include \"tiny_constants.h\"\n\n/* PLATFORM SELECTION */\n\n// available platforms\n#define MCU_PLATFORM_GENERIC     0\n#define MCU_PLATFORM_ESP32       1 // here, we utilize the ESP built-in DSP library, it will automatically select the optimized version\n#define MCU_PLATFORM_STM32       2\n#define MCU_PLATFORM_RISCV       3\n\n// choose one platform\n#define MCU_PLATFORM_SELECTED    MCU_PLATFORM_ESP32\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_MATH_CONFIG__ */\n</code></pre>"},{"location":"MATH/MATRIX/tiny-mat-api/","title":"MATRIX OPERATIONS - TINY_MAT","text":"<p>About tiny_mat library</p> <p>tiny_mat is a C implementation of a matrix library that provides basic matrix operation functions. It supports operations such as addition, subtraction, and multiplication of floating-point matrices. This library is suitable for embedded systems and real-time applications that require matrix calculations. The library is based on the ANSI C standard, ensuring good portability and performance, while also supporting platform acceleration through configuration files (ESP32).</p> <p>About the usage of tiny_mat library</p> <p>The functionality of tiny_mat is completely covered by tiny_matrix, which means that the functions in tiny_matrix include all the functions of tiny_mat. For simple matrix operations, you can only include the tiny_mat library; for complex matrix operations, it is recommended to use the tiny_matrix library. The tiny_matrix library is a C++ implementation of a matrix library that provides richer functionality and better performance. It supports operations such as addition, subtraction, multiplication, transposition, and inversion of floating-point and integer matrices.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#list-of-functions","title":"LIST OF FUNCTIONS","text":"<pre><code>TinyMath\n    \u251c\u2500\u2500Vector\n    \u2514\u2500\u2500Matrix\n        \u251c\u2500\u2500 tiny_mat (c) &lt;---\n        \u2514\u2500\u2500 tiny_matrix (c++)\n</code></pre> <pre><code>// print matrix\nvoid print_matrix(const char *name, const float *mat, int rows, int cols);\n// print matrix padded (row-major)\nvoid print_matrix_padded(const char *name, const float *mat, int rows, int cols, int step);\n// addition\ntiny_error_t tiny_mat_add_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\ntiny_error_t tiny_mat_addc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n// subtraction\ntiny_error_t tiny_mat_sub_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\ntiny_error_t tiny_mat_subc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n// multiplication\ntiny_error_t tiny_mat_mult_f32(const float *A, const float *B, float *C, int m, int n, int k);\ntiny_error_t tiny_mat_mult_ex_f32(const float *A, const float *B, float *C, int A_rows, int A_cols, int B_cols, int A_padding, int B_padding, int C_padding);\ntiny_error_t tiny_mat_multc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre>"},{"location":"MATH/MATRIX/tiny-mat-api/#utility-functions","title":"UTILITY FUNCTIONS","text":""},{"location":"MATH/MATRIX/tiny-mat-api/#print-matrix","title":"Print Matrix","text":"<p><pre><code>void print_matrix(const char *name, const float *mat, int rows, int cols);\n</code></pre> Function: Print a matrix in row-major order.</p> <p>Parameters:</p> <ul> <li> <p><code>name</code>: Name of the matrix.</p> </li> <li> <p><code>mat</code>: Pointer to the matrix data.</p> </li> <li> <p><code>rows</code>: Number of rows in the matrix.</p> </li> <li> <p><code>cols</code>: Number of columns in the matrix.</p> </li> </ul> <p>Returns: None.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#print-padded-matrix","title":"Print Padded Matrix","text":"<p><pre><code>void print_matrix_padded(const char *name, const float *mat, int rows, int cols, int step);\n</code></pre> Function: Print a matrix in row-major order with padding.</p> <p>Parameters: - <code>name</code>: Name of the matrix.</p> <ul> <li> <p><code>mat</code>: Pointer to the matrix data.</p> </li> <li> <p><code>rows</code>: Number of rows in the matrix.</p> </li> <li> <p><code>cols</code>: Number of columns in the matrix.</p> </li> <li> <p><code>step</code>: Step size for the matrix data.</p> </li> </ul> <p>Returns: None.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#addition","title":"ADDITION","text":""},{"location":"MATH/MATRIX/tiny-mat-api/#matrix-addition","title":"Matrix Addition","text":"<pre><code>tiny_error_t tiny_mat_add_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\n</code></pre> <p>Function: Add two matrices.</p> <p>Parameters:</p> <ul> <li> <p><code>input1</code>: Pointer to the first input matrix.</p> </li> <li> <p><code>input2</code>: Pointer to the second input matrix.</p> </li> <li> <p><code>output</code>: Pointer to the output matrix.</p> </li> <li> <p><code>rows</code>: Number of rows in the matrices.</p> </li> <li> <p><code>cols</code>: Number of columns in the matrices.</p> </li> <li> <p><code>padd1</code>: Padding for the first input matrix.</p> </li> <li> <p><code>padd2</code>: Padding for the second input matrix.</p> </li> <li> <p><code>padd_out</code>: Padding for the output matrix.</p> </li> <li> <p><code>step1</code>: Step size for the first input matrix.</p> </li> <li> <p><code>step2</code>: Step size for the second input matrix.</p> </li> <li> <p><code>step_out</code>: Step size for the output matrix.</p> </li> </ul> <p>Returns: <code>tiny_error_t</code> indicating success or failure.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#matrix-addition-with-constant","title":"Matrix Addition with Constant","text":"<pre><code>tiny_error_t tiny_mat_addc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre> <p>Function: Add a constant to a matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>input</code>: Pointer to the input matrix.</p> </li> <li> <p><code>output</code>: Pointer to the output matrix.</p> </li> <li> <p><code>C</code>: Constant to add.</p> </li> <li> <p><code>rows</code>: Number of rows in the matrix.</p> </li> <li> <p><code>cols</code>: Number of columns in the matrix.</p> </li> <li> <p><code>padd_in</code>: Padding for the input matrix.</p> </li> <li> <p><code>padd_out</code>: Padding for the output matrix.</p> </li> <li> <p><code>step_in</code>: Step size for the input matrix.</p> </li> <li> <p><code>step_out</code>: Step size for the output matrix.</p> </li> </ul> <p>Returns: <code>tiny_error_t</code> indicating success or failure.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#subtraction","title":"SUBTRACTION","text":""},{"location":"MATH/MATRIX/tiny-mat-api/#matrix-subtraction","title":"Matrix Subtraction","text":"<pre><code>tiny_error_t tiny_mat_sub_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\n</code></pre> <p>Function: Subtract two matrices.</p> <p>Parameters:</p> <ul> <li> <p><code>input1</code>: Pointer to the first input matrix.</p> </li> <li> <p><code>input2</code>: Pointer to the second input matrix.</p> </li> <li> <p><code>output</code>: Pointer to the output matrix.</p> </li> <li> <p><code>rows</code>: Number of rows in the matrices.</p> </li> <li> <p><code>cols</code>: Number of columns in the matrices.</p> </li> <li> <p><code>padd1</code>: Padding for the first input matrix.</p> </li> <li> <p><code>padd2</code>: Padding for the second input matrix.</p> </li> <li> <p><code>padd_out</code>: Padding for the output matrix.</p> </li> <li> <p><code>step1</code>: Step size for the first input matrix.</p> </li> <li> <p><code>step2</code>: Step size for the second input matrix.</p> </li> <li> <p><code>step_out</code>: Step size for the output matrix.</p> </li> </ul> <p>Returns: <code>tiny_error_t</code> indicating success or failure.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#matrix-subtraction-with-constant","title":"Matrix Subtraction with Constant","text":"<pre><code>tiny_error_t tiny_mat_subc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre> <p>Function: Subtract a constant from a matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>input</code>: Pointer to the input matrix.</p> </li> <li> <p><code>output</code>: Pointer to the output matrix.</p> </li> <li> <p><code>C</code>: Constant to subtract.</p> </li> <li> <p><code>rows</code>: Number of rows in the matrix.</p> </li> <li> <p><code>cols</code>: Number of columns in the matrix.</p> </li> <li> <p><code>padd_in</code>: Padding for the input matrix.</p> </li> <li> <p><code>padd_out</code>: Padding for the output matrix.</p> </li> <li> <p><code>step_in</code>: Step size for the input matrix.</p> </li> <li> <p><code>step_out</code>: Step size for the output matrix.</p> </li> </ul> <p>Returns: <code>tiny_error_t</code> indicating success or failure.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#multiplication","title":"MULTIPLICATION","text":""},{"location":"MATH/MATRIX/tiny-mat-api/#matrix-multiplication","title":"Matrix Multiplication","text":"<pre><code>tiny_error_t tiny_mat_mult_f32(const float *A, const float *B, float *C, int m, int n, int k);\n</code></pre> <p>Function: Multiply two matrices.</p> <p>Parameters:</p> <ul> <li> <p><code>A</code>: Pointer to the first input matrix.</p> </li> <li> <p><code>B</code>: Pointer to the second input matrix.</p> </li> <li> <p><code>C</code>: Pointer to the output matrix.</p> </li> <li> <p><code>m</code>: Number of rows in the first matrix.</p> </li> <li> <p><code>n</code>: Number of columns in the first matrix (and rows in the second matrix).</p> </li> <li> <p><code>k</code>: Number of columns in the second matrix.</p> </li> </ul> <p>Returns: <code>tiny_error_t</code> indicating success or failure.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#extended-matrix-multiplication","title":"Extended Matrix Multiplication","text":"<pre><code>tiny_error_t tiny_mat_mult_ex_f32(const float *A, const float *B, float *C, int A_rows, int A_cols, int B_cols, int A_padding, int B_padding, int C_padding);\n</code></pre> <p>Function: Multiply two matrices with extended parameters.</p> <p>Parameters:</p> <ul> <li> <p><code>A</code>: Pointer to the first input matrix.</p> </li> <li> <p><code>B</code>: Pointer to the second input matrix.</p> </li> <li> <p><code>C</code>: Pointer to the output matrix.</p> </li> <li> <p><code>A_rows</code>: Number of rows in the first matrix.</p> </li> <li> <p><code>A_cols</code>: Number of columns in the first matrix.</p> </li> <li> <p><code>B_cols</code>: Number of columns in the second matrix.</p> </li> <li> <p><code>A_padding</code>: Padding for the first matrix.</p> </li> <li> <p><code>B_padding</code>: Padding for the second matrix.</p> </li> <li> <p><code>C_padding</code>: Padding for the output matrix.</p> </li> </ul> <p>Returns: <code>tiny_error_t</code> indicating success or failure.</p>"},{"location":"MATH/MATRIX/tiny-mat-api/#matrix-multiplication-with-constant","title":"Matrix Multiplication with Constant","text":"<pre><code>tiny_error_t tiny_mat_multc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre> <p>Function: Multiply a matrix by a constant.</p> <p>Parameters:</p> <ul> <li> <p><code>input</code>: Pointer to the input matrix.</p> </li> <li> <p><code>output</code>: Pointer to the output matrix.</p> </li> <li> <p><code>C</code>: Constant to multiply.</p> </li> <li> <p><code>rows</code>: Number of rows in the matrix.</p> </li> <li> <p><code>cols</code>: Number of columns in the matrix.</p> </li> <li> <p><code>padd_in</code>: Padding for the input matrix.</p> </li> <li> <p><code>padd_out</code>: Padding for the output matrix.</p> </li> <li> <p><code>step_in</code>: Step size for the input matrix.</p> </li> <li> <p><code>step_out</code>: Step size for the output matrix.</p> </li> </ul> <p>Returns: <code>tiny_error_t</code> indicating success or failure. ```</p>"},{"location":"MATH/MATRIX/tiny-mat-code/","title":"CODE","text":""},{"location":"MATH/MATRIX/tiny-mat-code/#tiny_math","title":"tiny_mat.h","text":"<pre><code>/**\n * @file tiny_mat.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the submodule mat (basic matrix operations) of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-17\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_MAT__\n#define __TINY_MAT__\n\n/* DEPENDENCIES */\n#include \"tiny_math_config.h\"\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n// ESP32 DSP library\n#include \"dspm_matrix.h\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* FUNCTION PROTOTYPES */\n// print matrix\nvoid print_matrix(const char *name, const float *mat, int rows, int cols);\n// print matrix padded (row-major)\nvoid print_matrix_padded(const char *name, const float *mat, int rows, int cols, int step);\n// addition\ntiny_error_t tiny_mat_add_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\ntiny_error_t tiny_mat_addc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n// subtraction\ntiny_error_t tiny_mat_sub_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\ntiny_error_t tiny_mat_subc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n// multiplication\ntiny_error_t tiny_mat_mult_f32(const float *A, const float *B, float *C, int m, int n, int k);\ntiny_error_t tiny_mat_mult_ex_f32(const float *A, const float *B, float *C, int A_rows, int A_cols, int B_cols, int A_padding, int B_padding, int C_padding);\ntiny_error_t tiny_mat_multc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY__MAT__ */\n</code></pre>"},{"location":"MATH/MATRIX/tiny-mat-code/#tiny_matc","title":"tiny_mat.c","text":"<pre><code>/**\n * @file tiny_mat.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the source file for the submodule mat (basic matrix operations) of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-17\n * @copyright Copyright (c) 2025\n *\n */\n\n/* DEPENDENCIES */\n#include \"tiny_mat.h\"\n\n/* SUPPORTIVE FUNCTIONS */\n\n/**\n * @name print_matrix\n * @brief Prints a matrix to the console.\n * @param name Name of the matrix.\n * @param mat Pointer to the matrix data.\n * @param rows Number of rows in the matrix.\n * @param cols Number of columns in the matrix.\n */\nvoid print_matrix(const char *name, const float *mat, int rows, int cols)\n{\n    printf(\"%s =\\n\\r\", name);\n    for (int i = 0; i &lt; rows; i++)\n    {\n        for (int j = 0; j &lt; cols; j++)\n        {\n            printf(\"%10.6f \", mat[i + j]); // padding not considered\n        }\n        printf(\"\\n\\r\");\n    }\n    printf(\"\\n\\r\");\n}\n\n// print matrix padded\n/**\n * @name print_matrix\n * @brief Prints a matrix to the console.\n * @param name Name of the matrix.\n * @param mat Pointer to the matrix data.\n * @param rows Number of rows in the matrix.\n * @param cols Number of columns in the matrix.\n * @param step Step size (how many elements in a row) for the matrix data. row-major order.\n */\nvoid print_matrix_padded(const char *name, const float *mat, int rows, int cols, int step)\n{\n    printf(\"%s =\\n\\r\", name);\n    for (int i = 0; i &lt; rows; i++)\n    {\n        for (int j = 0; j &lt; cols; j++)\n        {\n            printf(\"%10.6f \", mat[i * step + j]); // padding considered\n        }\n        printf(\"\\n\\r\");\n    }\n    printf(\"\\n\\r\");\n}\n\n/* ADDITION */\n\n// matrix + matrix | float\n\n/**\n * @name tiny_mat_add_f32\n * @brief Adds two matrices of type float32.\n * @param input1 Pointer to the first input matrix.\n * @param input2 Pointer to the second input matrix.\n * @param output Pointer to the output matrix.\n * @param rows Number of rows in the matrices.\n * @param cols Number of columns in the matrices.\n * @param padd1 Number of padding columns in the first input matrix.\n * @param padd2 Number of padding columns in the second input matrix.\n * @param padd_out Number of padding columns in the output matrix.\n * @param step1 Step size for the first input matrix.\n * @param step2 Step size for the second input matrix.\n * @param step_out Step size for the output matrix.\n * @return Returns TINY_OK on success, or an error code on failure.\n * @note This function performs matrix addition with the specified padding and step sizes.\n * @note The function assumes that the input matrices are in row-major order.\n */\ntiny_error_t tiny_mat_add_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out)\n{\n    if (NULL == input1 || NULL == input2 || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (rows &lt;= 0 || cols &lt;= 0 || padd1 &lt; 0 || padd2 &lt; 0 || padd_out &lt; 0 || step1 &lt;= 0 || step2 &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_MATH_INVALID_PARAM;\n    }\n\n    // pad refers to the columns that are not used in the matrix operation\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized matrix addition\n    dspm_add_f32(input1, input2, output, rows, cols, padd1, padd2, padd_out, step1, step2, step_out);\n#else\n    const int ptr_input1_step = cols + padd1;\n    const int ptr_input2_step = cols + padd2;\n    const int ptr_output_step = cols + padd_out;\n    float *ptr_input1 = (float *)input1;\n    float *ptr_input2 = (float *)input2;\n\n    for (int row = 0; row &lt; rows; row++)\n    {\n        for (int col = 0; col &lt; cols; col++)\n        {\n            output[col * step_out] = ptr_input1[col * step1] + ptr_input2[col * step2];\n        }\n        ptr_input1 += ptr_input1_step; // move to the next row of input1\n        ptr_input2 += ptr_input2_step; // move to the next row of input2\n        output += ptr_output_step;     // move to the next row of output\n    }\n#endif\n    return TINY_OK;\n}\n\n// matrix + constant | float\n\n/**\n * @name tiny_mat_addc_f32\n * @brief Adds a constant to each element of a matrix of type float32.\n * @param input Pointer to the input matrix.\n * @param output Pointer to the output matrix.\n * @param C Constant value to be added to each element of the matrix.\n * @param rows Number of rows in the matrices.\n * @param cols Number of columns in the matrices.\n * @param padd_in Number of padding columns in the input matrix.\n * @param padd_out Number of padding columns in the output matrix.\n * @param step_in Step size for the input matrix.\n * @param step_out Step size for the output matrix.\n * @return Returns TINY_OK on success, or an error code on failure.\n * @note This function performs matrix addition with a constant with the specified padding and step sizes.\n * @note The function assumes that the input matrix is in row-major order.\n */\ntiny_error_t tiny_mat_addc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (rows &lt;= 0 || cols &lt;= 0 || padd_in &lt; 0 || padd_out &lt; 0 || step_in &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_MATH_INVALID_PARAM;\n    }\n    // pad refers to the columns that are not used in the matrix operation\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized matrix addition with a constant\n    dspm_addc_f32(input, output, C, rows, cols, padd_in, padd_out, step_in, step_out);\n#else\n    const int ptr_input_step = cols + padd_in;\n    const int ptr_output_step = cols + padd_out;\n    float *ptr_input = (float *)input;\n\n    for (int row = 0; row &lt; rows; row++)\n    {\n        for (int col = 0; col &lt; cols; col++)\n        {\n            output[col * step_out] = ptr_input[col * step_in] + C;\n        }\n        ptr_input += ptr_input_step; // move to the next row of input\n        output += ptr_output_step;   // move to the next row of output\n    }\n#endif\n    return TINY_OK;\n}\n\n/* SUBTRACTION */\n\n// matrix - matrix | float\n\n/**\n * @name tiny_mat_sub_f32\n * @brief Subtracts two matrices of type float32.\n * @param input1 Pointer to the first input matrix.\n * @param input2 Pointer to the second input matrix.\n * @param output Pointer to the output matrix.\n * @param rows Number of rows in the matrices.\n * @param cols Number of columns in the matrices.\n * @param padd1 Number of padding columns in the first input matrix.\n * @param padd2 Number of padding columns in the second input matrix.\n * @param padd_out Number of padding columns in the output matrix.\n * @param step1 Step size for the first input matrix.\n * @param step2 Step size for the second input matrix.\n * @param step_out Step size for the output matrix.\n * @return Returns TINY_OK on success, or an error code on failure.\n * @note This function performs matrix subtraction with the specified padding and step sizes.\n * @note The function assumes that the input matrices are in row-major order.\n */\ntiny_error_t tiny_mat_sub_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out)\n{\n    if (NULL == input1 || NULL == input2 || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (rows &lt;= 0 || cols &lt;= 0 || padd1 &lt; 0 || padd2 &lt; 0 || padd_out &lt; 0 || step1 &lt;= 0 || step2 &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_MATH_INVALID_PARAM;\n    }\n    // pad refers to the columns that are not used in the matrix operation\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized matrix subtraction\n    dspm_sub_f32(input1, input2, output, rows, cols, padd1, padd2, padd_out, step1, step2, step_out);\n#else\n    const int ptr_input1_step = cols + padd1;\n    const int ptr_input2_step = cols + padd2;\n    const int ptr_output_step = cols + padd_out;\n    float *ptr_input1 = (float *)input1;\n    float *ptr_input2 = (float *)input2;\n\n    for (int row = 0; row &lt; rows; row++)\n    {\n        for (int col = 0; col &lt; cols; col++)\n        {\n            output[col * step_out] = ptr_input1[col * step1] - ptr_input2[col * step2];\n        }\n        ptr_input1 += ptr_input1_step; // move to the next row of input1\n        ptr_input2 += ptr_input2_step; // move to the next row of input2\n        output += ptr_output_step;     // move to the next row of output\n    }\n#endif\n    return TINY_OK;\n}\n\n// matrix - constant | float\n\n/**\n * @name tiny_mat_subc_f32\n * @brief Subtracts a constant from each element of a matrix of type float32.\n * @param input Pointer to the input matrix.\n * @param output Pointer to the output matrix.\n * @param C Constant value to be subtracted from each element of the matrix.\n * @param rows Number of rows in the matrices.\n * @param cols Number of columns in the matrices.\n * @param padd_in Number of padding columns in the input matrix.\n * @param padd_out Number of padding columns in the output matrix.\n * @param step_in Step size for the input matrix.\n * @param step_out Step size for the output matrix.\n * @return Returns TINY_OK on success, or an error code on failure.\n * @note This function performs matrix subtraction with a constant with the specified padding and step sizes.\n * @note The function assumes that the input matrix is in row-major order.\n */\ntiny_error_t tiny_mat_subc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (rows &lt;= 0 || cols &lt;= 0 || padd_in &lt; 0 || padd_out &lt; 0 || step_in &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_MATH_INVALID_PARAM;\n    }\n    // pad refers to the columns that are not used in the matrix operation\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized matrix subtraction with a constant\n    dspm_addc_f32(input, output, -C, rows, cols, padd_in, padd_out, step_in, step_out);\n#else\n    const int ptr_input_step = cols + padd_in;\n    const int ptr_output_step = cols + padd_out;\n    float *ptr_input = (float *)input;\n\n    for (int row = 0; row &lt; rows; row++)\n    {\n        for (int col = 0; col &lt; cols; col++)\n        {\n            output[col * step_out] = ptr_input[col * step_in] - C;\n        }\n        ptr_input += ptr_input_step; // move to the next row of input\n        output += ptr_output_step;   // move to the next row of output\n    }\n#endif\n    return TINY_OK;\n}\n\n/* MULTIPLICATION */\n\n// matrix * matrix | float\n\n/**\n * @name tiny_mat_mult_f32\n * @brief Multiplies two matrices of type float32.\n * @param A Pointer to the first input matrix.\n * @param B Pointer to the second input matrix.\n * @param C Pointer to the output matrix.\n * @param m Number of rows in the first matrix.\n * @param n Number of columns in the first matrix and rows in the second matrix.\n * @param k Number of columns in the second matrix.\n * @return Returns TINY_OK on success, or an error code on failure.\n * @note This function performs matrix multiplication with the specified padding and step sizes.\n * @note The function assumes that the input matrices are in row-major order.\n */\ntiny_error_t tiny_mat_mult_f32(const float *A, const float *B, float *C, int m, int n, int k)\n{\n    if (NULL == A || NULL == B || NULL == C)\n        return TINY_ERR_MATH_NULL_POINTER;\n    if (m &lt;= 0 || n &lt;= 0 || k &lt;= 0)\n        return TINY_ERR_MATH_INVALID_PARAM;\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized matrix multiplication\n    dspm_mult_f32(A, B, C, m, n, k);\n#else\n    // C[i][j] = sum_{s=0}^{n-1} A[i][s] * B[s][j]\n    for (int i = 0; i &lt; m; i++)\n    {\n        for (int j = 0; j &lt; k; j++)\n        {\n            C[i * k + j] = 0.0f;\n            for (int s = 0; s &lt; n; s++)\n            {\n                C[i * k + j] += A[i * n + s] * B[s * k + j];\n            }\n        }\n    }\n#endif\n    return TINY_OK;\n}\n\n// matrix * matrix | float with padding and step sizes\n/**\n * @name tiny_mat_mult_ex_f32\n * @brief Multiplies two matrices of type float32 with padding and step sizes.\n * @param A Pointer to the first input matrix.\n * @param B Pointer to the second input matrix.\n * @param C Pointer to the output matrix.\n * @param A_rows Number of rows in the first matrix.\n * @param A_cols Number of columns in the first matrix and rows in the second matrix.\n * @param B_cols Number of columns in the second matrix.\n * @param A_padding Number of padding columns in the first matrix.\n * @param B_padding Number of padding columns in the second matrix.\n * @param C_padding Number of padding columns in the output matrix.\n * @return Returns TINY_OK on success, or an error code on failure.\n * @note This function performs matrix multiplication with the specified padding and step sizes.\n * @note The function assumes that the input matrices are in row-major order.\n */\ntiny_error_t tiny_mat_mult_ex_f32(const float *A, const float *B, float *C, int A_rows, int A_cols, int B_cols, int A_padding, int B_padding, int C_padding)\n{\n    if (NULL == A || NULL == B || NULL == C)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (A_rows &lt;= 0 || A_cols &lt;= 0 || B_cols &lt;= 0)\n    {\n        return TINY_ERR_MATH_INVALID_PARAM;\n    }\n    if (A_padding &lt; 0 || B_padding &lt; 0 || C_padding &lt; 0)\n    {\n        return TINY_ERR_MATH_INVALID_PARAM;\n    }\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized matrix multiplication\n    dspm_mult_ex_f32(A, B, C, A_rows, A_cols, B_cols, A_padding, B_padding, C_padding);\n#else\n    // Matrix A(m,n), m - amount or rows, n - amount of columns\n    // C(m,k) = A(m,n)*B(n,k)\n    // c(i * c_step,j) = sum(a(i * a_step,s)*b(s * b_step,j)) , s=1..n\n    const int A_step = A_cols + A_padding;\n    const int B_step = B_cols + B_padding;\n    const int C_step = B_cols + C_padding;\n\n    for (int i = 0; i &lt; A_rows; i++)\n    {\n        for (int j = 0; j &lt; B_cols; j++)\n        {\n            C[i * C_step + j] = A[i * A_step] * B[j];\n            for (int s = 1; s &lt; A_cols; s++)\n            {\n                C[i * C_step + j] += A[i * A_step + s] * B[s * B_step + j];\n            }\n        }\n    }\n#endif\n    return TINY_OK;\n}\n\n// matrix * constant | float\n/**\n * @name tiny_mat_multc_f32\n * @brief Multiplies a matrix by a constant of type float32.\n * @param input Pointer to the input matrix.\n * @param output Pointer to the output matrix.\n * @param C Constant value to be multiplied with each element of the matrix.\n * @param rows Number of rows in the matrices.\n * @param cols Number of columns in the matrices.\n * @param padd_in Number of padding columns in the input matrix.\n * @param padd_out Number of padding columns in the output matrix.\n * @param step_in Step size for the input matrix.\n * @param step_out Step size for the output matrix.\n * @return Returns TINY_OK on success, or an error code on failure.\n * @note This function performs matrix multiplication with a constant with the specified padding and step sizes.\n * @note The function assumes that the input matrix is in row-major order.\n */\ntiny_error_t tiny_mat_multc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (rows &lt;= 0 || cols &lt;= 0 || padd_in &lt; 0 || padd_out &lt; 0 || step_in &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_MATH_INVALID_PARAM;\n    }\n    // pad refers to the columns that are not used in the matrix operation\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized matrix multiplication with a constant\n    dspm_mulc_f32(input, output, C, rows, cols, padd_in, padd_out, step_in, step_out);\n#else\n    const int ptr_input_step = cols + padd_in;\n    const int ptr_output_step = cols + padd_out;\n    float *ptr_input = (float *)input;\n\n    for (int row = 0; row &lt; rows; row++)\n    {\n        for (int col = 0; col &lt; cols; col++)\n        {\n            output[col * step_out] = ptr_input[col * step_in] * C;\n        }\n        ptr_input += ptr_input_step; // move to the next row of input\n        output += ptr_output_step;   // move to the next row of output\n    }\n#endif\n    return TINY_OK;\n}\n</code></pre>"},{"location":"MATH/MATRIX/tiny-mat-test/","title":"TINY_MAT TEST","text":""},{"location":"MATH/MATRIX/tiny-mat-test/#test-code","title":"TEST CODE","text":""},{"location":"MATH/MATRIX/tiny-mat-test/#tiny_mat_testh","title":"tiny_mat_test.h","text":"<pre><code>/**\n * @file tiny_mat_test.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the test of the submodule mat (basic matrix operations) of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-17\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_MAT_TEST__\n#define __TINY_MAT_TEST__\n\n/* DEPENDENCIES */\n#include \"tiny_math_config.h\"\n#include \"tiny_mat.h\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\nvoid tiny_mat_test(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_MAT_TEST__ */\n</code></pre>"},{"location":"MATH/MATRIX/tiny-mat-test/#tiny_mat_testc","title":"tiny_mat_test.c","text":"<pre><code>/**\n * @file tiny_mat_test.c\n * @brief This file implements test functions for the submodule mat of the tiny_math middleware.\n */\n\n#include \"tiny_mat_test.h\"\n\n#define ROWS 2\n#define COLS 3\n#define PAD 1\n#define FULL_WIDTH (COLS + PAD)\n\nvoid tiny_mat_test(void)\n{\n    float A[ROWS * FULL_WIDTH] = {\n        1, 2, 3, 0,\n        4, 5, 6, 0};\n\n    float B[COLS * FULL_WIDTH] = {\n        7, 8, 9, 0,\n        10, 11, 12, 0,\n        13, 14, 15, 0};\n\n    float A_compact[ROWS * COLS] = {0};\n    float B_compact[COLS * COLS] = {0};\n    float C_compact[ROWS * COLS] = {0};\n\n    float output_general[ROWS * FULL_WIDTH] = {0};\n    float constant = 2.0f;\n\n    for (int i = 0; i &lt; ROWS; i++)\n        for (int j = 0; j &lt; COLS; j++)\n            A_compact[i * COLS + j] = A[i * FULL_WIDTH + j];\n\n    for (int i = 0; i &lt; COLS; i++)\n        for (int j = 0; j &lt; COLS; j++)\n            B_compact[i * COLS + j] = B[i * FULL_WIDTH + j];\n\n    printf(\"============ [tiny_mat_test - Full Coverage] ============\\n\\r\");\n    printf(\"[TEST SETTINGS] ROWS=%d, COLS=%d, PAD=%d, FULL_WIDTH=%d\\n\\r\", ROWS, COLS, PAD, FULL_WIDTH);\n\n    print_matrix_padded(\"A (padded) | memory layout\", A, ROWS, FULL_WIDTH, FULL_WIDTH);\n    print_matrix_padded(\"B (padded) | memory layout\", B, COLS, FULL_WIDTH, FULL_WIDTH);\n    print_matrix(\"A_compact\", A_compact, ROWS, COLS);\n    print_matrix(\"B_compact\", B_compact, COLS, COLS);\n    printf(\"constant = %f\\n\\r\\n\\r\", constant);\n\n    TinyTimeMark_t t0, t1;\n    tiny_error_t err;\n\n    t0 = tiny_get_running_time();\n    err = tiny_mat_add_f32(A, B, output_general, ROWS, COLS, PAD, PAD, PAD, 1, 1, 1);\n    t1 = tiny_get_running_time();\n    printf(\"--- tiny_mat_add_f32(rows=%d, cols=%d, paddings=1) | Time: %6.2f us | Error: %d ---\\n\\r\", ROWS, COLS, (double)(t1 - t0), err);\n    print_matrix_padded(\"Output (padded)\", output_general, ROWS, COLS, FULL_WIDTH);\n\n    t0 = tiny_get_running_time();\n    err = tiny_mat_addc_f32(A, output_general, constant, ROWS, COLS, PAD, PAD, 1, 1);\n    t1 = tiny_get_running_time();\n    printf(\"--- tiny_mat_addc_f32(C=%f) | Time: %6.2f us | Error: %d ---\\n\\r\", constant, (double)(t1 - t0), err);\n    print_matrix_padded(\"Output (padded)\", output_general, ROWS, COLS, FULL_WIDTH);\n\n    t0 = tiny_get_running_time();\n    err = tiny_mat_sub_f32(A, B, output_general, ROWS, COLS, PAD, PAD, PAD, 1, 1, 1);\n    t1 = tiny_get_running_time();\n    printf(\"--- tiny_mat_sub_f32(rows=%d, cols=%d) | Time: %6.2f us | Error: %d ---\\n\\r\", ROWS, COLS, (double)(t1 - t0), err);\n    print_matrix_padded(\"Output (padded)\", output_general, ROWS, COLS, FULL_WIDTH);\n\n    t0 = tiny_get_running_time();\n    err = tiny_mat_subc_f32(A, output_general, constant, ROWS, COLS, PAD, PAD, 1, 1);\n    t1 = tiny_get_running_time();\n    printf(\"--- tiny_mat_subc_f32(C=%f) | Time: %6.2f us | Error: %d ---\\n\\r\", constant, (double)(t1 - t0), err);\n    print_matrix_padded(\"Output (padded)\", output_general, ROWS, COLS, FULL_WIDTH);\n\n    t0 = tiny_get_running_time();\n    err = tiny_mat_multc_f32(A, output_general, constant, ROWS, COLS, PAD, PAD, 1, 1);\n    t1 = tiny_get_running_time();\n    printf(\"--- tiny_mat_multc_f32(C=%f) | Time: %6.2f us | Error: %d ---\\n\\r\", constant, (double)(t1 - t0), err);\n    print_matrix_padded(\"Output (padded)\", output_general, ROWS, COLS, FULL_WIDTH);\n\n    t0 = tiny_get_running_time();\n    err = tiny_mat_mult_f32(A_compact, B_compact, C_compact, ROWS, COLS, COLS);\n    t1 = tiny_get_running_time();\n    printf(\"--- tiny_mat_mult_f32 (compact) | Time: %6.2f us | Error: %d ---\\n\\r\", (double)(t1 - t0), err);\n    print_matrix(\"Output (compact)\", C_compact, ROWS, COLS);\n\n    t0 = tiny_get_running_time();\n    err = tiny_mat_mult_ex_f32(A, B, output_general, ROWS, COLS, COLS, PAD, PAD, PAD);\n    t1 = tiny_get_running_time();\n    printf(\"--- tiny_mat_mult_ex_f32(padded) | Time: %6.2f us | Error: %d ---\\n\\r\", (double)(t1 - t0), err);\n    print_matrix_padded(\"Output (padded)\", output_general, ROWS, COLS, FULL_WIDTH);\n\n    printf(\"============ [test complete] ============\\n\\r\");\n}\n</code></pre>"},{"location":"MATH/MATRIX/tiny-mat-test/#test-output","title":"TEST OUTPUT","text":"<pre><code>============ [tiny_mat_test - Full Coverage] ============\n[TEST SETTINGS] ROWS=2, COLS=3, PAD=1, FULL_WIDTH=4\nA (padded) | memory layout =\n  1.000000   2.000000   3.000000   0.000000 \n  4.000000   5.000000   6.000000   0.000000 \n\nB (padded) | memory layout =\n  7.000000   8.000000   9.000000   0.000000 \n 10.000000  11.000000  12.000000   0.000000 \n 13.000000  14.000000  15.000000   0.000000 \n\nA_compact =\n  1.000000   2.000000   3.000000 \n  2.000000   3.000000   4.000000 \n\nB_compact =\n  7.000000   8.000000   9.000000 \n  8.000000   9.000000  10.000000 \n  9.000000  10.000000  11.000000 \n\nconstant = 2.000000\n\n--- tiny_mat_add_f32(rows=2, cols=3, paddings=1) | Time:  18.00 us | Error: 0 ---\nOutput (padded) =\n  8.000000  10.000000  12.000000 \n 14.000000  16.000000  18.000000 \n\n--- tiny_mat_addc_f32(C=2.000000) | Time:  10.00 us | Error: 0 ---\nOutput (padded) =\n  3.000000   4.000000   5.000000 \n  6.000000   7.000000   8.000000 \n\n--- tiny_mat_sub_f32(rows=2, cols=3) | Time:  13.00 us | Error: 0 ---\nOutput (padded) =\n -6.000000  -6.000000  -6.000000 \n -6.000000  -6.000000  -6.000000 \n\n--- tiny_mat_subc_f32(C=2.000000) | Time:   7.00 us | Error: 0 ---\nOutput (padded) =\n -1.000000   0.000000   1.000000 \n  2.000000   3.000000   4.000000 \n\n--- tiny_mat_multc_f32(C=2.000000) | Time:   8.00 us | Error: 0 ---\nOutput (padded) =\n  2.000000   4.000000   6.000000 \n  8.000000  10.000000  12.000000 \n\n--- tiny_mat_mult_f32 (compact) | Time:  10.00 us | Error: 0 ---\nOutput (compact) =\n 66.000000  72.000000  78.000000 \n 72.000000  78.000000 156.000000 \n\n--- tiny_mat_mult_ex_f32(padded) | Time:  13.00 us | Error: 0 ---\nOutput (padded) =\n 66.000000  72.000000  78.000000 \n156.000000 171.000000 186.000000 \n\n============ [test complete] ============\n</code></pre>"},{"location":"MATH/MATRIX/tiny-matrix-api/","title":"MATRIX OPERATIONS - TINY_MATRIX","text":"<p>TINY_MATRIX Library</p> <ul> <li>This library is a lightweight matrix computation library implemented in C++, providing basic matrix operations and linear algebra functions.</li> <li>The design goal of this library is to provide a simple and easy-to-use matrix operation interface, suitable for embedded systems and resource-constrained environments.</li> </ul> <p>Usage Scenario</p> <p>Compared to the TINY_MAT library, the TINY_MATRIX library offers richer functionality and higher flexibility, suitable for applications that require complex matrix computations. However, please note that this library is written in C++.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#list-of-functions","title":"LIST OF FUNCTIONS","text":"<pre><code>TinyMath\n    \u251c\u2500\u2500Vector\n    \u2514\u2500\u2500Matrix\n        \u251c\u2500\u2500 tiny_mat (c)\n        \u2514\u2500\u2500 tiny_matrix (c++) &lt;---\n</code></pre> <pre><code>namespace tiny\n{\n    class Mat\n    {\n    public:\n        /* === Matrix Metadata === */\n        int row;         //&lt; number of rows\n        int col;         //&lt; number of columns\n        int pad;         //&lt; number of paddings between 2 rows\n        int stride;      //&lt; stride = (number of elements in a row) + padding\n        int element;     //&lt; number of elements = rows * cols\n        int memory;      //&lt; size of the data buffer = rows * stride\n        float *data;     //&lt; pointer to the data buffer\n        float *temp;     //&lt; pointer to the temporary data buffer\n        bool ext_buff;   //&lt; flag indicates that matrix use external buffer\n        bool sub_matrix; //&lt; flag indicates that matrix is a subset of another matrix\n\n        /* === Rectangular ROI Structure === */\n        /**\n         * @name Region of Interest (ROI) Structure\n         * @brief This is the structure for ROI\n         * \n         */\n        struct ROI\n        {\n            int pos_x;  ///&lt; starting column index\n            int pos_y;  ///&lt; starting row index\n            int width;  ///&lt; width of ROI (columns)\n            int height; ///&lt; height of ROI (rows)\n\n            // ROI constructor\n            ROI(int pos_x = 0, int pos_y = 0, int width = 0, int height = 0);\n\n            // resize ROI\n            void resize_roi(int pos_x, int pos_y, int width, int height);\n\n            // calculate area of ROI\n            int area_roi(void) const;\n        };\n\n        /* === Printing Functions === */\n        // print matrix info\n        void print_info() const;\n\n        // print matrix elements, paddings optional\n        void print_matrix(bool show_padding);\n\n        /* === Constructors &amp; Destructor === */\n        // memory allocation\n        void alloc_mem(); // Allocate internal memory\n\n        // constructor\n        Mat();\n        Mat(int rows, int cols);\n        Mat(int rows, int cols, int stride);\n        Mat(float *data, int rows, int cols);\n        Mat(float *data, int rows, int cols, int stride);\n        Mat(const Mat &amp;src);\n\n        // destructor\n        ~Mat();\n\n        /* === Element Access === */\n        // access matrix elements - non const\n        inline float &amp;operator()(int row, int col) { return data[row * stride + col]; }\n\n        // access matrix elements - const             \n        inline const float &amp;operator()(int row, int col) const { return data[row * stride + col]; }\n\n        /* === Data Manipulation === */\n        // copy other matrix into this matrix as a sub-matrix\n        tiny_error_t copy_paste(const Mat &amp;src, int row_pos, int col_pos);\n\n        // copy header of other matrix to this matrix\n        tiny_error_t copy_head(const Mat &amp;src);\n\n        // get a view (shallow copy) of sub-matrix (ROI) from this matrix\n        Mat view_roi(int start_row, int start_col, int roi_rows, int roi_cols) const;\n\n        // get a view (shallow copy) of sub-matrix (ROI) from this matrix using ROI structure\n        Mat view_roi(const Mat::ROI &amp;roi) const;\n\n        // get a replica (deep copy) of sub-matrix (ROI) \n        Mat copy_roi(int start_row, int start_col, int roi_rows, int roi_cols);\n\n        // get a replica (deep copy) of sub-matrix (ROI) using ROI structure\n        Mat copy_roi(const Mat::ROI &amp;roi);\n\n        // get a block of matrix\n        Mat block(int start_row, int start_col, int block_rows, int block_cols);\n\n        // swap rows\n        void swap_rows(int row1, int row2);\n\n        // clear matrix\n        void clear(void);\n\n        /* === Arithmetic Operators === */\n        Mat &amp;operator=(const Mat &amp;src);    // Copy assignment\n        Mat &amp;operator+=(const Mat &amp;A);     // Add matrix\n        Mat &amp;operator+=(float C);          // Add constant\n        Mat &amp;operator-=(const Mat &amp;A);     // Subtract matrix\n        Mat &amp;operator-=(float C);          // Subtract constant \n        Mat &amp;operator*=(const Mat &amp;A);     // Multiply matrix\n        Mat &amp;operator*=(float C);          // Multiply constant\n        Mat &amp;operator/=(const Mat &amp;B);     // Divide matrix\n        Mat &amp;operator/=(float C);          // Divide constant\n        Mat operator^(int C);              // Exponentiation\n\n        /* === Linear Algebra === */\n        Mat transpose();                   // Transpose matrix\n        Mat cofactor(int row, int col);    // cofactor matrix extraction\n        float determinant();\n        Mat adjoint(); \n        void normalize();\n        float norm() const;\n        Mat inverse_adjoint();\n        static Mat eye(int size);\n        static Mat augment(const Mat &amp;A, const Mat &amp;B);\n        static Mat ones(int rows, int cols);\n        static Mat ones(int size);\n        Mat gaussian_eliminate() const;\n        Mat row_reduce_from_gaussian();\n        Mat inverse_gje(); // Inverse using Gaussian-Jordan elimination\n        float dotprod(const Mat &amp;A, const Mat &amp;B);\n        Mat solve(const Mat &amp;A, const Mat &amp;b);\n        Mat band_solve(Mat A, Mat b, int k);\n        Mat roots(Mat A, Mat y);\n\n    protected:\n\n    private:\n\n    };\n\n    /* === Stream Operators === */\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat &amp;m);\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat::ROI &amp;roi);\n    std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Mat &amp;m);\n\n    /* === Global Arithmetic Operators === */\n    Mat operator+(const Mat &amp;A, const Mat &amp;B);\n    Mat operator+(const Mat &amp;A, float C);\n    Mat operator-(const Mat &amp;A, const Mat &amp;B);\n    Mat operator-(const Mat &amp;A, float C);\n    Mat operator*(const Mat &amp;A, const Mat &amp;B);\n    Mat operator*(const Mat &amp;A, float C);\n    Mat operator*(float C, const Mat &amp;A);\n    Mat operator/(const Mat &amp;A, float C);\n    Mat operator/(const Mat &amp;A, const Mat &amp;B);\n    bool operator==(const Mat &amp;A, const Mat &amp;B);\n\n}\n</code></pre>"},{"location":"MATH/MATRIX/tiny-matrix-api/#meta-data","title":"META DATA","text":"<ul> <li> <p><code>int row</code> : Number of rows in the matrix.</p> </li> <li> <p><code>int col</code> : Number of columns in the matrix.</p> </li> <li> <p><code>int pad</code> : Number of paddings between two rows.</p> </li> <li> <p><code>int stride</code> : Stride = (number of elements in a row) + padding.</p> </li> <li> <p><code>int element</code> : Number of elements = rows * cols.</p> </li> <li> <p><code>int memory</code> : Size of the data buffer = rows * stride.</p> </li> <li> <p><code>float *data</code> : Pointer to the data buffer.</p> </li> <li> <p><code>float *temp</code> : Pointer to the temporary data buffer.</p> </li> <li> <p><code>bool ext_buff</code> : Flag indicating that the matrix uses an external buffer.</p> </li> <li> <p><code>bool sub_matrix</code> : Flag indicating that the matrix is a subset of another matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#roi-structure","title":"ROI STRUCTURE","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#metadata","title":"Metadata","text":"<ul> <li> <p><code>int pos_x</code> : Starting column index.</p> </li> <li> <p><code>int pos_y</code> : Starting row index.</p> </li> <li> <p><code>int width</code> : Width of the ROI (columns).</p> </li> <li> <p><code>int height</code> : Height of the ROI (rows).</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#roi-constructor","title":"ROI Constructor","text":"<pre><code>Mat::ROI::ROI(int pos_x = 0, int pos_y = 0, int width = 0, int height = 0);\n</code></pre> <p>Description: ROI constructor initializes the ROI with the specified position and size.</p> <p>Parameters:</p> <ul> <li> <p><code>int pos_x</code> : Starting column index.</p> </li> <li> <p><code>int pos_y</code> : Starting row index.</p> </li> <li> <p><code>int width</code> : Width of the ROI (columns).</p> </li> <li> <p><code>int height</code> : Height of the ROI (rows).</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#roi-resize","title":"ROI RESIZE","text":"<pre><code>void Mat::ROI::resize_roi(int pos_x, int pos_y, int width, int height);\n</code></pre> <p>Description: Resizes the ROI to the specified position and size.</p> <p>Parameters:</p> <ul> <li> <p><code>int pos_x</code> : Starting column index.</p> </li> <li> <p><code>int pos_y</code> : Starting row index.</p> </li> <li> <p><code>int width</code> : Width of the ROI (columns).</p> </li> <li> <p><code>int height</code> : Height of the ROI (rows).</p> </li> </ul> <p>Returns: void</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#area-roi","title":"AREA ROI","text":"<pre><code>int Mat::ROI::area_roi(void) const;\n</code></pre> <p>Description: Calculates the area of the ROI.</p> <p>Parameters: void</p> <p>Returns: int - Area of the ROI.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#print-function","title":"PRINT FUNCTION","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#print-matrix-information","title":"Print matrix information","text":"<pre><code>void print_info() const;\n</code></pre> <p>Description : Prints the matrix information including number of rows, columns, elements, paddings, stride, memory size (size of float), data buffer address, temporary buffer address, indicators whether the matrix uses an external buffer, and whether it is a sub-matrix.</p> <p>Parameters: void</p> <p>Returns: void</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#print-matrix-elements","title":"Print matrix elements","text":"<pre><code>void Mat::print_matrix(bool show_padding);\n</code></pre> <p>Description: Prints the matrix elements. If <code>show_padding</code> is true, it will also print the padding values.</p> <p>Parameters: </p> <ul> <li><code>bool show_padding</code> - If true, show padding values.</li> </ul> <p>Returns: void</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#constructors-destructor","title":"CONSTRUCTORS &amp; DESTRUCTOR","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#default-constructor","title":"Default Constructor","text":"<pre><code>Mat::Mat();\n</code></pre> <p>Description: Default constructor initializes the matrix with default values. This function will create a matrix with only one row and one column, and the only element is set to 0.</p> <p>Parameters: void</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#constructor-matint-rows-int-cols","title":"Constructor - Mat(int rows, int cols)","text":"<pre><code>Mat::Mat(int rows, int cols);\n</code></pre> <p>Description: Constructor initializes the matrix with the specified number of rows and columns.</p> <p>Parameters:</p> <ul> <li> <p><code>int rows</code> : Number of rows.</p> </li> <li> <p><code>int cols</code> : Number of columns.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#constructor-matint-rows-int-cols-int-stride","title":"Constructor - Mat(int rows, int cols, int stride)","text":"<pre><code>Mat::Mat(int rows, int cols, int stride);\n</code></pre> <p>Description: Constructor initializes the matrix with the specified number of rows, columns, and stride.</p> <p>Parameters:</p> <ul> <li> <p><code>int rows</code> : Number of rows.</p> </li> <li> <p><code>int cols</code> : Number of columns.</p> </li> <li> <p><code>int stride</code> : Stride.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#constructor-matfloat-data-int-rows-int-cols","title":"Constructor - Mat(float *data, int rows, int cols)","text":"<pre><code>Mat::Mat(float *data, int rows, int cols);\n</code></pre> <p>Description: Constructor initializes the matrix with the specified data buffer, number of rows, and columns.</p> <p>Parameters:</p> <ul> <li> <p><code>float *data</code> : Pointer to the data buffer.</p> </li> <li> <p><code>int rows</code> : Number of rows.</p> </li> <li> <p><code>int cols</code> : Number of columns.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#constructor-matfloat-data-int-rows-int-cols-int-stride","title":"Constructor - Mat(float *data, int rows, int cols, int stride)","text":"<pre><code>Mat(float *data, int rows, int cols, int stride);\n</code></pre> <p>Description: Constructor initializes the matrix with the specified data buffer, number of rows, columns, and stride.</p> <p>Parameters:</p> <ul> <li> <p><code>float *data</code> : Pointer to the data buffer.</p> </li> <li> <p><code>int rows</code> : Number of rows.</p> </li> <li> <p><code>int cols</code> : Number of columns.</p> </li> <li> <p><code>int stride</code> : Stride.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#constructor-matconst-mat-src","title":"Constructor - Mat(const Mat &amp;src)","text":"<pre><code>Mat::Mat(const Mat &amp;src);\n</code></pre> <p>Description: Copy constructor initializes the matrix with the specified source matrix.</p> <p>Parameters:</p> <ul> <li><code>const Mat &amp;src</code> : Source matrix.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#destructor","title":"Destructor","text":"<pre><code>Mat::~Mat();\n</code></pre> <p>Description: Destructor releases the allocated memory for the matrix.</p> <p>Parameters: void</p> <p>Note</p> <p>For constructor functions, it must has the same name as the class name, and it must not have a return type. As shown, for C++, the function name can be reloaded by changing the number and order of the parameters as long as the permutation of the parameters is different. The destructor will be automatically called when the object goes out of scope.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#element-access","title":"ELEMENT ACCESS","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#access-matrix-elements-non-const","title":"Access matrix elements - non const","text":"<pre><code>inline float &amp;operator()(int row, int col);\n</code></pre> <p>Description: Accesses the matrix elements using the specified row and column indices.</p> <p>Parameters\uff1a</p> <ul> <li> <p><code>int row</code> : Row index.</p> </li> <li> <p><code>int col</code> : Column index.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#access-matrix-elements-const","title":"Access matrix elements - const","text":"<pre><code>inline const float &amp;operator()(int row, int col) const;\n</code></pre> <p>Description: Accesses the matrix elements using the specified row and column indices (const version).</p> <p>Parameters\uff1a</p> <ul> <li> <p><code>int row</code> : Row index.</p> </li> <li> <p><code>int col</code> : Column index.</p> </li> </ul> <p>Note</p> <p>These two functions are in fact redefining the <code>()</code> operator, which allows you to access the elements of the matrix using the syntax <code>matrix(row, col)</code>.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#data-manipulation","title":"DATA MANIPULATION","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#copy-other-matrix-into-this-matrix-as-a-sub-matrix","title":"Copy other matrix into this matrix as a sub-matrix","text":"<pre><code>tiny_error_t Mat::copy_paste(const Mat &amp;src, int row_pos, int col_pos);\n</code></pre> <p>Description: Copies the specified source matrix into this matrix as a sub-matrix starting from the specified row and column positions, not sharing the data buffer.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;src</code> : Source matrix.</p> </li> <li> <p><code>int row_pos</code> : Starting row position.</p> </li> <li> <p><code>int col_pos</code> : Starting column position.</p> </li> </ul> <p>***Returns**: tiny_error_t - Error code.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#copy-header-of-other-matrix-to-this-matrix","title":"Copy header of other matrix to this matrix","text":"<pre><code>tiny_error_t Mat::copy_head(const Mat &amp;src);\n</code></pre> <p>Description: Copies the header of the specified source matrix to this matrix, sharing the data buffer. All items copy the source matrix.</p> <p>Parameters:</p> <ul> <li><code>const Mat &amp;src</code> : Source matrix.</li> </ul> <p>Returns: tiny_error_t - Error code.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#get-a-view-shallow-copy-of-sub-matrix-roi-from-this-matrix","title":"Get a view (shallow copy) of sub-matrix (ROI) from this matrix","text":"<pre><code>Mat Mat::view_roi(int start_row, int start_col, int roi_rows, int roi_cols) const;\n</code></pre> <p>Description: Gets a view (shallow copy) of the sub-matrix (ROI) from this matrix starting from the specified row and column positions.</p> <p>Parameters:</p> <ul> <li> <p><code>int start_row</code> : Starting row position.</p> </li> <li> <p><code>int start_col</code> : Starting column position.</p> </li> <li> <p><code>int roi_rows</code> : Number of rows in the ROI.</p> </li> <li> <p><code>int roi_cols</code> : Number of columns in the ROI.</p> </li> </ul> <p>Warning</p> <p>Unlike ESP-DSP, view_roi does not allow to setup stride as it will automatically calculate the stride based on the number of columns and paddings. The function will also refuse illegal requests, i.e., out of bound requests. </p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#get-a-view-shallow-copy-of-sub-matrix-roi-from-this-matrix-using-roi-structure","title":"Get a view (shallow copy) of sub-matrix (ROI) from this matrix using ROI structure","text":"<pre><code>Mat Mat::view_roi(const Mat::ROI &amp;roi) const;\n</code></pre> <p>Description: Gets a view (shallow copy) of the sub-matrix (ROI) from this matrix using the specified ROI structure. This function will call the previous function in low level by passing the ROI structure to the parameters.</p> <p>Parameters:</p> <ul> <li><code>const Mat::ROI &amp;roi</code> : ROI structure.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#get-a-replica-deep-copy-of-sub-matrix-roi","title":"Get a replica (deep copy) of sub-matrix (ROI)","text":"<pre><code>Mat Mat::copy_roi(int start_row, int start_col, int roi_rows, int roi_cols);\n</code></pre> <p>Description: Gets a replica (deep copy) of the sub-matrix (ROI) from this matrix starting from the specified row and column positions. This function will return a new matrix object that does not share the data buffer with the original matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>int start_row</code> : Starting row position.</p> </li> <li> <p><code>int start_col</code> : Starting column position.</p> </li> <li> <p><code>int roi_rows</code> : Number of rows in the ROI.</p> </li> <li> <p><code>int roi_cols</code> : Number of columns in the ROI.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#get-a-replica-deep-copy-of-sub-matrix-roi-using-roi-structure","title":"Get a replica (deep copy) of sub-matrix (ROI) using ROI structure","text":"<pre><code>Mat Mat::copy_roi(const Mat::ROI &amp;roi);\n</code></pre> <p>Description: Gets a replica (deep copy) of the sub-matrix (ROI) from this matrix using the specified ROI structure. This function will call the previous function in low level by passing the ROI structure to the parameters.</p> <p>Parameters:</p> <ul> <li><code>const Mat::ROI &amp;roi</code> : ROI structure.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#get-a-block-of-matrix","title":"Get a block of matrix","text":"<pre><code>Mat Mat::block(int start_row, int start_col, int block_rows, int block_cols);\n</code></pre> <p>Description: Gets a block of the matrix starting from the specified row and column positions.</p> <p>Parameters:</p> <ul> <li> <p><code>int start_row</code> : Starting row position.</p> </li> <li> <p><code>int start_col</code> : Starting column position.</p> </li> <li> <p><code>int block_rows</code> : Number of rows in the block.</p> </li> <li> <p><code>int block_cols</code> : Number of columns in the block.</p> </li> </ul> <p>Differences between view_roi | copy_roi | block</p> <ul> <li> <p><code>view_roi</code> : Shallow copy of the sub-matrix (ROI) from this matrix.</p> </li> <li> <p><code>copy_roi</code> : Deep copy of the sub-matrix (ROI) from this matrix. Rigid and faster.</p> </li> <li> <p><code>block</code> : Deep copy of the block from this matrix. Flexible and slower.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#swap-rows","title":"Swap rows","text":"<pre><code>void Mat::swap_rows(int row1, int row2);\n</code></pre> <p>Description: Swaps the specified rows in the matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>int row1</code> : First row index.</p> </li> <li> <p><code>int row2</code> : Second row index.</p> </li> </ul> <p>Returns: void</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#clear-matrix","title":"Clear matrix","text":"<pre><code>void Mat::clear(void);\n</code></pre> <p>Description: Clears the matrix by setting all elements to zero.</p> <p>Parameters: void</p> <p>Returns: void</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#arithmetic-operators","title":"ARITHMETIC OPERATORS","text":"<p>Note</p> <p>This section defines the arithmetic operators that act on the current matrix itself. The operators are overloaded to perform matrix operations.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#copy-assignment","title":"Copy assignment","text":"<pre><code>Mat &amp;operator=(const Mat &amp;src);\n</code></pre> <p>Description: Copy assignment operator for the matrix.</p> <p>Parameters:</p> <ul> <li><code>const Mat &amp;src</code> : Source matrix.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#add-matrix","title":"Add matrix","text":"<pre><code>Mat &amp;operator+=(const Mat &amp;A);\n</code></pre> <p>Description: Adds the specified matrix to this matrix.</p> <p>Parameters:</p> <ul> <li><code>const Mat &amp;A</code> : Matrix to be added.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#add-constant","title":"Add constant","text":"<pre><code>Mat &amp;operator+=(float C);\n</code></pre>"},{"location":"MATH/MATRIX/tiny-matrix-api/#sbtract-matrix","title":"Sbtract matrix","text":"<pre><code>Mat &amp;operator-=(const Mat &amp;A);\n</code></pre> <p>Description: Subtracts the specified matrix from this matrix.</p> <p>Parameters:</p> <ul> <li><code>const Mat &amp;A</code> : Matrix to be subtracted.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#subtract-constant","title":"Subtract constant","text":"<pre><code>Mat &amp;operator-=(float C);\n</code></pre> <p>Description: Subtracts the specified constant from this matrix.</p> <p>***Parameters**:</p> <ul> <li><code>float C</code> : Constant to be subtracted.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#multiply-matrix","title":"Multiply matrix","text":"<pre><code>Mat &amp;operator*=(const Mat &amp;A);\n</code></pre> <p>Description: Multiplies this matrix by the specified matrix.</p> <p>Parameters:</p> <ul> <li><code>const Mat &amp;A</code> : Matrix to be multiplied.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#multiply-constant","title":"Multiply constant","text":"<pre><code>Mat &amp;operator*=(float C);\n</code></pre> <p>Description: Multiplies this matrix by the specified constant.</p> <p>Parameters:</p> <ul> <li><code>float C</code> : Constant to be multiplied.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#divide-matrix-element-wise","title":"Divide matrix (element-wise)","text":"<pre><code>Mat &amp;operator/=(const Mat &amp;B);\n</code></pre> <p>Description: Divides this matrix by the specified matrix element-wise.</p> <p>Parameters:</p> <ul> <li><code>const Mat &amp;B</code> : Matrix to be divided by.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#divide-constant","title":"Divide constant","text":"<pre><code>Mat &amp;operator/=(float C);\n</code></pre> <p>Description: Divides this matrix by the specified constant.</p> <p>Parameters:</p> <ul> <li><code>float C</code> : Constant to be divided by.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#exponentiation","title":"Exponentiation","text":"<pre><code>Mat operator^(int C);\n</code></pre> <p>Description: Raises this matrix to the specified power.</p> <p>Parameters:</p> <ul> <li><code>int C</code> : Exponent.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#linear-algebra","title":"LINEAR ALGEBRA","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#transpose","title":"Transpose","text":"<pre><code>Mat::transpose();\n</code></pre> <p>Description: Calculates the transpose of the matrix, returning a new matrix.</p> <p>Parameters: None.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#cofactor","title":"cofactor","text":"<pre><code>Mat::cofactor(int row, int col);\n</code></pre> <p>Description: Extracts the cofactor matrix from the specified row and column.</p> <p>Parameters: </p> <ul> <li> <p><code>int row</code>: Number of the row to be excluded.</p> </li> <li> <p><code>int col</code>: Number of the column to be excluded.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#determinant","title":"Determinant","text":"<pre><code>float Mat::determinant();\n</code></pre> <p>Description: Calculates the determinant of the matrix. It is based on cofactor and adjoint matrices.</p> <p>Parameters: None.</p> <p>Returns: float - Determinant value.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#adjoint","title":"Adjoint","text":"<pre><code>Mat::adjoint();\n</code></pre> <p>Description: Calculates the adjoint of the matrix.</p> <p>Parameters: None.</p> <p>Returns: Mat - Adjoint matrix.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#normalize","title":"Normalize","text":"<pre><code>void Mat::normalize();\n</code></pre> <p>Description: Normalizes the matrix.</p> <p>Parameters: None.</p> <p>Returns: void</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#norm","title":"Norm","text":"<pre><code>float Mat::norm() const;\n</code></pre> <p>Description: Calculates the norm of the matrix.</p> <p>Parameters: None.</p> <p>Returns: float - Norm value.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#inverse-using-adjoint","title":"Inverse using Adjoint","text":"<pre><code>Mat::inverse_adjoint();\n</code></pre> <p>Description: Calculates the inverse of the matrix using the adjoint method.</p> <p>Parameters: None.</p> <p>Returns: Mat - Inverse matrix.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#identity-matrix","title":"Identity matrix","text":"<pre><code>static Mat::eye(int size);\n</code></pre> <p>Description: Creates an identity matrix of the specified size.</p> <p>Parameters: </p> <ul> <li><code>int size</code> : Size of the identity matrix.</li> </ul> <p>Returns: Mat - Identity matrix.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#augmentation-matrix","title":"Augmentation Matrix","text":"<pre><code>static Mat::augment(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>Description: Creates an augmented matrix by combining two matrices.</p> <p>Parameters:</p> <ul> <li><code>const Mat &amp;A</code> : First matrix.</li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#identity-matrix_1","title":"identity matrix","text":"<pre><code>static Mat::ones(int rows, int cols);\n</code></pre> <p>Description: Creates a matrix filled with ones of the specified size.</p> <p>Parameters:</p> <ul> <li> <p><code>int rows</code> : Number of rows.</p> </li> <li> <p><code>int cols</code> : Number of columns.</p> </li> </ul> <p>Returns: Mat - Matrix filled with ones.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#all-ones-matrix","title":"All-Ones matrix","text":"<pre><code>static Mat::ones(int rows, int cols);\n</code></pre> <p>Description: Creates a matrix filled with ones of the specified size.</p> <p>Parameters:</p> <ul> <li> <p><code>int rows</code> : Number of rows.</p> </li> <li> <p><code>int cols</code> : Number of columns.</p> </li> </ul> <p>Returns: Mat - Matrix filled with ones.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#all-ones-matrix_1","title":"All-Ones matrix","text":"<pre><code>static Mat::ones(int size);\n</code></pre> <p>Description: Creates a square matrix filled with ones of the specified size.</p> <p>Parameters:</p> <ul> <li><code>int size</code> : Size of the square matrix.</li> </ul> <p>Returns: Mat - Square matrix filled with ones.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#gaussian-elimination","title":"Gaussian Elimination","text":"<pre><code>Mat::gaussian_eliminate() const;\n</code></pre> <p>Description: Performs Gaussian elimination on the matrix.</p> <p>Parameters: None.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#row-reduce-from-gaussian-elimination","title":"row reduce from Gaussian elimination","text":"<pre><code>Mat::row_reduce_from_gaussian();\n</code></pre> <p>Description: Performs row reduction from Gaussian elimination on the matrix.</p> <p>Parameters: None.</p> <p>Returns: Mat - Row reduced matrix.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#inverse-using-gaussian-jordan-elimination","title":"Inverse using Gaussian-Jordan elimination","text":"<pre><code>Mat::inverse_gje();\n</code></pre> <p>Description: Calculates the inverse of the matrix using Gaussian-Jordan elimination.</p> <p>Parameters: None.</p> <p>Returns: Mat - Inverse matrix.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#dot-product","title":"Dot Product","text":"<pre><code>float Mat::dotprod(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>Description: Calculates the dot product of two matrices.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code> : First matrix.</p> </li> <li> <p><code>const Mat &amp;B</code> : Second matrix.</p> </li> </ul> <p>Returns: float - Dot product value.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#solve-linear-system","title":"Solve Linear System","text":"<pre><code>Mat Mat::solve(const Mat &amp;A, const Mat &amp;b);\n</code></pre> <p>Description: Solves the linear system Ax = b.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code> : Coefficient matrix.</p> </li> <li> <p><code>const Mat &amp;b</code> : Right-hand side matrix.</p> </li> </ul> <p>Returns: Mat - Solution matrix.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#band-solve","title":"Band Solve","text":"<pre><code>Mat Mat::band_solve(Mat A, Mat b, int k);\n</code></pre> <p>Description: Solves a banded linear system.</p> <p>Parameters:</p> <ul> <li> <p><code>Mat A</code> : Coefficient matrix.</p> </li> <li> <p><code>Mat b</code> : Right-hand side matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#band-solve_1","title":"Band Solve","text":"<pre><code>Mat Mat::band_solve(Mat A, Mat b, int k);\n</code></pre> <p>Description: Solves a banded linear system.</p> <p>Parameters:</p> <ul> <li> <p><code>Mat A</code> : Coefficient matrix.</p> </li> <li> <p><code>Mat b</code> : Right-hand side matrix.</p> </li> <li> <p><code>int k</code> : Bandwidth.</p> </li> </ul> <p>Returns: Mat - Solution matrix.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#roots","title":"Roots","text":"<pre><code>Mat Mat::roots(Mat A, Mat y);\n</code></pre> <p>Description: Calculates the roots of a polynomial represented by the matrix A.</p> <p>Parameters:</p> <ul> <li> <p><code>Mat A</code> : Coefficient matrix.</p> </li> <li> <p><code>Mat y</code> : Right-hand side matrix.</p> </li> </ul> <p>Returns: Mat - Roots matrix.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#stream-operators","title":"STREAM OPERATORS","text":""},{"location":"MATH/MATRIX/tiny-matrix-api/#matrix-output-stream-operator","title":"Matrix output stream operator","text":"<pre><code>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat &amp;m);\n</code></pre> <p>Description: Overloaded output stream operator for the matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>std::ostream &amp;os</code> : Output stream.</p> </li> <li> <p><code>const Mat &amp;m</code> : Matrix to be output.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#roi-output-stream-operator","title":"ROI output stream operator","text":"<pre><code>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat::ROI &amp;roi);\n</code></pre> <p>Description: Overloaded output stream operator for the ROI structure.</p> <p>Parameters:</p> <ul> <li> <p><code>std::ostream &amp;os</code> : Output stream.</p> </li> <li> <p><code>const Mat::ROI &amp;roi</code> : ROI structure.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#matrix-input-stream-operator","title":"Matrix input stream operator","text":"<pre><code>std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Mat &amp;m);\n</code></pre> <p>Description: Overloaded input stream operator for the matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>std::istream &amp;is</code> : Input stream.</p> </li> <li> <p><code>Mat &amp;m</code> : Matrix to be input.</p> </li> </ul> <p>Tip</p> <p>This section is actually kind of overlapping with print function in terms of showing the matrix.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#global-arithmetic-operators","title":"GLOBAL ARITHMETIC OPERATORS","text":"<p>Tip</p> <p>The operators in this section return a new matrix object, which is the result of the operation. The original matrices remain unchanged. Unlike the previous section, the operators are designed to perform operation acting on the current matrix itself.</p>"},{"location":"MATH/MATRIX/tiny-matrix-api/#add-matrix_1","title":"Add matrix","text":"<pre><code>Mat operator+(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>Description: Adds the specified matrices.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code> : First matrix.</p> </li> <li> <p><code>const Mat &amp;B</code> : Second matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#add-constant_1","title":"Add constant","text":"<pre><code>Mat operator+(const Mat &amp;A, float C);\n</code></pre> <p>Description: Adds the specified constant to the matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code> : Matrix to be added.</p> </li> <li> <p><code>float C</code> : Constant to be added.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#subtract-matrix","title":"Subtract matrix","text":"<pre><code>Mat operator-(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>Description: Subtracts the specified matrices.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code> : First matrix.</p> </li> <li> <p><code>const Mat &amp;B</code> : Second matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#subtract-constant_1","title":"Subtract constant","text":"<pre><code>Mat operator-(const Mat &amp;A, float C);\n</code></pre> <p>Description: Subtracts the specified constant from the matrix.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code> : Matrix to be subtracted.</p> </li> <li> <p><code>float C</code> : Constant to be subtracted.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#multiply-matrix_1","title":"Multiply matrix","text":"<pre><code>Mat operator*(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>Description: Multiplies the specified matrices.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code> : First matrix.</p> </li> <li> <p><code>const Mat &amp;B</code> : Second matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#multiply-constant_1","title":"Multiply constant","text":"<pre><code>Mat operator*(const Mat &amp;A, float C);\n</code></pre> <p>Description: Multiplies the specified matrix by the constant.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code> : Matrix to be multiplied.</p> </li> <li> <p><code>float C</code> : Constant to be multiplied.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#multiply-constant_2","title":"Multiply constant","text":"<pre><code>Mat operator*(float C, const Mat &amp;A);\n</code></pre> <p>Description: Multiplies the specified matrix by the constant.</p> <p>Parameters:</p> <ul> <li> <p><code>float C</code> : Constant to be multiplied.</p> </li> <li> <p><code>const Mat &amp;A</code> : Matrix to be multiplied.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#multiply-constant-with-constant-on-the-left","title":"Multiply constant with constant on the left","text":"<pre><code>Mat operator*(float C, const Mat &amp;A);\n</code></pre> <p>Description: Multiplies the specified matrix by the constant.</p> <p>Parameters:</p> <ul> <li> <p><code>float C</code> : Constant to be multiplied.</p> </li> <li> <p><code>const Mat &amp;A</code> : Matrix to be multiplied.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#divide-matrix-by-constant","title":"Divide matrix (by constant)","text":"<pre><code>Mat operator/(const Mat &amp;A, float C);\n</code></pre> <p>Description: Divides the specified matrix by the constant element-wise.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code> : Matrix to be divided.</p> </li> <li> <p><code>float C</code> : Constant to divide by.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#divide-matrix-element-wise_1","title":"Divide matrix (element-wise)","text":"<pre><code>Mat operator/(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>Description: Divides the specified matrices element-wise.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code> : First matrix.</p> </li> <li> <p><code>const Mat &amp;B</code> : Second matrix.</p> </li> </ul>"},{"location":"MATH/MATRIX/tiny-matrix-api/#equality-check","title":"Equality check","text":"<pre><code>bool operator==(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>Description: Checks if the specified matrices are equal.</p> <p>Parameters:</p> <ul> <li> <p><code>const Mat &amp;A</code> : First matrix.</p> </li> <li> <p><code>const Mat &amp;B</code> : Second matrix.</p> </li> </ul> <p>Returns: bool - true if equal, false otherwise.</p>"},{"location":"MATH/MATRIX/tiny-matrix-code/","title":"CODE","text":""},{"location":"MATH/MATRIX/tiny-matrix-code/#tiny_matrixhpp","title":"tiny_matrix.hpp","text":"<pre><code>/**\n * @file tiny_matrix.hpp\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the submodule matrix (advanced matrix operations) of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-17\n * @note This file is built on top of the mat.h file from the ESP-DSP library.\n *\n */\n\n#pragma once\n\n/* DEPENDENCIES */\n// TinyMath\n#include \"tiny_math_config.h\"\n#include \"tiny_vec.h\"\n#include \"tiny_mat.h\"\n\n// Standard Libraries\n#include &lt;iostream&gt;\n#include &lt;stdint.h&gt;\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n// ESP32 DSP C++ Matrix library\n#include \"mat.h\"\n#endif\n\n/* STATEMENTS */\nnamespace tiny\n{\n    class Mat\n    {\n    public:\n        /* === Matrix Metadata === */\n        int row;         //&lt; number of rows\n        int col;         //&lt; number of columns\n        int pad;         //&lt; number of paddings between 2 rows\n        int stride;      //&lt; stride = (number of elements in a row) + padding\n        int element;     //&lt; number of elements = rows * cols\n        int memory;      //&lt; size of the data buffer = rows * stride\n        float *data;     //&lt; pointer to the data buffer\n        float *temp;     //&lt; pointer to the temporary data buffer\n        bool ext_buff;   //&lt; flag indicates that matrix use external buffer\n        bool sub_matrix; //&lt; flag indicates that matrix is a subset of another matrix\n\n        /* === Rectangular ROI Structure === */\n        struct ROI\n        {\n            int pos_x;  ///&lt; starting column index\n            int pos_y;  ///&lt; starting row index\n            int width;  ///&lt; width of ROI (columns)\n            int height; ///&lt; height of ROI (rows)\n\n            // ROI constructor\n            ROI(int pos_x = 0, int pos_y = 0, int width = 0, int height = 0);\n\n            // resize ROI\n            void resize_roi(int pos_x, int pos_y, int width, int height);\n\n            // calculate area of ROI\n            int area_roi(void) const;\n        };\n\n        /* === Printing Functions === */\n        // print matrix info\n        void print_info() const;\n\n        // print matrix elements, paddings optional\n        void print_matrix(bool show_padding);\n\n        /* === Constructors &amp; Destructor === */\n        // memory allocation\n        void alloc_mem(); // Allocate internal memory\n\n        // constructor\n        Mat();\n        Mat(int rows, int cols);\n        Mat(int rows, int cols, int stride);\n        Mat(float *data, int rows, int cols);\n        Mat(float *data, int rows, int cols, int stride);\n        Mat(const Mat &amp;src);\n\n        // destructor\n        ~Mat();\n\n        /* === Element Access === */\n        // access matrix elements - non const\n        inline float &amp;operator()(int row, int col) { return data[row * stride + col]; }\n\n        // access matrix elements - const             \n        inline const float &amp;operator()(int row, int col) const { return data[row * stride + col]; }\n\n        /* === Data Manipulation === */\n        // copy other matrix into this matrix as a sub-matrix\n        tiny_error_t copy_paste(const Mat &amp;src, int row_pos, int col_pos);\n\n        // copy header of other matrix to this matrix\n        tiny_error_t copy_head(const Mat &amp;src);\n\n        // get a view (shallow copy) of sub-matrix (ROI) from this matrix\n        Mat view_roi(int start_row, int start_col, int roi_rows, int roi_cols) const;\n\n        // get a view (shallow copy) of sub-matrix (ROI) from this matrix using ROI structure\n        Mat view_roi(const Mat::ROI &amp;roi) const;\n\n        // get a replica (deep copy) of sub-matrix (ROI) \n        Mat copy_roi(int start_row, int start_col, int roi_rows, int roi_cols);\n\n        // get a replica (deep copy) of sub-matrix (ROI) using ROI structure\n        Mat copy_roi(const Mat::ROI &amp;roi);\n\n        // get a block of matrix\n        Mat block(int start_row, int start_col, int block_rows, int block_cols);\n\n        // swap rows\n        void swap_rows(int row1, int row2);\n\n        // clear matrix\n        void clear(void);\n\n        /* === Arithmetic Operators === */\n        Mat &amp;operator=(const Mat &amp;src);    // Copy assignment\n        Mat &amp;operator+=(const Mat &amp;A);     // Add matrix\n        Mat &amp;operator+=(float C);          // Add constant\n        Mat &amp;operator-=(const Mat &amp;A);     // Subtract matrix\n        Mat &amp;operator-=(float C);          // Subtract constant \n        Mat &amp;operator*=(const Mat &amp;A);     // Multiply matrix\n        Mat &amp;operator*=(float C);          // Multiply constant\n        Mat &amp;operator/=(const Mat &amp;B);     // Divide matrix\n        Mat &amp;operator/=(float C);          // Divide constant\n        Mat operator^(int C);              // Exponentiation\n\n        /* === Linear Algebra === */\n        Mat transpose();                   // Transpose matrix\n        Mat cofactor(int row, int col);    // cofactor matrix extraction\n        float determinant();\n        Mat adjoint(); \n        void normalize();\n        float norm() const;\n        Mat inverse_adjoint();\n        static Mat eye(int size);\n        static Mat augment(const Mat &amp;A, const Mat &amp;B);\n        static Mat ones(int rows, int cols);\n        static Mat ones(int size);\n        Mat gaussian_eliminate() const;\n        Mat row_reduce_from_gaussian();\n        Mat inverse_gje(); // Inverse using Gaussian-Jordan elimination\n        float dotprod(const Mat &amp;A, const Mat &amp;B);\n        Mat solve(const Mat &amp;A, const Mat &amp;b);\n        Mat band_solve(Mat A, Mat b, int k);\n        Mat roots(Mat A, Mat y);\n\n    protected:\n\n    private:\n\n    };\n\n    /* === Stream Operators === */\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat &amp;m);\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat::ROI &amp;roi);\n    std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Mat &amp;m);\n\n    /* === Global Arithmetic Operators === */\n    Mat operator+(const Mat &amp;A, const Mat &amp;B);\n    Mat operator+(const Mat &amp;A, float C);\n    Mat operator-(const Mat &amp;A, const Mat &amp;B);\n    Mat operator-(const Mat &amp;A, float C);\n    Mat operator*(const Mat &amp;A, const Mat &amp;B);\n    Mat operator*(const Mat &amp;A, float C);\n    Mat operator*(float C, const Mat &amp;A);\n    Mat operator/(const Mat &amp;A, float C);\n    Mat operator/(const Mat &amp;A, const Mat &amp;B);\n    bool operator==(const Mat &amp;A, const Mat &amp;B);\n\n}\n</code></pre>"},{"location":"MATH/MATRIX/tiny-matrix-code/#tiny_matrixcpp","title":"tiny_matrix.cpp","text":"<pre><code>/**\n * @file tiny_matrix.cpp\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the source file for the submodule matrix (advanced matrix operations) of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-17\n * @copyright Copyright (c) 2025\n *\n */\n\n/* DEPENDENCIES */\n// TinyMath\n#include \"tiny_matrix.hpp\"\n\n// Standard Libraries\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\n#include &lt;cmath&gt;\n#include &lt;inttypes.h&gt;\n#include &lt;iomanip&gt;\n\n/* LIBRARIE CONTENTS */\nnamespace tiny\n{\n    /* === Rectangular ROI Structure === */\n    /**\n     * @brief Construct a new Mat:: R O I:: R O I object\n     * \n     * @param pos_x \n     * @param pos_y \n     * @param width \n     * @param height \n     */\n    Mat::ROI::ROI(int pos_x, int pos_y, int width, int height)\n    {\n        this-&gt;pos_x = pos_x;\n        this-&gt;pos_y = pos_y;\n        this-&gt;width = width;\n        this-&gt;height = height;\n    }\n\n    /**\n     * @brief resize the ROI structure\n     * \n     * @param pos_x starting column\n     * @param pos_y starting row\n     * @param width number of columns\n     * @param height number of rows\n     */\n    void Mat::ROI::resize_roi(int pos_x, int pos_y, int width, int height)\n    {\n        this-&gt;pos_x = pos_x;\n        this-&gt;pos_y = pos_y;\n        this-&gt;width = width;\n        this-&gt;height = height;\n    }\n\n    /**\n     * @brief calculate the area of the ROI structure - how many elements covered\n     * \n     * @return int \n     */\n    int Mat::ROI::area_roi(void) const\n    {\n        return this-&gt;width * this-&gt;height;\n    }\n\n    /* === Printing Functions === */\n    /**\n     * @name Mat::PrintHead()\n     * @brief Print the header of the matrix.\n     */\n    void Mat::print_info() const\n    {\n        std::cout &lt;&lt; \"Matrix Info &gt;&gt;&gt;\\n\";\n\n        // Basic matrix metadata\n        std::cout &lt;&lt; \"rows            \" &lt;&lt; this-&gt;row &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"cols            \" &lt;&lt; this-&gt;col &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"elements        \" &lt;&lt; this-&gt;element;\n\n        // Check if elements match rows * cols\n        if (this-&gt;element != this-&gt;row * this-&gt;col)\n        {\n            std::cout &lt;&lt; \"   [Warning] Mismatch! Expected: \" &lt;&lt; (this-&gt;row * this-&gt;col);\n        }\n        std::cout &lt;&lt; \"\\n\";\n\n        std::cout &lt;&lt; \"paddings        \" &lt;&lt; this-&gt;pad &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"stride          \" &lt;&lt; this-&gt;stride &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"memory          \" &lt;&lt; this-&gt;memory &lt;&lt; \"\\n\";\n\n        // Pointer information\n        std::cout &lt;&lt; \"data pointer    \" &lt;&lt; static_cast&lt;const void *&gt;(this-&gt;data) &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"temp pointer    \" &lt;&lt; static_cast&lt;const void *&gt;(this-&gt;temp) &lt;&lt; \"\\n\";\n\n        // Flags information\n        std::cout &lt;&lt; \"ext_buff        \" &lt;&lt; this-&gt;ext_buff;\n        if (this-&gt;ext_buff)\n        {\n            std::cout &lt;&lt; \"   (External buffer or View)\";\n        }\n        std::cout &lt;&lt; \"\\n\";\n\n        std::cout &lt;&lt; \"sub_matrix      \" &lt;&lt; this-&gt;sub_matrix;\n        if (this-&gt;sub_matrix)\n        {\n            std::cout &lt;&lt; \"   (This is a Sub-Matrix View)\";\n        }\n        std::cout &lt;&lt; \"\\n\";\n\n        // State warnings\n        if (this-&gt;sub_matrix &amp;&amp; !this-&gt;ext_buff)\n        {\n            std::cout &lt;&lt; \"[Warning] Sub-matrix is marked but ext_buff is false! Potential logic error.\\n\";\n        }\n\n        if (this-&gt;data == nullptr)\n        {\n            std::cout &lt;&lt; \"[Info] No data buffer assigned to this matrix.\\n\";\n        }\n\n        std::cout &lt;&lt; \"&lt;&lt;&lt; Matrix Info\\n\";\n    }\n\n    /**\n     * @name Mat::print_matrix()\n     * @brief Print the matrix elements.\n     *\n     * @param show_padding If true, print the padding elements as well.\n     */\n    void Mat::print_matrix(bool show_padding)\n    {\n        std::cout &lt;&lt; \"Matrix Elements &gt;&gt;&gt;\\n\";\n        for (int i = 0; i &lt; this-&gt;row; ++i)\n        {\n            // print the non-padding elements\n            for (int j = 0; j &lt; this-&gt;col; ++j)\n            {\n                std::cout &lt;&lt; std::setw(12) &lt;&lt; this-&gt;data[i * this-&gt;stride + j] &lt;&lt; \" \";\n            }\n\n            // if padding is enabled, print the padding elements\n            if (show_padding)\n            {\n                // print a separator first\n                std::cout &lt;&lt; \"      |\";\n\n                // print the padding elements\n                for (int j = this-&gt;col; j &lt; this-&gt;stride; ++j)\n                {\n                    if (j == this-&gt;col)\n                    {\n                        std::cout &lt;&lt; std::setw(7) &lt;&lt; this-&gt;data[i * this-&gt;stride + j] &lt;&lt; \" \";\n                    }\n                    else\n                    {\n                        // print the padding elements\n                        std::cout &lt;&lt; std::setw(12) &lt;&lt; this-&gt;data[i * this-&gt;stride + j] &lt;&lt; \" \";\n                    }\n                }\n            }\n\n            // print a new line after each row\n            std::cout &lt;&lt; \"\\n\";\n        }\n\n        std::cout &lt;&lt; \"&lt;&lt;&lt; Matrix Elements\\n\";\n        std::cout &lt;&lt; std::endl;\n    }\n\n    /* === Constructors &amp; Destructor === */\n    // memory allocation\n    /**\n     * @name Mat::allocate()\n     * @brief Allocate memory for the matrix according to the memory required.\n     */\n    void Mat::alloc_mem()\n    {\n        this-&gt;ext_buff = false;\n        this-&gt;memory = this-&gt;row * this-&gt;stride;\n        this-&gt;data = new float[this-&gt;memory];\n    }\n\n    /**\n     * @name Mat::Mat()\n     * @brief Constructor - default constructor: create a 1x1 matrix with only a zero element.\n     */\n    Mat::Mat()\n    {\n        this-&gt;row = 1;\n        this-&gt;col = 1;\n        this-&gt;pad = 0;\n        this-&gt;stride = 1;\n        this-&gt;element = 1;\n        this-&gt;memory = 1;\n        this-&gt;data = nullptr;\n        this-&gt;temp = nullptr;\n        this-&gt;ext_buff = false;\n        this-&gt;sub_matrix = false;\n        alloc_mem();\n        if (this-&gt;data == nullptr)\n        {\n            std::cerr &lt;&lt; \"[&gt;&gt;&gt; Error ! &lt;&lt;&lt;] Memory allocation failed in alloc_mem()\\n\";\n        }\n        std::memset(this-&gt;data, 0, this-&gt;memory * sizeof(float));\n    }\n\n    /**\n     * @name Mat::Mat(int rows, int cols)\n     * @brief Constructor - create a matrix with the specified number of rows and columns.\n     *\n     * @param rows Number of rows\n     * @param cols Number of columns\n     */\n    Mat::Mat(int rows, int cols)\n    {\n        this-&gt;row = rows;\n        this-&gt;col = cols;\n        this-&gt;pad = 0;\n        this-&gt;stride = cols;\n        this-&gt;element = rows * cols;\n        this-&gt;memory = rows * cols;\n        this-&gt;data = nullptr;\n        this-&gt;temp = nullptr;\n        this-&gt;ext_buff = false;\n        this-&gt;sub_matrix = false;\n        alloc_mem();\n        if (this-&gt;data == nullptr)\n        {\n            std::cerr &lt;&lt; \"[&gt;&gt;&gt; Error ! &lt;&lt;&lt;] Memory allocation failed in alloc_mem()\\n\";\n        }\n        std::memset(this-&gt;data, 0, this-&gt;memory * sizeof(float));\n    }\n    /**\n     * @name Mat::Mat(int rows, int cols, int stride)\n     * @brief Constructor - create a matrix with the specified number of rows, columns and stride.\n     *\n     * @param rows Number of rows\n     * @param cols Number of columns\n     * @param stride Stride (number of elements in a row)\n     */\n    Mat::Mat(int rows, int cols, int stride)\n    {\n        this-&gt;row = rows;\n        this-&gt;col = cols;\n        this-&gt;pad = stride - cols;\n        this-&gt;stride = stride;\n        this-&gt;element = rows * cols;\n        this-&gt;memory = rows * stride;\n        this-&gt;data = nullptr;\n        this-&gt;temp = nullptr;\n        this-&gt;ext_buff = false;\n        this-&gt;sub_matrix = false;\n        alloc_mem();\n        if (this-&gt;data == nullptr)\n        {\n            std::cerr &lt;&lt; \"[&gt;&gt;&gt; Error ! &lt;&lt;&lt;] Memory allocation failed in alloc_mem()\\n\";\n        }\n        std::memset(this-&gt;data, 0, this-&gt;memory * sizeof(float));\n    }\n\n    /**\n     * @name Mat::Mat(float *data, int rows, int cols)\n     * @brief Constructor - create a matrix with the specified number of rows, columns and external data.\n     *\n     * @param data Pointer to external data buffer\n     * @param rows Number of rows\n     * @param cols Number of columns\n     */\n    Mat::Mat(float *data, int rows, int cols)\n    {\n        this-&gt;row = rows;\n        this-&gt;col = cols;\n        this-&gt;pad = 0;\n        this-&gt;stride = cols;\n        this-&gt;element = rows * cols;\n        this-&gt;memory = rows * cols; // for external data, this item is actually not used\n        this-&gt;data = data;\n        this-&gt;temp = nullptr;\n        this-&gt;ext_buff = true;\n        this-&gt;sub_matrix = false;\n    }\n\n    /**\n     * @name Mat::Mat(float *data, int rows, int cols, int stride)\n     * @brief Constructor - create a matrix with the specified number of rows, columns and external data.\n     *\n     * @param data Pointer to external data buffer\n     * @param rows Number of rows\n     * @param cols Number of columns\n     * @param stride Stride (number of elements in a row)\n     */\n    Mat::Mat(float *data, int rows, int cols, int stride)\n    {\n        this-&gt;row = rows;\n        this-&gt;col = cols;\n        this-&gt;pad = stride - cols;\n        this-&gt;stride = stride;\n        this-&gt;element = rows * cols;\n        this-&gt;memory = rows * stride; // for external data, this item is actually not used\n        this-&gt;data = data;\n        this-&gt;temp = nullptr;\n        this-&gt;ext_buff = true;\n        this-&gt;sub_matrix = false;\n    }\n\n    /**\n     * @name Mat::Mat(const Mat &amp;src)\n     * @brief Copy constructor - create a matrix with the same properties as the source matrix.\n     *\n     * @param src Source matrix\n     */\n    Mat::Mat(const Mat &amp;src)\n    {\n        this-&gt;row = src.row;\n        this-&gt;col = src.col;\n        this-&gt;pad = src.pad;\n        this-&gt;stride = src.stride;\n        this-&gt;element = src.element;\n        this-&gt;memory = src.memory;\n\n        if (src.sub_matrix &amp;&amp; src.ext_buff)\n        {\n            // if the source is a view (submatrix), do shallow copy\n            this-&gt;data = src.data;\n            this-&gt;temp = nullptr;\n            this-&gt;ext_buff = true;\n            this-&gt;sub_matrix = true;\n        }\n        else\n        {\n            // otherwise do deep copy\n            this-&gt;data = nullptr;\n            this-&gt;temp = nullptr;\n            this-&gt;ext_buff = false;\n            this-&gt;sub_matrix = false;\n\n            if (src.data != nullptr)\n            {\n                alloc_mem();\n                if (this-&gt;data == nullptr)\n                {\n                    std::cerr &lt;&lt; \"[Error] Memory allocation failed in alloc_mem()\\n\";\n                }\n                std::memcpy(this-&gt;data, src.data, this-&gt;memory * sizeof(float));\n            }\n        }\n    }\n\n    /**\n     * @name ~Mat()\n     * @brief Destructor - free the memory allocated for the matrix.\n     */\n    Mat::~Mat()\n    {\n        if (!this-&gt;ext_buff &amp;&amp; this-&gt;data)\n        {\n            delete[] this-&gt;data;\n        }\n        if (this-&gt;temp)\n        {\n            delete[] this-&gt;temp;\n        }\n    }\n\n    /* === Element Access === */\n    // Already defined by inline functions in the header file\n\n    /* === Data Manipulation === */\n\n    /**\n     * @name Mat::copy_paste(const Mat &amp;src, int row_pos, int col_pos)\n     * @brief Copy the elements of the source matrix into the destination matrix. The dimension of the current matrix must be larger than the source matrix.\n     * @brief This one does not share memory with the source matrix.\n     *\n     * @param src Source matrix\n     * @param row_pos Start row position of the destination matrix\n     * @param col_pos Start column position of the destination matrix\n     */\n    tiny_error_t Mat::copy_paste(const Mat &amp;src, int row_pos, int col_pos)\n    {\n        if ((row_pos + src.row) &gt; this-&gt;row)\n        {\n            std::cerr &lt;&lt; \"[&gt;&gt;&gt; Error ! &lt;&lt;&lt;] Invalid row position \" &lt;&lt; std::endl;\n            return TINY_ERR_INVALID_ARG;\n        }\n        if ((col_pos + src.col) &gt; this-&gt;col)\n        {\n            std::cerr &lt;&lt; \"[&gt;&gt;&gt; Error ! &lt;&lt;&lt;] Invalid column position \" &lt;&lt; std::endl;\n            return TINY_ERR_INVALID_ARG;\n        }\n        for (size_t r = 0; r &lt; src.row; r++)\n        {\n            memcpy(&amp;this-&gt;data[(r + row_pos) * this-&gt;stride + col_pos], &amp;src.data[r * src.col], src.col * sizeof(float));\n        }\n\n        return TINY_OK;\n    }\n\n    /**\n     * @name Mat::copy_head(const Mat &amp;src)\n     * @brief Copy the header of the source matrix into the destination matrix. The data pointer is shared.\n     *\n     * @param src Source matrix\n     */\n    tiny_error_t Mat::copy_head(const Mat &amp;src)\n    {\n        if (!this-&gt;ext_buff)\n        {\n            delete[] this-&gt;data;\n        }\n        this-&gt;row = src.row;\n        this-&gt;col = src.col;\n        this-&gt;element = src.element;\n        this-&gt;pad = src.pad;\n        this-&gt;stride = src.stride;\n        this-&gt;memory = src.memory;\n        this-&gt;data = src.data;\n        this-&gt;temp = src.temp;\n        this-&gt;ext_buff = src.ext_buff;\n        this-&gt;sub_matrix = src.sub_matrix;\n\n        return TINY_OK;\n    }\n\n    /**\n     * @name Mat::view_roi(int start_row, int start_col, int roi_rows, int roi_cols)\n     * @brief Make a shallow copy of ROI matrix. | Make a view of the ROI matrix. Low level function. Unlike ESP-DSP, it is not allowed to setup stride here, stride is automatically calculated inside the function.\n     *\n     * @param start_row Start row position of source matrix to copy\n     * @param start_col Start column position of source matrix to copy\n     * @param roi_rows Size of row elements of source matrix to copy\n     * @param roi_cols Size of column elements of source matrix to copy\n     *\n     * @todo the pointer address is changing every time access, but the result is correct.\n     *\n     * @return result matrix size row_size x col_size\n     */\n    Mat Mat::view_roi(int start_row, int start_col, int roi_rows, int roi_cols) const\n    {\n        if ((start_row + roi_rows) &gt; this-&gt;row || (start_col + roi_cols) &gt; this-&gt;col)\n        {\n            std::cerr &lt;&lt; \"[Error] Invalid ROI request.\\n\";\n            return Mat();\n        }\n\n        Mat result;\n        result.row = roi_rows;\n        result.col = roi_cols;\n        result.stride = this-&gt;stride;\n        result.pad = this-&gt;stride - roi_cols;\n        result.element = roi_rows * roi_cols;\n        result.memory = roi_rows * this-&gt;stride;\n        result.data = this-&gt;data + (start_row * this-&gt;stride + start_col);\n        result.temp = nullptr;\n        result.ext_buff = true;\n        result.sub_matrix = true;\n\n        return result;\n    }\n\n    /**\n     * @name Mat::view_roi(const Mat::ROI &amp;roi)\n     * @brief Make a shallow copy of ROI matrix. | Make a view of the ROI matrix. Using ROI structure.\n     *\n     * @param roi Rectangular area of interest\n     *\n     * @return result matrix size row_size x col_size\n     */\n    Mat Mat::view_roi(const Mat::ROI &amp;roi) const\n    {\n        return view_roi(roi.pos_y, roi.pos_x, roi.height, roi.width);\n    }\n\n    /**\n     * @name Mat::copy_roi(int start_row, int start_col, int height, int width)\n     * @brief Make a deep copy of matrix. Copared to view_roi(), this one is a deep copy, not sharing memory with the source matrix.\n     *\n     * @param start_row Start row position of source matrix to copy\n     * @param start_col Start column position of source matrix to copy\n     * @param height Size of row elements of source matrix to copy\n     * @param width Size of column elements of source matrix to copy\n     *\n     * @return result matrix size row_size x col_size\n     */\n    Mat Mat::copy_roi(int start_row, int start_col, int height, int width)\n    {\n        if ((start_row + height) &gt; this-&gt;row)\n        {\n            std::cerr &lt;&lt; \"[&gt;&gt;&gt; Error ! &lt;&lt;&lt;] Invalid row position \" &lt;&lt; std::endl;\n            return Mat();\n        }\n        if ((start_col + width) &gt; this-&gt;col)\n        {\n            std::cerr &lt;&lt; \"[&gt;&gt;&gt; Error ! &lt;&lt;&lt;] Invalid columnn position \" &lt;&lt; std::endl;\n            return Mat();\n        }\n\n        // initiate the result matrix\n        Mat result(height, width);\n\n        // deep copy the data from the source matrix\n        for (size_t r = 0; r &lt; result.row; r++)\n        {\n            memcpy(&amp;result.data[r * result.col], &amp;this-&gt;data[(r + start_row) * this-&gt;stride + start_col], result.col * sizeof(float));\n        }\n\n        // return result;\n        return result;\n    }\n\n    /**\n     * @name Mat::copy_roi(const Mat::ROI &amp;roi)\n     * @brief Make a deep copy of matrix. Using ROI structure. Copared to view_roi(), this one is a deep copy, not sharing memory with the source matrix.\n     *\n     * @param roi Rectangular area of interest\n     *\n     * @return result matrix size row_size x col_size\n     */\n    Mat Mat::copy_roi(const Mat::ROI &amp;roi)\n    {\n        return (copy_roi(roi.pos_y, roi.pos_x, roi.height, roi.width));\n    }\n\n    /**\n     * @name Mat::block(int start_row, int start_col, int block_rows, int block_cols)\n     * @brief Get a block of matrix.\n     *\n     * @param start_row\n     * @param start_col\n     * @param block_rows\n     * @param block_cols\n     * @return Mat\n     */\n    Mat Mat::block(int start_row, int start_col, int block_rows, int block_cols)\n    {\n        Mat result(block_rows, block_cols);\n        for (int i = 0; i &lt; block_rows; ++i)\n        {\n            for (int j = 0; j &lt; block_cols; ++j)\n            {\n                result(i, j) = (*this)(start_row + i, start_col + j);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @name Mat::swap_rows(int row1, int row2)\n     * @brief Swap two rows of the matrix.\n     *\n     * @param row1 The index of the first row to swap\n     * @param row2 The index of the second row to swap\n     */\n    void Mat::swap_rows(int row1, int row2)\n    {\n        if ((this-&gt;row &lt;= row1) || (this-&gt;row &lt;= row2))\n        {\n            std::cerr &lt;&lt; \"Error: row index out of range\" &lt;&lt; std::endl;\n        }\n        else\n        {\n            float *temp_row = new float[this-&gt;col];\n            memcpy(temp_row, &amp;this-&gt;data[row1 * this-&gt;stride], this-&gt;col * sizeof(float));\n            memcpy(&amp;this-&gt;data[row1 * this-&gt;stride], &amp;this-&gt;data[row2 * this-&gt;stride], this-&gt;col * sizeof(float));\n            memcpy(&amp;this-&gt;data[row2 * this-&gt;stride], temp_row, this-&gt;col * sizeof(float));\n            delete[] temp_row;\n        }\n    }\n\n    /**\n     * @name Mat::clear()\n     * @brief Clear the matrix by setting all elements to zero.\n     */\n    void Mat::clear(void)\n    {\n        for (int row = 0; row &lt; this-&gt;row; row++)\n        {\n            memset(this-&gt;data + (row * this-&gt;stride), 0, this-&gt;col * sizeof(float));\n        }\n    }\n\n    /* === Arithmetic Operators === */\n    /**\n     * @name &amp;Mat::operator=(const Mat &amp;src)\n     * @brief Copy assignment operator - copy the elements of the source matrix into the destination matrix. Compared to the copy constructor, this one is used for existing matrix to copy the elements. The copy constructor is used for the first time to create a new matrix and copy the elements at the same time.\n     *\n     * @param src\n     * @return Mat&amp;\n     */\n    Mat &amp;Mat::operator=(const Mat &amp;src)\n    {\n        // 1. Self-assignment check\n        if (this == &amp;src)\n        {\n            return *this;\n        }\n\n        // 2. Forbid assignment to sub-matrix views\n        if (this-&gt;sub_matrix)\n        {\n            std::cerr &lt;&lt; \"[Error] Assignment to a sub-matrix is not allowed.\\n\";\n            return *this;\n        }\n\n        // 3. If dimensions differ, reallocate memory\n        if (this-&gt;row != src.row || this-&gt;col != src.col)\n        {\n            if (!this-&gt;ext_buff &amp;&amp; this-&gt;data != nullptr)\n            {\n                delete[] this-&gt;data;\n            }\n\n            // Update dimensions and memory info\n            this-&gt;row = src.row;\n            this-&gt;col = src.col;\n            this-&gt;stride = src.col; // Follow source's logical stride\n            this-&gt;pad = 0;\n            this-&gt;element = this-&gt;row * this-&gt;col;\n            this-&gt;memory = this-&gt;row * this-&gt;stride;\n\n            this-&gt;ext_buff = false;\n            this-&gt;sub_matrix = false;\n\n            alloc_mem();\n        }\n\n        // 4. Data copy (row-wise)\n        for (int r = 0; r &lt; this-&gt;row; ++r)\n        {\n            std::memcpy(this-&gt;data + r * this-&gt;stride, src.data + r * src.stride, this-&gt;col * sizeof(float));\n        }\n\n        return *this;\n    }\n\n    /**\n     * @name Mat::operator+=(const Mat &amp;A)\n     * @brief Element-wise addition of another matrix to this matrix.\n     *\n     * @param A The matrix to add\n     * @return Mat&amp; Reference to the current matrix\n     */\n    /**\n     * @name Mat::operator+=(const Mat &amp;A)\n     * @brief Element-wise addition of another matrix to this matrix.\n     *\n     * @param A The matrix to add\n     * @return Mat&amp; Reference to the current matrix\n     */\n    Mat &amp;Mat::operator+=(const Mat &amp;A)\n    {\n        // 1. Dimension check\n        if ((this-&gt;row != A.row) || (this-&gt;col != A.col))\n        {\n            std::cerr &lt;&lt; \"[Error] Matrix addition failed: Dimension mismatch (\"\n                      &lt;&lt; this-&gt;row &lt;&lt; \"x\" &lt;&lt; this-&gt;col &lt;&lt; \" vs \"\n                      &lt;&lt; A.row &lt;&lt; \"x\" &lt;&lt; A.col &lt;&lt; \")\\n\";\n            return *this;\n        }\n\n        // 2. Determine if padding handling is needed\n        bool need_padding_handling = (this-&gt;pad &gt; 0) || (A.pad &gt; 0);\n\n        if (need_padding_handling)\n        {\n            // Padding-aware addition\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_add_f32(this-&gt;data, A.data, this-&gt;data,\n                         this-&gt;row, this-&gt;col,\n                         this-&gt;pad, A.pad, this-&gt;pad,\n                         1, 1, 1);\n#else\n            tiny_mat_add_f32(this-&gt;data, A.data, this-&gt;data,\n                             this-&gt;row, this-&gt;col,\n                             this-&gt;pad, A.pad, this-&gt;pad,\n                             1, 1, 1);\n#endif\n        }\n        else\n        {\n            // Vectorized addition for contiguous memory\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dsps_add_f32(this-&gt;data, A.data, this-&gt;data, this-&gt;memory, 1, 1, 1);\n#else\n            tiny_vec_add_f32(this-&gt;data, A.data, this-&gt;data, this-&gt;memory, 1, 1, 1);\n#endif\n        }\n\n        return *this;\n    }\n\n    /**\n     * @name Mat::operator+=(float C)\n     * @brief Element-wise addition of a constant to this matrix.\n     *\n     * @param C The constant to add\n     */\n    /**\n     * @name Mat::operator+=(float C)\n     * @brief Element-wise addition of a constant to this matrix.\n     *\n     * @param C The constant to add\n     * @return Mat&amp; Reference to the current matrix\n     */\n    Mat &amp;Mat::operator+=(float C)\n    {\n        // check whether padding is presented\n        bool need_padding_handling = (this-&gt;pad &gt; 0);\n\n        if (need_padding_handling)\n        {\n            // Padding-aware constant addition\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_addc_f32(this-&gt;data, this-&gt;data, C,\n                          this-&gt;row, this-&gt;col,\n                          this-&gt;pad, this-&gt;pad,\n                          1, 1);\n#else\n            tiny_mat_addc_f32(this-&gt;data, this-&gt;data, C,\n                              this-&gt;row, this-&gt;col,\n                              this-&gt;pad, this-&gt;pad,\n                              1, 1);\n#endif\n        }\n        else\n        {\n            // Vectorized constant addition\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dsps_addc_f32(this-&gt;data, this-&gt;data, this-&gt;memory, C, 1, 1);\n#else\n            tiny_vec_addc_f32(this-&gt;data, this-&gt;data, this-&gt;memory, C, 1, 1);\n#endif\n        }\n\n        return *this;\n    }\n\n    /**\n     * @name Mat::operator-=(const Mat &amp;A)\n     * @brief Element-wise subtraction of another matrix from this matrix.\n     *\n     * @param A The matrix to subtract\n     * @return Mat&amp; Reference to the current matrix\n     */\n    /**\n     * @name Mat::operator-=(const Mat &amp;A)\n     * @brief Element-wise subtraction of another matrix from this matrix.\n     *\n     * @param A The matrix to subtract\n     * @return Mat&amp; Reference to the current matrix\n     */\n    Mat &amp;Mat::operator-=(const Mat &amp;A)\n    {\n        // 1. Dimension check\n        if ((this-&gt;row != A.row) || (this-&gt;col != A.col))\n        {\n            std::cerr &lt;&lt; \"[Error] Matrix subtraction failed: Dimension mismatch (\"\n                      &lt;&lt; this-&gt;row &lt;&lt; \"x\" &lt;&lt; this-&gt;col &lt;&lt; \" vs \"\n                      &lt;&lt; A.row &lt;&lt; \"x\" &lt;&lt; A.col &lt;&lt; \")\\n\";\n            return *this;\n        }\n\n        // 2. Determine if padding handling is needed\n        bool need_padding_handling = (this-&gt;pad &gt; 0) || (A.pad &gt; 0);\n\n        if (need_padding_handling)\n        {\n            // Padding-aware subtraction\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_sub_f32(this-&gt;data, A.data, this-&gt;data,\n                         this-&gt;row, this-&gt;col,\n                         this-&gt;pad, A.pad, this-&gt;pad,\n                         1, 1, 1);\n#else\n            tiny_mat_sub_f32(this-&gt;data, A.data, this-&gt;data,\n                             this-&gt;row, this-&gt;col,\n                             this-&gt;pad, A.pad, this-&gt;pad,\n                             1, 1, 1);\n#endif\n        }\n        else\n        {\n            // Vectorized subtraction for contiguous memory\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dsps_sub_f32(this-&gt;data, A.data, this-&gt;data, this-&gt;memory, 1, 1, 1);\n#else\n            tiny_vec_sub_f32(this-&gt;data, A.data, this-&gt;data, this-&gt;memory, 1, 1, 1);\n#endif\n        }\n\n        return *this;\n    }\n\n    /**\n     * @name Mat::operator-=(float C)\n     * @brief Element-wise subtraction of a constant from this matrix.\n     *\n     * @param C The constant to subtract\n     */\n    /**\n     * @name Mat::operator-=(float C)\n     * @brief Element-wise subtraction of a constant from this matrix.\n     *\n     * @param C The constant to subtract\n     * @return Mat&amp; Reference to the current matrix\n     */\n    Mat &amp;Mat::operator-=(float C)\n    {\n        bool need_padding_handling = (this-&gt;pad &gt; 0);\n\n        if (need_padding_handling)\n        {\n            // Padding-aware constant subtraction\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            // Note: ESP32 DSP does not provide dspm_subc_f32, using dspm_addc_f32 with -C\n            dspm_addc_f32(this-&gt;data, this-&gt;data, -C,\n                          this-&gt;row, this-&gt;col,\n                          this-&gt;pad, this-&gt;pad,\n                          1, 1);\n#else\n            tiny_mat_subc_f32(this-&gt;data, this-&gt;data, C,\n                              this-&gt;row, this-&gt;col,\n                              this-&gt;pad, this-&gt;pad,\n                              1, 1);\n#endif\n        }\n        else\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            // Note: ESP32 DSP does not provide dsps_subc_f32, using dsps_addc_f32 with -C\n            dsps_addc_f32(this-&gt;data, this-&gt;data, this-&gt;memory, -C, 1, 1);\n#else\n            tiny_vec_subc_f32(this-&gt;data, this-&gt;data, this-&gt;memory, C, 1, 1);\n#endif\n        }\n\n        return *this;\n    }\n\n    /**\n     * @name Mat::operator*=(const Mat &amp;m)\n     * @brief Matrix multiplication: this = this * m\n     *\n     * @param m The matrix to multiply with\n     * @return Mat&amp; Reference to the current matrix\n     */\n    Mat &amp;Mat::operator*=(const Mat &amp;m)\n    {\n        // 1. Dimension check\n        if (this-&gt;col != m.row)\n        {\n            std::cerr &lt;&lt; \"[Error] Matrix multiplication failed: incompatible dimensions (\"\n                      &lt;&lt; this-&gt;row &lt;&lt; \"x\" &lt;&lt; this-&gt;col &lt;&lt; \" * \"\n                      &lt;&lt; m.row &lt;&lt; \"x\" &lt;&lt; m.col &lt;&lt; \")\\n\";\n            return *this;\n        }\n\n        // 2. Prepare temp matrix (incase overwriting the original data)\n        Mat temp = this-&gt;copy_roi(0, 0, this-&gt;row, this-&gt;col);\n\n        // 3. check whether padding is present in either matrix\n        bool need_padding_handling = (this-&gt;pad &gt; 0) || (m.pad &gt; 0);\n\n        if (need_padding_handling)\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mult_ex_f32(temp.data, m.data, this-&gt;data, temp.row, temp.col, m.col, temp.pad, m.pad, this-&gt;pad);\n#else\n            tiny_mat_mult_ex_f32(temp.data, m.data, this-&gt;data, temp.row, temp.col, m.col, temp.pad, m.pad, this-&gt;pad);\n#endif\n        }\n        else\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mult_f32(temp.data, m.data, this-&gt;data, temp.row, temp.col, m.col);\n#else\n            tiny_mat_mult_f32(temp.data, m.data, this-&gt;data, temp.row, temp.col, m.col);\n#endif\n        }\n\n        return *this;\n    }\n\n    /**\n     * @name Mat::operator*=(float num)\n     * @brief Element-wise multiplication by a constant\n     *\n     * @param num The constant multiplier\n     * @return Mat&amp; Reference to the current matrix\n     */\n    Mat &amp;Mat::operator*=(float num)\n    {\n        // check whether padding is present\n        bool need_padding_handling = (this-&gt;pad &gt; 0);\n\n        if (need_padding_handling)\n        {\n            // Padding-aware multiplication\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mulc_f32(this-&gt;data, this-&gt;data, num,\n                          this-&gt;row, this-&gt;col,\n                          this-&gt;pad, this-&gt;pad,\n                          1, 1);\n#else\n            tiny_mat_multc_f32(this-&gt;data, this-&gt;data, num, this-&gt;row, this-&gt;col, this-&gt;pad, this-&gt;pad, 1, 1);\n#endif\n        }\n        else\n        {\n            // No padding, use vectorized multiplication\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dsps_mulc_f32(this-&gt;data, this-&gt;data, this-&gt;memory, num, 1, 1);\n#else\n            tiny_vec_mulc_f32(this-&gt;data, this-&gt;data, this-&gt;memory, num, 1, 1);\n#endif\n        }\n\n        return *this;\n    }\n\n    /**\n     * @name Mat::operator/=(const Mat &amp;B)\n     * @brief Element-wise division: this = this / B\n     *\n     * @param B The matrix divisor\n     * @return Mat&amp; Reference to the current matrix\n     */\n    Mat &amp;Mat::operator/=(const Mat &amp;B)\n    {\n        // 1. Dimension check\n        if ((this-&gt;row != B.row) || (this-&gt;col != B.col))\n        {\n            std::cerr &lt;&lt; \"[Error] Matrix division failed: Dimension mismatch (\"\n                      &lt;&lt; this-&gt;row &lt;&lt; \"x\" &lt;&lt; this-&gt;col &lt;&lt; \" vs \"\n                      &lt;&lt; B.row &lt;&lt; \"x\" &lt;&lt; B.col &lt;&lt; \")\\n\";\n            return *this;\n        }\n\n        // 2. Zero division check\n        bool zero_found = false;\n        for (int i = 0; i &lt; B.row; ++i)\n        {\n            for (int j = 0; j &lt; B.col; ++j)\n            {\n                if (B(i, j) == 0.0f)\n                {\n                    zero_found = true;\n                    break;\n                }\n            }\n            if (zero_found)\n                break;\n        }\n\n        if (zero_found)\n        {\n            std::cerr &lt;&lt; \"[Error] Matrix division failed: Division by zero detected.\\n\";\n            return *this;\n        }\n\n        // 3. Element-wise division\n        for (int i = 0; i &lt; this-&gt;row; ++i)\n        {\n            for (int j = 0; j &lt; this-&gt;col; ++j)\n            {\n                (*this)(i, j) /= B(i, j);\n            }\n        }\n\n        return *this;\n    }\n\n    /**\n     * @name Mat::operator/=(float num)\n     * @brief Element-wise division of this matrix by a constant.\n     *\n     * @param num The constant divisor\n     * @return Mat&amp; Reference to the current matrix\n     */\n    Mat &amp;Mat::operator/=(float num)\n    {\n        // 1. Check division by zero\n        if (num == 0.0f)\n        {\n            std::cerr &lt;&lt; \"[Error] Matrix division by zero is undefined.\\n\";\n            return *this;\n        }\n\n        // 2. Determine if padding handling is needed\n        bool need_padding_handling = (this-&gt;pad &gt; 0);\n\n        float inv_num = 1.0f / num;\n\n        if (need_padding_handling)\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mulc_f32(this-&gt;data, this-&gt;data, inv_num,\n                          this-&gt;row, this-&gt;col,\n                          this-&gt;pad, this-&gt;pad,\n                          1, 1);\n#else\n            tiny_mat_multc_f32(this-&gt;data, this-&gt;data, inv_num,\n                              this-&gt;row, this-&gt;col,\n                              this-&gt;pad, this-&gt;pad,\n                              1, 1);\n#endif\n        }\n        else\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dsps_mulc_f32(this-&gt;data, this-&gt;data, this-&gt;memory, inv_num, 1, 1);\n#else\n            tiny_vec_mulc_f32(this-&gt;data, this-&gt;data, this-&gt;memory, inv_num, 1, 1);\n#endif\n        }\n\n        return *this;\n    }\n\n    /**\n     * @name Mat::operator^(int num)\n     * @brief Element-wise integer exponentiation. Returns a new matrix where each element is raised to the given power.\n     *\n     * @param num The exponent (integer)\n     * @return Mat New matrix after exponentiation\n     */\n    Mat Mat::operator^(int num)\n    {\n        // Handle special cases\n        if (num == 0)\n        {\n            // Any number to the power of 0 is 1\n            Mat result(this-&gt;row, this-&gt;col, this-&gt;stride);\n            for (int i = 0; i &lt; this-&gt;row; ++i)\n            {\n                for (int j = 0; j &lt; this-&gt;col; ++j)\n                {\n                    result(i, j) = 1.0f;\n                }\n            }\n            return result;\n        }\n\n        if (num == 1)\n        {\n            // Return a copy of current matrix\n            return Mat(*this);\n        }\n\n        if (num &lt; 0)\n        {\n            std::cerr &lt;&lt; \"[Error] Negative exponent not supported in operator^.\\n\";\n            return Mat(*this); // Return a copy without modification\n        }\n\n        // General case: positive exponent &gt; 1\n        Mat result(this-&gt;row, this-&gt;col, this-&gt;stride);\n        for (int i = 0; i &lt; this-&gt;row; ++i)\n        {\n            for (int j = 0; j &lt; this-&gt;col; ++j)\n            {\n                float base = (*this)(i, j);\n                float value = 1.0f;\n                for (int k = 0; k &lt; num; ++k)\n                {\n                    value *= base;\n                }\n                result(i, j) = value;\n            }\n        }\n\n        return result;\n    }\n\n    /* === Linear Algebra === */\n    /**\n     * @name Mat::transpose\n     * @brief Transpose the matrix.\n     *\n     * @return Transposed matrix\n     */\n    Mat Mat::transpose()\n    {\n        Mat result(this-&gt;col, this-&gt;row);\n        for (int i = 0; i &lt; this-&gt;row; ++i)\n        {\n            for (int j = 0; j &lt; this-&gt;col; ++j)\n            {\n                result(j, i) = this-&gt;data[i * this-&gt;stride + j];\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @brief Calculate the cofactor matrix by removing specified row and column.\n     *\n     * @param target_row Row index to remove\n     * @param target_col Column index to remove\n     * @return Mat The (n-1)x(n-1) cofactor matrix\n     */\n    Mat Mat::cofactor(int target_row, int target_col)\n    {\n        if (this-&gt;row != this-&gt;col)\n        {\n            std::cerr &lt;&lt; \"[Error] Cofactor requires square matrix.\\n\";\n            return Mat();\n        }\n\n        int n = this-&gt;row;\n        Mat result(n - 1, n - 1);\n\n        for (int i = 0, res_i = 0; i &lt; n; ++i)\n        {\n            if (i == target_row)\n                continue;\n\n            for (int j = 0, res_j = 0; j &lt; n; ++j)\n            {\n                if (j == target_col)\n                    continue;\n\n                result.data[res_i * result.stride + res_j] = this-&gt;data[i * this-&gt;stride + j];\n                res_j++;\n            }\n            res_i++;\n        }\n\n        return result;\n    }\n\n    /**\n     * @name Mat::determinant()\n     * @brief Calculate the determinant of a square matrix using Laplace Expansion.\n     * @brief Low efficiency, only suitable for small matrices!!!\n     *\n     * @return Determinant value (float)\n     */\n    float Mat::determinant()\n    {\n        if (this-&gt;row != this-&gt;col)\n        {\n            std::cerr &lt;&lt; \"[Error] Determinant can only be calculated for square matrices.\\n\";\n            return 0.0f;\n        }\n\n        int n = this-&gt;row;\n\n        // Base case: 1x1 matrix\n        if (n == 1)\n            return this-&gt;data[0];\n\n        // Base case: 2x2 matrix (optimized)\n        if (n == 2)\n            return this-&gt;data[0] * this-&gt;data[3] - this-&gt;data[1] * this-&gt;data[2];\n\n        float D = 0.0f;\n        int sign = 1;\n\n        for (int f = 0; f &lt; n; ++f)\n        {\n            Mat minor = this-&gt;cofactor(0, f);                // Get cofactor matrix\n            D += sign * (*this)(0, f) * minor.determinant(); // Recursive call to calculate determinant of the cofactor matrix\n            sign = -sign;                                    // Alternate sign\n        }\n\n        return D;\n    }\n\n    /**\n     * @name Mat::adjoint()\n     * @brief Calculate the adjoint (adjugate) matrix of a square matrix.\n     *\n     * @return Mat The adjoint matrix\n     */\n    Mat Mat::adjoint()\n    {\n        if (this-&gt;row != this-&gt;col)\n        {\n            std::cerr &lt;&lt; \"[Error] Adjoint can only be computed for square matrices.\\n\";\n            return Mat();\n        }\n\n        int n = this-&gt;row;\n        Mat adj(n, n);\n\n        // Special case for 1x1 matrix\n        if (n == 1)\n        {\n            adj(0, 0) = 1.0f;\n            return adj;\n        }\n\n        for (int i = 0; i &lt; n; ++i)\n        {\n            for (int j = 0; j &lt; n; ++j)\n            {\n                // Calculate cofactor matrix of element (i, j)\n                Mat cof = this-&gt;cofactor(i, j);\n\n                int sign = ((i + j) % 2 == 0) ? 1 : -1;\n\n                // Adjoint is transpose of cofactor matrix\n                adj(j, i) = sign * cof.determinant();\n            }\n        }\n\n        return adj;\n    }\n\n    /**\n     * @brief Normalize the matrix using L2 norm (Frobenius norm).\n     *        After normalization, ||Matrix|| = 1\n     */\n    void Mat::normalize()\n    {\n        float norm_sq = 0.0f;\n\n        for (int i = 0; i &lt; this-&gt;row; ++i)\n        {\n            for (int j = 0; j &lt; this-&gt;col; ++j)\n            {\n                float val = (*this)(i, j);\n                norm_sq += val * val;\n            }\n        }\n\n        if (norm_sq == 0.0f)\n        {\n            std::cerr &lt;&lt; \"[Warning] Cannot normalize a zero matrix.\\n\";\n            return;\n        }\n\n        float inv_norm = 1.0f / sqrtf(norm_sq);\n        *this *= inv_norm;\n    }\n\n    /**\n     * @name Mat::norm() const\n     * @brief Calculate the Frobenius norm (L2 norm) of the matrix.\n     *\n     * @return float The computed matrix norm\n     */\n    float Mat::norm() const\n    {\n        float sum_sq = 0.0f;\n\n        for (int i = 0; i &lt; this-&gt;row; ++i)\n        {\n            for (int j = 0; j &lt; this-&gt;col; ++j)\n            {\n                float val = (*this)(i, j); // Access valid matrix element\n                sum_sq += val * val;\n            }\n        }\n\n        return sqrtf(sum_sq);\n    }\n\n    /**\n     * @name Mat::inverse_adjoint()\n     * @brief Compute the inverse of a square matrix using adjoint method.\n     *\n     * @return Mat The inverse matrix. If singular, returns a zero matrix.\n     */\n    Mat Mat::inverse_adjoint()\n    {\n        if (this-&gt;row != this-&gt;col)\n        {\n            std::cerr &lt;&lt; \"[Error] Inverse can only be computed for square matrices.\\n\";\n            return Mat();\n        }\n\n        int n = this-&gt;row;\n\n        float det_val = this-&gt;determinant();\n        if (det_val == 0.0f)\n        {\n            std::cerr &lt;&lt; \"[Error] Singular matrix, inverse does not exist.\\n\";\n            return Mat(n, n); // Return zero matrix\n        }\n\n        Mat adj = this-&gt;adjoint();\n\n        // Inverse = adjoint / determinant\n        Mat inv(n, n);\n        float inv_det = 1.0f / det_val;\n\n        for (int i = 0; i &lt; n; ++i)\n        {\n            for (int j = 0; j &lt; n; ++j)\n            {\n                inv(i, j) = adj(i, j) * inv_det;\n            }\n        }\n\n        return inv;\n    }\n\n    /**\n     * @name Mat::eye(int size)\n     * @brief Generate an identity matrix of given size.\n     *\n     * @param size Dimension of the square identity matrix\n     * @return Mat Identity matrix (size x size)\n     */\n    Mat Mat::eye(int size)\n    {\n        Mat identity(size, size);\n\n        // Set diagonal elements to 1, rest are initialized as 0\n        for (int i = 0; i &lt; size; ++i)\n        {\n            identity(i, i) = 1.0f;\n        }\n\n        return identity;\n    }\n\n    /**\n     * @name Mat::augment(const Mat &amp;A, const Mat &amp;B)\n     * @brief Augment two matrices horizontally [A | B].\n     *\n     * @param A Left matrix\n     * @param B Right matrix\n     * @return Mat Augmented matrix [A B]\n     */\n    Mat Mat::augment(const Mat &amp;A, const Mat &amp;B)\n    {\n        // 1. Check if row counts match\n        if (A.row != B.row)\n        {\n            std::cerr &lt;&lt; \"[Error] Cannot augment matrices: Row counts do not match (\"\n                      &lt;&lt; A.row &lt;&lt; \" vs \" &lt;&lt; B.row &lt;&lt; \")\\n\";\n            return Mat();\n        }\n\n        // 2. Create new matrix with combined columns\n        Mat AB(A.row, A.col + B.col);\n\n        // 3. Copy data from A and B\n        for (int i = 0; i &lt; A.row; ++i)\n        {\n            // Copy A\n            for (int j = 0; j &lt; A.col; ++j)\n            {\n                AB(i, j) = A(i, j);\n            }\n            // Copy B\n            for (int j = 0; j &lt; B.col; ++j)\n            {\n                AB(i, A.col + j) = B(i, j);\n            }\n        }\n\n        return AB;\n    }\n\n    /**\n     * @name Mat::ones(int size)\n     * @brief Create a square matrix filled with ones.\n     *\n     * @param size Size of the square matrix (rows = cols)\n     * @return Mat Square matrix [size x size] with all elements = 1\n     */\n    Mat Mat::ones(int size)\n    {\n        return Mat::ones(size, size);\n    }\n\n    /**\n     * @name Mat::ones(int rows, int cols)\n     * @brief Create a matrix of specified size filled with ones.\n     *\n     * @param rows Number of rows\n     * @param cols Number of columns\n     * @return Mat Matrix [rows x cols] with all elements = 1\n     */\n    Mat Mat::ones(int rows, int cols)\n    {\n        Mat result(rows, cols);\n\n        for (int i = 0; i &lt; rows; ++i)\n        {\n            for (int j = 0; j &lt; cols; ++j)\n            {\n                result(i, j) = 1.0f;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @name Mat::gaussian_eliminate\n     * @brief Perform Gaussian Elimination to convert matrix to Row Echelon Form (REF).\n     *\n     * @return Mat The upper triangular matrix (REF form)\n     */\n    Mat Mat::gaussian_eliminate() const\n    {\n        Mat result(*this); // Create a copy of the original matrix\n        int rows = result.row;\n        int cols = result.col;\n\n        int lead = 0; // Leading column tracker\n\n        for (int r = 0; r &lt; rows; ++r)\n        {\n            if (lead &gt;= cols)\n                break;\n\n            int i = r;\n\n            // Find pivot row (partial pivoting)\n            while (result(i, lead) == 0)\n            {\n                i++;\n                if (i == rows)\n                {\n                    i = r;\n                    lead++;\n                    if (lead == cols)\n                        return result; // Return the result matrix (upper triangular)\n                }\n            }\n\n            // Swap rows if pivot is not in current row\n            if (i != r)\n                result.swap_rows(i, r);\n\n            // Eliminate rows below\n            for (int j = r + 1; j &lt; rows; ++j)\n            {\n                if (result(j, lead) == 0)\n                    continue;\n\n                float factor = result(j, lead) / result(r, lead);\n                for (int k = lead; k &lt; cols; ++k)\n                {\n                    result(j, k) -= factor * result(r, k);\n\n                    // Numerical precision handling (set near-zero values to zero)\n                    if (fabs(result(j, k)) &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32)\n                        result(j, k) = 0.0f;\n                }\n            }\n\n            lead++;\n        }\n\n        return result; // Return the upper triangular matrix\n    }\n\n    /**\n     * @name Mat::row_reduce_from_gaussian()\n     * @brief Convert a matrix (assumed in row echelon form) to Reduced Row Echelon Form (RREF).\n     *\n     * @return Mat The matrix in RREF form\n     */\n    Mat Mat::row_reduce_from_gaussian()\n    {\n        Mat R(*this); // Make a copy to preserve original matrix\n        int rows = R.row;\n        int cols = R.col;\n\n        int pivot_row = rows - 1;\n        int pivot_col = cols - 2;\n\n        while (pivot_row &gt;= 0)\n        {\n            // Locate pivot in current row\n            int current_pivot_col = -1;\n            for (int k = 0; k &lt; cols; ++k)\n            {\n                if (R(pivot_row, k) != 0)\n                {\n                    current_pivot_col = k;\n                    break;\n                }\n            }\n\n            if (current_pivot_col != -1)\n            {\n                // Normalize pivot row\n                float pivot_val = R(pivot_row, current_pivot_col);\n                for (int s = current_pivot_col; s &lt; cols; ++s)\n                {\n                    R(pivot_row, s) /= pivot_val;\n                    if (fabs(R(pivot_row, s)) &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32)\n                    {\n                        R(pivot_row, s) = 0.0f;\n                    }\n                }\n\n                // Eliminate above pivot\n                for (int t = pivot_row - 1; t &gt;= 0; --t)\n                {\n                    float factor = R(t, current_pivot_col);\n                    for (int s = current_pivot_col; s &lt; cols; ++s)\n                    {\n                        R(t, s) -= factor * R(pivot_row, s);\n                        if (fabs(R(t, s)) &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32)\n                        {\n                            R(t, s) = 0.0f;\n                        }\n                    }\n                }\n            }\n\n            pivot_row--;\n        }\n\n        return R;\n    }\n\n    /**\n     * @name Mat::inverse_gje()\n     * @brief Compute the inverse of a square matrix using Gauss-Jordan elimination.\n     *\n     * @return Mat The inverse matrix if invertible, otherwise returns empty matrix.\n     */\n    Mat Mat::inverse_gje()\n    {\n        if (this-&gt;row != this-&gt;col)\n        {\n            std::cerr &lt;&lt; \"[Error] Inversion requires a square matrix.\\n\";\n            return Mat();\n        }\n\n        // Step 1: Create augmented matrix [A | I]\n        Mat I = Mat::eye(this-&gt;row);            // Identity matrix\n        Mat augmented = Mat::augment(*this, I); // Augment matrix A with I\n\n        // Step 2: Apply Gauss-Jordan elimination to get [I | A_inv]\n        Mat rref = augmented.gaussian_eliminate().row_reduce_from_gaussian();\n\n        // Check if the left half is the identity matrix\n        for (int i = 0; i &lt; this-&gt;row; ++i)\n        {\n            for (int j = 0; j &lt; this-&gt;col; ++j)\n            {\n                if (fabs(rref(i, j) - I(i, j)) &gt; TINY_MATH_MIN_POSITIVE_INPUT_F32)\n                {\n                    std::cerr &lt;&lt; \"[Error] Matrix is singular, cannot compute inverse.\\n\";\n                    return Mat();\n                }\n            }\n        }\n\n        // Step 3: Extract the right half as the inverse matrix\n        Mat result(this-&gt;row, this-&gt;col);\n        for (int i = 0; i &lt; this-&gt;row; ++i)\n        {\n            for (int j = 0; j &lt; this-&gt;col; ++j)\n            {\n                result(i, j) = rref(i, j + this-&gt;col); // Extract the right part\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @name Mat::dotprod(const Mat &amp;A, const Mat &amp;B)\n     * @brief Calculate the dot product of two vectors (Nx1).\n     *\n     * @param[in] A Input vector A (Nx1).\n     * @param[in] B Input vector B (Nx1).\n     *\n     * @return float The computed dot product value.\n     */\n    float Mat::dotprod(const Mat &amp;A, const Mat &amp;B)\n    {\n        if (A.row != B.row || A.col != 1 || B.col != 1)\n        {\n            std::cerr &lt;&lt; \"[Error] Dot product can only be computed for two vectors of the same length.\\n\";\n            return 0.0f; // Return 0 in case of dimension mismatch\n        }\n\n        float sum = 0;\n        for (int i = 0; i &lt; A.row; ++i)\n        {\n            sum += A(i, 0) * B(i, 0);\n        }\n\n        return sum;\n    }\n\n    /**\n     * @name Mat::solve\n     * @brief Solve the linear system Ax = b using Gaussian elimination.\n     *\n     * @param A Coefficient matrix (NxN)\n     * @param b Result vector (Nx1)\n     * @return Mat Solution vector (Nx1) containing the roots of the equation Ax = b\n     */\n    Mat Mat::solve(const Mat &amp;A, const Mat &amp;b)\n    {\n        // Check if the matrix A is square\n        if (A.row != A.col)\n        {\n            std::cerr &lt;&lt; \"[Error] Matrix A must be square for solving.\\n\";\n            return Mat(); // Return empty matrix\n        }\n\n        // Check if A and b dimensions are compatible for solving\n        if (A.row != b.row || b.col != 1)\n        {\n            std::cerr &lt;&lt; \"[Error] Matrix dimensions do not match for solving.\\n\";\n            return Mat(); // Return empty matrix\n        }\n\n        // Create augmented matrix [A | b]\n        Mat augmentedMatrix(A.row, A.col + 1);\n        for (int i = 0; i &lt; A.row; ++i)\n        {\n            for (int j = 0; j &lt; A.col; ++j)\n            {\n                augmentedMatrix(i, j) = A(i, j); // Copy matrix A into augmented matrix\n            }\n            augmentedMatrix(i, A.col) = b(i, 0); // Copy vector b into augmented matrix\n        }\n\n        // Perform Gaussian elimination\n        for (int i = 0; i &lt; A.row; ++i)\n        {\n            // Find pivot and make sure it's non-zero\n            if (augmentedMatrix(i, i) == 0)\n            {\n                std::cerr &lt;&lt; \"[Error] Pivot is zero, matrix is singular.\\n\";\n                return Mat(); // Return empty matrix\n            }\n\n            // Normalize the pivot row\n            float pivot = augmentedMatrix(i, i);\n            for (int j = i; j &lt; augmentedMatrix.col; ++j)\n            {\n                augmentedMatrix(i, j) /= pivot; // Normalize the pivot row\n            }\n\n            // Eliminate the entries below the pivot\n            for (int j = i + 1; j &lt; A.row; ++j)\n            {\n                float factor = augmentedMatrix(j, i);\n                for (int k = i; k &lt; augmentedMatrix.col; ++k)\n                {\n                    augmentedMatrix(j, k) -= factor * augmentedMatrix(i, k);\n                }\n            }\n        }\n\n        // Back-substitution to find the solution\n        Mat solution(A.row, 1);\n        for (int i = A.row - 1; i &gt;= 0; --i)\n        {\n            float sum = augmentedMatrix(i, A.col);\n            for (int j = i + 1; j &lt; A.row; ++j)\n            {\n                sum -= augmentedMatrix(i, j) * solution(j, 0);\n            }\n            solution(i, 0) = sum;\n        }\n\n        return solution;\n    }\n\n    /**\n     * @name Mat::band_solve\n     * @brief Solve the system of equations Ax = b using optimized Gaussian elimination for banded matrices.\n     *\n     * @param A Coefficient matrix (NxN) - banded matrix\n     * @param b Result vector (Nx1)\n     * @param k Bandwidth of the matrix (the width of the non-zero bands)\n     * @return Mat Solution vector (Nx1) containing the roots of the equation Ax = b\n     */\n    Mat Mat::band_solve(Mat A, Mat b, int k)\n    {\n        // Dimension compatibility check\n        if (A.row != A.col) // Check if A is a square matrix\n        {\n            std::cerr &lt;&lt; \"[Error] Matrix A must be square for solving.\\n\";\n            return Mat(); // Return an empty matrix in case of an error\n        }\n\n        if (A.row != b.row || b.col != 1) // Check if dimensions of A and b are compatible\n        {\n            std::cerr &lt;&lt; \"[Error] Matrix dimensions are not compatible for solving.\\n\";\n            return Mat(); // Return an empty matrix in case of an error\n        }\n\n        int bandsBelow = (k - 1) / 2; // Number of bands below the main diagonal\n\n        // Perform forward elimination to reduce the matrix\n        for (int i = 0; i &lt; A.row; ++i)\n        {\n            if (A(i, i) == 0)\n            {\n                // Pivot 0 - error\n                std::cerr &lt;&lt; \"[Error] Zero pivot detected in bandSolve. Cannot proceed.\\n\";\n                Mat err_result(b.row, 1);\n                memset(err_result.data, 0, b.row * sizeof(float));\n                return err_result;\n            }\n\n            float a_ii = 1 / A(i, i); // Inverse of the pivot element\n\n            // Eliminate elements below the pivot in the current column\n            for (int j = i + 1; j &lt; A.row &amp;&amp; j &lt;= i + bandsBelow; ++j)\n            {\n                if (A(j, i) != 0)\n                {\n                    float factor = A(j, i) * a_ii;\n                    for (int k = i; k &lt; A.col; ++k)\n                    {\n                        A(j, k) -= A(i, k) * factor; // Eliminate the element\n                    }\n                    b(j, 0) -= b(i, 0) * factor; // Update the result vector\n                    A(j, i) = 0;                 // Set the element to zero as it has been eliminated\n                }\n            }\n        }\n\n        // Back substitution to solve for x\n        Mat x(b.row, 1);\n        x(x.row - 1, 0) = b(x.row - 1, 0) / A(x.row - 1, x.row - 1); // Solve the last variable\n\n        for (int i = x.row - 2; i &gt;= 0; --i)\n        {\n            float sum = 0;\n            for (int j = i + 1; j &lt; x.row; ++j)\n            {\n                sum += A(i, j) * x(j, 0); // Sum of the known terms\n            }\n            x(i, 0) = (b(i, 0) - sum) / A(i, i); // Solve for the current variable\n        }\n\n        return x; // Return the solution vector\n    }\n\n    /**\n     * @name Mat::roots(Mat A, Mat y)\n     * @brief   Solve the matrix using a different method. Another implementation of the 'solve' function, no difference in principle.\n     *\n     * This method solves the linear system A * x = y using Gaussian elimination.\n     *\n     * @param[in] A: matrix [N]x[N] with input coefficients\n     * @param[in] y: vector [N]x[1] with result values\n     *\n     * @return\n     *      - matrix [N]x[1] with roots\n     */\n    Mat Mat::roots(Mat A, Mat y)\n    {\n        int n = A.col; // Number of rows and columns in A (assuming A is square)\n\n        // Create augmented matrix [A | y]\n        Mat augmentedMatrix = Mat::augment(A, y);\n\n        // Perform Gaussian elimination\n        for (int j = 0; j &lt; n; j++)\n        {\n            // Normalize the pivot row (make pivot element equal to 1)\n            float pivot = augmentedMatrix(j, j);\n            if (pivot == 0)\n            {\n                std::cerr &lt;&lt; \"[Error] Pivot is zero, system may have no solution.\" &lt;&lt; std::endl;\n                return Mat(); // Return an empty matrix in case of an error\n            }\n\n            for (int k = 0; k &lt; augmentedMatrix.col; k++)\n            {\n                augmentedMatrix(j, k) /= pivot;\n            }\n\n            // Eliminate the column below the pivot (set other elements in the column to zero)\n            for (int i = j + 1; i &lt; n; i++)\n            {\n                float factor = augmentedMatrix(i, j);\n                for (int k = 0; k &lt; augmentedMatrix.col; k++)\n                {\n                    augmentedMatrix(i, k) -= factor * augmentedMatrix(j, k);\n                }\n            }\n        }\n\n        // Perform back-substitution\n        Mat result(n, 1);\n        for (int i = n - 1; i &gt;= 0; i--)\n        {\n            float sum = augmentedMatrix(i, n); // Right-hand side of the augmented matrix\n            for (int j = i + 1; j &lt; n; j++)\n            {\n                sum -= augmentedMatrix(i, j) * result(j, 0); // Subtract the known terms\n            }\n            result(i, 0) = sum; // Solve for the current variable\n        }\n\n        return result;\n    }\n\n    /* === Stream Operators === */\n    /**\n     * @name operator&lt;&lt;\n     * @brief Stream insertion operator for printing matrix to the output stream (e.g., std::cout).\n     *\n     * This function allows printing the contents of a matrix to an output stream.\n     * It prints each row of the matrix on a new line, with elements separated by spaces.\n     *\n     * @param os Output stream where the matrix will be printed (e.g., std::cout)\n     * @param m Matrix to be printed\n     *\n     * @return os The output stream after printing the matrix\n     */\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat &amp;m)\n    {\n        for (int i = 0; i &lt; m.row; ++i)\n        {\n            os &lt;&lt; m(i, 0);\n            for (int j = 1; j &lt; m.col; ++j)\n            {\n                os &lt;&lt; \" \" &lt;&lt; m(i, j);\n            }\n            os &lt;&lt; std::endl;\n        }\n        return os;\n    }\n\n    /**\n     * @name operator&lt;&lt;\n     * @brief Stream insertion operator for printing the Rectangular ROI structure to the output stream.\n     *\n     * This function prints the details of the ROI (Region of Interest) including the start row and column,\n     * and the width and height of the rectangular region.\n     *\n     * @param os Output stream where the ROI will be printed (e.g., std::cout)\n     * @param roi The ROI structure to be printed\n     *\n     * @return os The output stream after printing the ROI details\n     */\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat::ROI &amp;roi)\n    {\n        os &lt;&lt; \"row start \" &lt;&lt; roi.pos_y &lt;&lt; std::endl;\n        os &lt;&lt; \"col start \" &lt;&lt; roi.pos_x &lt;&lt; std::endl;\n        os &lt;&lt; \"row count \" &lt;&lt; roi.height &lt;&lt; std::endl;\n        os &lt;&lt; \"col count \" &lt;&lt; roi.width &lt;&lt; std::endl;\n\n        return os;\n    }\n\n    /**\n     * @name operator&gt;&gt;\n     * @brief Stream extraction operator for reading matrix from the input stream (e.g., std::cin).\n     *\n     * This function reads the contents of a matrix from an input stream.\n     * The matrix elements are read row by row, with elements separated by spaces or newlines.\n     *\n     * @param is Input stream from which the matrix will be read (e.g., std::cin)\n     * @param m Matrix to store the read data\n     *\n     * @return is The input stream after reading the matrix\n     */\n    std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Mat &amp;m)\n    {\n        for (int i = 0; i &lt; m.row; ++i)\n        {\n            for (int j = 0; j &lt; m.col; ++j)\n            {\n                is &gt;&gt; m(i, j);\n            }\n        }\n        return is;\n    }\n\n    /* === Global Arithmetic Operators === */\n    /**\n     * + operator, sum of two matrices\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] B: Input matrix B\n     *\n     * @return\n     *     - result matrix A+B\n     */\n    Mat operator+(const Mat &amp;m1, const Mat &amp;m2)\n    {\n        if ((m1.row != m2.row) || (m1.col != m2.col))\n        {\n            std::cerr &lt;&lt; \"operator + Error: matrices do not have equal dimensions\" &lt;&lt; std::endl;\n            Mat err_ret;\n            return err_ret;\n        }\n\n        if (m1.sub_matrix || m2.sub_matrix)\n        {\n            Mat temp(m1.row, m2.col);\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_add_f32(m1.data, m2.data, temp.data, m1.row, m1.col, m1.pad, m2.pad, temp.pad, 1, 1, 1);\n#else\n            tiny_mat_add_f32(m1.data, m2.data, temp.data, m1.row, m1.col, m1.pad, m2.pad, temp.pad, 1, 1, 1);\n#endif\n            return temp;\n        }\n        else\n        {\n            Mat temp(m1);\n            return (temp += m2);\n        }\n    }\n\n    /**\n     * + operator, sum of matrix with constant\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] C: Input constant\n     *\n     * @return\n     *     - result matrix A+C\n     */\n    Mat operator+(const Mat &amp;m, float C)\n    {\n        if (m.sub_matrix)\n        {\n            Mat temp(m.row, m.col);\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_addc_f32(m.data, temp.data, C, m.row, m.col, m.pad, temp.pad, 1, 1);\n#else\n            tiny_mat_addc_f32(m.data, temp.data, C, m.row, m.col, m.pad, temp.pad, 1, 1);\n#endif\n            return temp;\n        }\n        else\n        {\n            Mat temp(m);\n            return (temp += C);\n        }\n    }\n\n    /**\n     * - operator, subtraction of two matrices\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] B: Input matrix B\n     *\n     * @return\n     *     - result matrix A-B\n     */\n    Mat operator-(const Mat &amp;m1, const Mat &amp;m2)\n    {\n        if ((m1.row != m2.row) || (m1.col != m2.col))\n        {\n            std::cerr &lt;&lt; \"operator - Error: matrices do not have equal dimensions\" &lt;&lt; std::endl;\n            Mat err_ret;\n            return err_ret;\n        }\n\n        if (m1.sub_matrix || m2.sub_matrix)\n        {\n            Mat temp(m1.row, m1.col);\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_sub_f32(m1.data, m2.data, temp.data, m1.row, m1.col, m1.pad, m2.pad, temp.pad, 1, 1, 1);\n#else\n            tiny_mat_sub_f32(m1.data, m2.data, temp.data, m1.row, m1.col, m1.pad, m2.pad, temp.pad, 1, 1, 1);\n#endif\n            return temp;\n        }\n        else\n        {\n            Mat temp(m1);\n            return (temp -= m2);\n        }\n    }\n\n\n    /**\n     * - operator, subtraction of matrix with constant\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] C: Input constant\n     *\n     * @return\n     *     - result matrix A-C\n     */\n    Mat operator-(const Mat &amp;m, float C)\n    {\n        if (m.sub_matrix)\n        {\n            Mat temp(m.row, m.col);\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_addc_f32(m.data, temp.data, -C, m.row, m.col, m.pad, temp.pad, 1, 1);\n#else\n            tiny_mat_addc_f32(m.data, temp.data, -C, m.row, m.col, m.pad, temp.pad, 1, 1);\n#endif\n            return temp;\n        }\n        else\n        {\n            Mat temp(m);\n            return (temp -= C);\n        }\n    }\n\n\n    /**\n     * * operator, multiplication of two matrices.\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] B: Input matrix B\n     *\n     * @return\n     *     - result matrix A*B\n     */\n    Mat operator*(const Mat &amp;m1, const Mat &amp;m2)\n    {\n        if (m1.col != m2.row)\n        {\n            std::cerr &lt;&lt; \"operator * Error: matrices do not have correct dimensions\" &lt;&lt; std::endl;\n            Mat err_ret;\n            return err_ret;\n        }\n        Mat temp(m1.row, m2.col);\n\n        if (m1.sub_matrix || m2.sub_matrix)\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mult_ex_f32(m1.data, m2.data, temp.data, m1.row, m1.col, m2.col, m1.pad, m2.pad, temp.pad);\n#else\n            tiny_mat_mult_ex_f32(m1.data, m2.data, temp.data, m1.row, m1.col, m2.col, m1.pad, m2.pad, temp.pad);\n#endif\n        }\n        else\n        {\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mult_f32(m1.data, m2.data, temp.data, m1.row, m1.col, m2.col);\n#else\n            tiny_mat_mult_f32(m1.data, m2.data, temp.data, m1.row, m1.col, m2.col);\n#endif\n        }\n\n        return temp;\n    }\n\n    /**\n     * * operator, multiplication of matrix with constant\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] C: floating point value\n     *\n     * @return\n     *     - result matrix A*B\n     */\n    Mat operator*(const Mat &amp;m, float num)\n    {\n        if (m.sub_matrix)\n        {\n            Mat temp(m.row, m.col);\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mulc_f32(m.data, temp.data, num, m.row, m.col, m.pad, temp.pad, 1, 1);\n#else\n            tiny_mat_multc_f32(m.data, temp.data, num, m.row, m.col, m.pad, temp.pad, 1, 1);\n#endif\n            return temp;\n        }\n        else\n        {\n            Mat temp(m);\n            return (temp *= num);\n        }\n    }\n\n    /**\n     * * operator, multiplication of matrix with constant\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] C: floating point value\n     * @param[in] A: Input matrix A\n     *\n     * @return\n     *     - result matrix C*A\n     */\n    Mat operator*(float num, const Mat &amp;m)\n    {\n        return (m * num);\n    }\n\n    /**\n     * / operator, divide of matrix by constant\n     * The operator use DSP optimized implementation of multiplication.\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] C: floating point value\n     *\n     * @return\n     *     - result matrix A/C\n     */\n    Mat operator/(const Mat &amp;m, float num)\n    {\n        if (m.sub_matrix)\n        {\n            Mat temp(m.row, m.col);\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n            dspm_mulc_f32(m.data, temp.data, 1 / num, m.row, m.col, m.pad, temp.pad, 1, 1);\n#else\n            tiny_mat_multc_f32(m.data, temp.data, 1 / num, m.row, m.col, m.pad, temp.pad, 1, 1);\n#endif\n            return temp;\n        }\n        else\n        {\n            Mat temp(m);\n            return (temp /= num);\n        }\n    }\n\n\n    /**\n     * / operator, divide matrix A by matrix B (element-wise)\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] B: Input matrix B\n     *\n     * @return\n     *     - result matrix C, where C[i,j] = A[i,j]/B[i,j]\n     */\n    Mat operator/(const Mat &amp;A, const Mat &amp;B)\n    {\n        if ((A.row != B.row) || (A.col != B.col))\n        {\n            std::cerr &lt;&lt; \"operator / Error: matrices do not have equal dimensions\" &lt;&lt; std::endl;\n            Mat err_ret;\n            return err_ret;\n        }\n\n        Mat temp(A.row, A.col);\n        for (int row = 0; row &lt; A.row; row++)\n        {\n            for (int col = 0; col &lt; A.col; col++)\n            {\n                temp(row, col) = A(row, col) / B(row, col);\n            }\n        }\n        return temp;\n    }\n\n\n    /**\n     * == operator, compare two matrices\n     *\n     * @param[in] A: Input matrix A\n     * @param[in] B: Input matrix B\n     *\n     * @return\n     *      - true if matrices are the same\n     *      - false if matrices are different\n     */\n    bool operator==(const Mat &amp;m1, const Mat &amp;m2)\n    {\n        if ((m1.col != m2.col) || (m1.row != m2.row))\n        {\n            return false;\n        }\n\n        for (int row = 0; row &lt; m1.row; row++)\n        {\n            for (int col = 0; col &lt; m1.col; col++)\n            {\n                if (m1(row, col) != m2(row, col))\n                {\n                    std::cout &lt;&lt; \"operator == Error: \" &lt;&lt; row &lt;&lt; \" \" &lt;&lt; col &lt;&lt; \", m1.data=\" &lt;&lt; m1(row, col) &lt;&lt; \", m2.data=\" &lt;&lt; m2(row, col) &lt;&lt; std::endl;\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}\n</code></pre>"},{"location":"MATH/MATRIX/tiny-matrix-test/","title":"TEST","text":"<p>Tip</p> <p>The following code for testing also serves as tutorial codes.</p>"},{"location":"MATH/MATRIX/tiny-matrix-test/#tiny_matrix_testhpp","title":"tiny_matrix_test.hpp","text":"<pre><code>/**\n * @file tiny_matrix_test.hpp\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the test of the submodule matrix (advanced matrix operations) of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-17\n * @copyright Copyright (c) 2025\n *\n */\n\n#pragma once\n\n/* DEPENDENCIES */\n#include \"tiny_matrix.hpp\" // TinyMatrix Header\n\n/* STATEMENTS */\nvoid tiny_matrix_test();  // C-compatible test entry\n</code></pre>"},{"location":"MATH/MATRIX/tiny-matrix-test/#tiny_matrix_testcpp","title":"tiny_matrix_test.cpp","text":"<pre><code>/**\n * @file tiny_matrix_test.cpp\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the source file for the test of the submodule matrix (advanced matrix operations) of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-17\n * @copyright Copyright (c) 2025\n *\n */\n\n/* DEPENDENCIES */\n#include \"tiny_matrix_test.hpp\" // TinyMatrix Test Header\n\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\n// Group 1: constructor &amp; destructor\nvoid test_constructor_destructor()\n{\n    std::cout &lt;&lt; \"\\n--- Test: Constructor &amp; Destructor ---\\n\";\n\n    // test1: default constructor\n    std::cout &lt;&lt; \"[Test1: Default Constructor]\\n\";\n    tiny::Mat mat1;\n    mat1.print_info();\n    mat1.print_matrix(true);\n\n    // test2: constructor with rows and cols, using internal allocation\n    std::cout &lt;&lt; \"[Test2: Constructor with Rows and Cols]\\n\";\n    tiny::Mat mat2(3, 4);\n    mat2.print_info();\n    mat2.print_matrix(true);\n\n    // test3: constructor with rows and cols, specifying stride, using internal allocation\n    std::cout &lt;&lt; \"[Test3: Constructor with Rows, Cols and Stride]\\n\";\n    tiny::Mat mat3(3, 4, 5);\n    mat3.print_info();\n    mat3.print_matrix(true);\n\n    // test4: constructor with external data\n    std::cout &lt;&lt; \"[Test4: Constructor with External Data]\\n\";\n    float data[12] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    tiny::Mat mat4(data, 3, 4);\n    mat4.print_info();\n    mat4.print_matrix(true);\n\n    // test5: constructor with external data and stride\n    std::cout &lt;&lt; \"[Test5: Constructor with External Data and Stride]\\n\";\n    float data_stride[15] = {0, 1, 2, 3, 0, 4, 5, 6, 7, 0, 8, 9, 10, 11, 0};\n    tiny::Mat mat5(data_stride, 3, 4, 5);\n    mat5.print_info();\n    mat5.print_matrix(true);\n\n    // test6: copy constructor\n    std::cout &lt;&lt; \"[Test6: Copy Constructor]\\n\";\n    tiny::Mat mat6(mat5);\n    mat6.print_info();\n    mat6.print_matrix(true);\n}\n\n// Group 2: element access\nvoid test_element_access()\n{\n    std::cout &lt;&lt; \"\\n--- Test: Element Access ---\\n\";\n    tiny::Mat mat(2, 3);\n\n    // Test 1: non-const access\n    std::cout &lt;&lt; \"[Test1: Non-const Access]\\n\";\n    mat(0, 0) = 1.1f;\n    mat(0, 1) = 2.2f;\n    mat(0, 2) = 3.3f;\n    mat(1, 0) = 4.4f;\n    mat(1, 1) = 5.5f;\n    mat(1, 2) = 6.6f;\n    mat.print_info();\n    mat.print_matrix(true);\n\n    // Test 2: const access\n    std::cout &lt;&lt; \"[Test2: Const Access]\\n\";\n    const tiny::Mat const_mat = mat;\n    std::cout &lt;&lt; \"const_mat(0, 0): \" &lt;&lt; const_mat(0, 0) &lt;&lt; \"\\n\";\n}\n\n// Group 3: data manipulation\nvoid test_roi_operations()\n{\n    std::cout &lt;&lt; \"\\n--- Test: Data Manipulation ---\\n\";\n\n    // Material Matrices\n    tiny::Mat matA(2, 3);\n    for (int i = 0; i &lt; 2; ++i)\n    {\n        for (int j = 0; j &lt; 3; ++j)\n        {\n            matA(i, j) = i * 3 + j + 1;\n            matA(i, j) = matA(i, j) / 10;\n        }\n    }\n\n    float data[15] = {0, 1, 2, 3, 0, 4, 5, 6, 7, 0, 8, 9, 10, 11, 0};\n    tiny::Mat matB(data, 3, 4, 5);\n\n    tiny::Mat matC;\n\n    std::cout &lt;&lt; \"[Material Matrices]\\n\";\n    std::cout &lt;&lt; \"matA:\\n\";\n    matA.print_info();\n    matA.print_matrix(true);\n    std::cout &lt;&lt; \"matB:\\n\";\n    matB.print_info();\n    matB.print_matrix(true);\n    std::cout &lt;&lt; \"matC:\\n\";\n    matC.print_info();\n    matC.print_matrix(true);\n\n    // Test 1: Copy ROI\n    std::cout &lt;&lt; \"[Test1: Copy ROI - over range case]\\n\";\n    matB.copy_paste(matA, 1, 2);\n    std::cout &lt;&lt; \"matB after copy_paste matA at (1, 2):\\n\";\n    matB.print_matrix(true);\n    std::cout &lt;&lt; \"nothing changed.\\n\";\n\n    std::cout &lt;&lt; \"[Test1: Copy ROI - suitable range case]\\n\";\n    matB.copy_paste(matA, 1, 1);\n    std::cout &lt;&lt; \"matB after copy_paste matA at (1, 1):\\n\";\n    matB.print_info();\n    matB.print_matrix(true);\n    std::cout &lt;&lt; \"successfully copied.\\n\";\n\n    // Test 2: Copy Head\n    std::cout &lt;&lt; \"[Test2: Copy Head]\\n\";\n    matC.copy_head(matB);\n    std::cout &lt;&lt; \"matC after copy_head matB:\\n\";\n    matC.print_info();\n    matC.print_matrix(true);\n\n    std::cout &lt;&lt; \"[Test2: Copy Head - memory sharing check]\\n\"; // matB and matC share the same data pointer\n    matB(0, 0) = 99.99f;\n    std::cout &lt;&lt; \"matB(0, 0) = 99.99f\\n\";\n    std::cout &lt;&lt; \"matC:\\n\";\n    matC.print_info();\n    matC.print_matrix(true);\n\n    // Test 3: Get a View of ROI - low level function\n    std::cout &lt;&lt; \"[Test3: Get a View of ROI - low level function]\\n\";\n    std::cout &lt;&lt; \"get a view of ROI with overrange dimensions - rows:\\n\";\n    tiny::Mat roi1 = matB.view_roi(1, 1, 3, 2); // note here, C++ will use the copy constructor, which will copy according to the case (submatrix - shallow copy | normal - deep copy)\n    std::cout &lt;&lt; \"get a view of ROI with overrange dimensions - cols:\\n\";\n    tiny::Mat roi2 = matB.view_roi(1, 1, 2, 4); // note here, C++ will use the copy constructor, which will copy according to the case (submatrix - shallow copy | normal - deep copy)\n    std::cout &lt;&lt; \"get a view of ROI with suitable dimensions:\\n\";\n    tiny::Mat roi3 = matB.view_roi(1, 1, 2, 2); // note here, C++ will use the copy constructor, which will copy according to the case (submatrix - shallow copy | normal - deep copy)\n    std::cout &lt;&lt; \"roi3:\\n\";\n    roi3.print_info();\n    roi3.print_matrix(true);\n\n    // Test 4: Get a View of ROI - using ROI structure\n    std::cout &lt;&lt; \"[Test4: Get a View of ROI - using ROI structure]\\n\";\n    tiny::Mat::ROI roi_struct(1, 1, 2, 2);\n    tiny::Mat roi4 = matB.view_roi(roi_struct);\n    roi4.print_info();\n    roi4.print_matrix(true);\n\n    // Test 5: Copy ROI - low level function\n    std::cout &lt;&lt; \"[Test5: Copy ROI - low level function]\\n\";\n    tiny::Mat mat_deep_copy = matB.copy_roi(1, 1, 2, 2);\n    mat_deep_copy.print_info();\n    mat_deep_copy.print_matrix(true);\n\n    // Test 6: Copy ROI - using ROI structure\n    std::cout &lt;&lt; \"[Test6: Copy ROI - using ROI structure]\\n\";\n    TinyTimeMark_t tic1 = tiny_get_running_time();\n    tiny::Mat::ROI roi_struct2(1, 1, 2, 2);\n    tiny::Mat mat_deep_copy2 = matB.copy_roi(roi_struct2);\n    TinyTimeMark_t toc1 = tiny_get_running_time();\n    TinyTimeMark_t copy_roi_time = toc1 - tic1;\n    std::cout &lt;&lt; \"time for copy_roi using ROI structure: \" &lt;&lt; copy_roi_time &lt;&lt; \" ms\\n\";\n    mat_deep_copy2.print_info();\n    mat_deep_copy2.print_matrix(true);\n\n    // Test 7: Block\n    std::cout &lt;&lt; \"[Test7: Block]\\n\";\n    TinyTimeMark_t tic2 = tiny_get_running_time();\n    tiny::Mat mat_block = matB.block(1, 1, 2, 2);\n    TinyTimeMark_t toc2 = tiny_get_running_time();\n    TinyTimeMark_t block_roi_time = toc2 - tic2;\n    std::cout &lt;&lt; \"time for block: \" &lt;&lt; block_roi_time &lt;&lt; \" ms\\n\";\n    mat_block.print_info();\n    mat_block.print_matrix(true);\n\n    // swap rows\n    std::cout &lt;&lt; \"[Test7: Swap Rows]\\n\";\n    std::cout &lt;&lt; \"matB before swap:\\n\";\n    matB.print_info();\n    matB.print_matrix(true);\n    std::cout &lt;&lt; \"matB after swap:\\n\";\n    matB.swap_rows(0, 2);\n    matB.print_info();\n    matB.print_matrix(true);\n\n    // clear function\n    std::cout &lt;&lt; \"[Test8: Clear]\\n\";\n    std::cout &lt;&lt; \"matB before clear:\\n\";\n    matB.print_info();\n    matB.print_matrix(true);\n    std::cout &lt;&lt; \"matB after clear:\\n\";\n    matB.clear();\n    matB.print_info();\n    matB.print_matrix(true);\n}\n\n// Group 4: arithmetic operators\n// void test_arithmetic_operators()\n// {\n//     std::cout &lt;&lt; \"\\n[Arithmetic Operators Test Start]\\n\";\n\n//     /*** Test1: Assignment Operator ***/\n//     std::cout &lt;&lt; \"\\n[Test 1.1] Assignment (Same Dimensions)\\n\";\n//     tiny::Mat assignMat_1_1_dst(2, 3);\n//     tiny::Mat assignMat_1_1_src(2, 3);\n//     for (int i = 0; i &lt; 2; ++i)\n//         for (int j = 0; j &lt; 3; ++j)\n//             assignMat_1_1_src(i, j) = static_cast&lt;float&gt;(i * 3 + j + 1);\n//     assignMat_1_1_dst = assignMat_1_1_src;\n//     assignMat_1_1_dst.print_matrix(true);\n\n//     std::cout &lt;&lt; \"\\n[Test 1.2] Assignment (Different Dimensions)\\n\";\n//     tiny::Mat assignMat_1_2_dst(4, 2);\n//     assignMat_1_2_dst = assignMat_1_1_src;\n//     assignMat_1_2_dst.print_matrix(true);\n\n//     std::cout &lt;&lt; \"\\n[Test 1.3] Assignment to Sub-Matrix (Expect Error)\\n\";\n//     float data_1_3[15] = {0, 1, 2, 3, 0, 4, 5, 6, 7, 0, 8, 9, 10, 11, 0};\n//     tiny::Mat baseMat_1_3(data_1_3, 3, 4, 5);\n//     tiny::Mat subView_1_3 = baseMat_1_3.view_roi(1, 1, 2, 2);\n//     subView_1_3 = assignMat_1_1_src;\n//     subView_1_3.print_matrix(true);\n\n//     std::cout &lt;&lt; \"\\n[Test 1.4] Self-Assignment\\n\";\n//     assignMat_1_1_src = assignMat_1_1_src;\n//     assignMat_1_1_src.print_matrix(true);\n\n//     /*** Test2: Matrix Addition ***/\n//     std::cout &lt;&lt; \"\\n[Test 2.1] Matrix Addition (Same Dimensions)\\n\";\n//     tiny::Mat addMat_2_1_A(2, 3);\n//     tiny::Mat addMat_2_1_B(2, 3);\n//     for (int i = 0; i &lt; 2; ++i)\n//         for (int j = 0; j &lt; 3; ++j)\n//         {\n//             addMat_2_1_A(i, j) = static_cast&lt;float&gt;(i * 3 + j + 1);\n//             addMat_2_1_B(i, j) = 1.0f;\n//         }\n//     addMat_2_1_A += addMat_2_1_B;\n//     addMat_2_1_A.print_matrix(true);\n\n//     std::cout &lt;&lt; \"\\n[Test 2.2] Sub-Matrix Addition\\n\";\n//     float data_2_2[20] = {0, 1, 2, 3, 0, 4, 5, 6, 7, 0, 8, 9, 10, 11, 0, 12, 13, 14, 15, 0};\n//     tiny::Mat baseMat_2_2(data_2_2, 4, 4, 5);\n//     tiny::Mat subView_2_2_A = baseMat_2_2.view_roi(1, 1, 2, 2);\n//     tiny::Mat subView_2_2_B = baseMat_2_2.view_roi(1, 1, 2, 2);\n//     subView_2_2_A += subView_2_2_B;\n//     subView_2_2_A.print_matrix(true);\n\n//     std::cout &lt;&lt; \"\\n[Test 2.3] Full Matrix + Sub-Matrix Addition\\n\";\n//     tiny::Mat addMat_2_3(2, 2);\n//     for (int i = 0; i &lt; 2; ++i)\n//         for (int j = 0; j &lt; 2; ++j)\n//             addMat_2_3(i, j) = 2.0f;\n//     addMat_2_3 += subView_2_2_B;\n//     addMat_2_3.print_matrix(true);\n\n//     std::cout &lt;&lt; \"\\n[Test 2.4] Addition Dimension Mismatch (Expect Error)\\n\";\n//     tiny::Mat addMat_2_4_wrongDim(3, 3);\n//     addMat_2_3 += addMat_2_4_wrongDim;\n\n//     /*** Test3: Constant Addition ***/\n//     std::cout &lt;&lt; \"\\n[Test 3.1] Full Matrix + Constant\\n\";\n//     tiny::Mat addConstMat_3_1(2, 3);\n//     for (int i = 0; i &lt; 2; ++i)\n//         for (int j = 0; j &lt; 3; ++j)\n//             addConstMat_3_1(i, j) = static_cast&lt;float&gt;(i * 3 + j);\n//     addConstMat_3_1 += 5.0f;\n//     addConstMat_3_1.print_matrix(true);\n\n//     std::cout &lt;&lt; \"\\n[Test 3.2] Sub-Matrix + Constant\\n\";\n//     float data_3_2[20] = {0, 1, 2, 3, 0, 4, 5, 6, 7, 0, 8, 9, 10, 11, 0, 12, 13, 14, 15, 0};\n//     tiny::Mat baseMat_3_2(data_3_2, 4, 4, 5);\n//     tiny::Mat subView_3_2 = baseMat_3_2.view_roi(1, 1, 2, 2);\n//     subView_3_2 += 3.0f;\n//     subView_3_2.print_matrix(true);\n\n//     std::cout &lt;&lt; \"\\n[Test 3.3] Add Zero to Matrix\\n\";\n//     tiny::Mat addConstMat_3_3(2, 2);\n//     addConstMat_3_3(0, 0) = 1;\n//     addConstMat_3_3(0, 1) = 2;\n//     addConstMat_3_3(1, 0) = 3;\n//     addConstMat_3_3(1, 1) = 4;\n//     addConstMat_3_3 += 0.0f;\n//     addConstMat_3_3.print_matrix(true);\n\n//     std::cout &lt;&lt; \"\\n[Test 3.4] Add Negative Constant\\n\";\n//     tiny::Mat addConstMat_3_4(2, 2);\n//     addConstMat_3_4(0, 0) = 10;\n//     addConstMat_3_4(0, 1) = 20;\n//     addConstMat_3_4(1, 0) = 30;\n//     addConstMat_3_4(1, 1) = 40;\n//     addConstMat_3_4 += -15.0f;\n//     addConstMat_3_4.print_matrix(true);\n\n//     /*** Test4: Matrix Subtraction ***/\n//     std::cout &lt;&lt; \"\\n[Test 4.1] Matrix Subtraction\\n\";\n//     tiny::Mat subMat_4_1_A(2, 2);\n//     tiny::Mat subMat_4_1_B(2, 2);\n//     subMat_4_1_A(0, 0) = 5;\n//     subMat_4_1_A(0, 1) = 7;\n//     subMat_4_1_A(1, 0) = 9;\n//     subMat_4_1_A(1, 1) = 11;\n//     subMat_4_1_B(0, 0) = 1;\n//     subMat_4_1_B(0, 1) = 2;\n//     subMat_4_1_B(1, 0) = 3;\n//     subMat_4_1_B(1, 1) = 4;\n//     subMat_4_1_A -= subMat_4_1_B;\n//     subMat_4_1_A.print_matrix(true);\n\n//     std::cout &lt;&lt; \"\\n[Test 4.2] Subtraction Dimension Mismatch (Expect Error)\\n\";\n//     tiny::Mat subMat_4_2_wrong(3, 3);\n//     subMat_4_1_A -= subMat_4_2_wrong;\n\n//     /*** Test5: Constant Subtraction ***/\n//     std::cout &lt;&lt; \"\\n[Test 5.1] Full Matrix - Constant\\n\";\n//     tiny::Mat subConstMat_5_1(2, 3);\n//     for (int i = 0; i &lt; 2; ++i)\n//         for (int j = 0; j &lt; 3; ++j)\n//             subConstMat_5_1(i, j) = static_cast&lt;float&gt;(i * 3 + j + 1);\n//     subConstMat_5_1 -= 2.0f;\n//     subConstMat_5_1.print_matrix(true);\n\n//     std::cout &lt;&lt; \"\\n[Test 5.2] Sub-Matrix - Constant\\n\";\n//     float data_5_2[15] = {0, 1, 2, 3, 0, 4, 5, 6, 7, 0, 8, 9, 10, 11, 0};\n//     tiny::Mat baseMat_5_2(data_5_2, 3, 4, 5);\n//     tiny::Mat subView_5_2 = baseMat_5_2.view_roi(1, 1, 2, 2);\n//     subView_5_2 -= 1.5f;\n//     subView_5_2.print_matrix(true);\n\n//     /*** Test6: Matrix Element-wise Division ***/\n//     std::cout &lt;&lt; \"\\n[Test6: Operator /= (Matrix)]\\n\";\n\n//     // Test 6.1: Standard element-wise division\n//     std::cout &lt;&lt; \"\\n[Test 6.1] Element-wise division (no zero, same dimensions)\\n\";\n//     tiny::Mat divMat_6_1_A(2, 2);\n//     tiny::Mat divMat_6_1_B(2, 2);\n\n//     // Initialize matrices\n//     divMat_6_1_A(0, 0) = 10;\n//     divMat_6_1_A(0, 1) = 20;\n//     divMat_6_1_A(1, 0) = 30;\n//     divMat_6_1_A(1, 1) = 40;\n\n//     divMat_6_1_B(0, 0) = 2;\n//     divMat_6_1_B(0, 1) = 4;\n//     divMat_6_1_B(1, 0) = 5;\n//     divMat_6_1_B(1, 1) = 8;\n\n//     divMat_6_1_A /= divMat_6_1_B;\n//     divMat_6_1_A.print_matrix(true);\n\n//     // Test 6.2: Dimension mismatch\n//     std::cout &lt;&lt; \"\\n[Test 6.2] Division with dimension mismatch (expect error)\\n\";\n//     tiny::Mat divMat_6_2_wrong(3, 3);\n//     divMat_6_1_A /= divMat_6_2_wrong;\n\n//     // Test 6.3: Division by zero detection\n//     std::cout &lt;&lt; \"\\n[Test 6.3] Division by matrix containing zero (expect error)\\n\";\n//     tiny::Mat divMat_6_3_A(2, 2);\n//     tiny::Mat divMat_6_3_B(2, 2);\n\n//     divMat_6_3_A(0, 0) = 5;\n//     divMat_6_3_A(0, 1) = 10;\n//     divMat_6_3_A(1, 0) = 15;\n//     divMat_6_3_A(1, 1) = 20;\n\n//     divMat_6_3_B(0, 0) = 1;\n//     divMat_6_3_B(0, 1) = 0; // Contains zero\n//     divMat_6_3_B(1, 0) = 3;\n//     divMat_6_3_B(1, 1) = 4;\n\n//     divMat_6_3_A /= divMat_6_3_B;\n//     divMat_6_3_A.print_matrix(true); // Should remain unchanged\n\n//     /*** Test7: Matrix Division by Constant ***/\n//     std::cout &lt;&lt; \"\\n[Test7: Operator /= (Constant)]\\n\";\n\n//     // Test 7.1: Standard division by positive constant\n//     std::cout &lt;&lt; \"\\n[Test 7.1] Divide full matrix by positive constant\\n\";\n//     tiny::Mat divConstMat_7_1(2, 3);\n//     for (int i = 0; i &lt; 2; ++i)\n//         for (int j = 0; j &lt; 3; ++j)\n//             divConstMat_7_1(i, j) = static_cast&lt;float&gt;((i * 3 + j + 2)); // Avoid zero\n\n//     divConstMat_7_1 /= 2.0f;\n//     divConstMat_7_1.print_matrix(true);\n\n//     // Test 7.2: Division by negative constant\n//     std::cout &lt;&lt; \"\\n[Test 7.2] Divide matrix by negative constant\\n\";\n//     tiny::Mat divConstMat_7_2(2, 2);\n//     divConstMat_7_2(0, 0) = 6;\n//     divConstMat_7_2(0, 1) = 12;\n//     divConstMat_7_2(1, 0) = 18;\n//     divConstMat_7_2(1, 1) = 24;\n\n//     divConstMat_7_2 /= -3.0f;\n//     divConstMat_7_2.print_matrix(true);\n\n//     // Test 7.3: Division by zero (expect error)\n//     std::cout &lt;&lt; \"\\n[Test 7.3] Division by zero constant (expect error)\\n\";\n//     tiny::Mat divConstMat_7_3(2, 2);\n//     divConstMat_7_3(0, 0) = 1;\n//     divConstMat_7_3(0, 1) = 2;\n//     divConstMat_7_3(1, 0) = 3;\n//     divConstMat_7_3(1, 1) = 4;\n\n//     divConstMat_7_3 /= 0.0f;\n//     divConstMat_7_3.print_matrix(true); // Should remain unchanged\n\n//     /*** Test8: Matrix Element-wise Exponentiation ***/\n//     std::cout &lt;&lt; \"\\n[Test8: Operator ^ (Element-wise Exponentiation)]\\n\";\n\n//     // Test 8.1: Positive exponent (Square)\n//     std::cout &lt;&lt; \"\\n[Test 8.1] Raise each element to power of 2\\n\";\n//     tiny::Mat expMat_8_1(2, 2);\n//     expMat_8_1(0, 0) = 2;\n//     expMat_8_1(0, 1) = 3;\n//     expMat_8_1(1, 0) = 4;\n//     expMat_8_1(1, 1) = 5;\n\n//     tiny::Mat result_8_1 = expMat_8_1 ^ 2;\n//     result_8_1.print_matrix(true);\n\n//     // Test 8.2: Exponent = 0\n//     std::cout &lt;&lt; \"\\n[Test 8.2] Raise each element to power of 0\\n\";\n//     tiny::Mat expMat_8_2(2, 2);\n//     expMat_8_2(0, 0) = 7;\n//     expMat_8_2(0, 1) = -3;\n//     expMat_8_2(1, 0) = 0.5f;\n//     expMat_8_2(1, 1) = 10;\n\n//     tiny::Mat result_8_2 = expMat_8_2 ^ 0;\n//     result_8_2.print_matrix(true); // Expected: all 1\n\n//     // Test 8.3: Exponent = 1\n//     std::cout &lt;&lt; \"\\n[Test 8.3] Raise each element to power of 1\\n\";\n//     tiny::Mat expMat_8_3(2, 2);\n//     expMat_8_3(0, 0) = 9;\n//     expMat_8_3(0, 1) = 8;\n//     expMat_8_3(1, 0) = 7;\n//     expMat_8_3(1, 1) = 6;\n\n//     tiny::Mat result_8_3 = expMat_8_3 ^ 1;\n//     result_8_3.print_matrix(true); // Expected: same as original\n\n//     // Test 8.4: Negative exponent (if supported)\n//     std::cout &lt;&lt; \"\\n[Test 8.4] Raise each element to power of -1 (Expect reciprocal if supported)\\n\";\n//     tiny::Mat expMat_8_4(2, 2);\n//     expMat_8_4(0, 0) = 1;\n//     expMat_8_4(0, 1) = 2;\n//     expMat_8_4(1, 0) = 4;\n//     expMat_8_4(1, 1) = 5;\n\n//     tiny::Mat result_8_4 = expMat_8_4 ^ -1;\n//     result_8_4.print_matrix(true); // Depends on expHelper behavior\n\n//     // Test 8.5: Matrix contains zero, exponent = 3\n//     std::cout &lt;&lt; \"\\n[Test 8.5] Raise matrix containing zero to power of 3\\n\";\n//     tiny::Mat expMat_8_5(2, 2);\n//     expMat_8_5(0, 0) = 0;\n//     expMat_8_5(0, 1) = 2;\n//     expMat_8_5(1, 0) = -1;\n//     expMat_8_5(1, 1) = 3;\n\n//     tiny::Mat result_8_5 = expMat_8_5 ^ 3;\n//     result_8_5.print_matrix(true); // Expected: 0^3=0, others normal\n\n//     std::cout &lt;&lt; \"\\n[Arithmetic Operators Test End]\\n\";\n// }\n\n// Test 4.1\nvoid test_assignment_operator()\n{\n    std::cout &lt;&lt; \"\\n[Assignment Operator Tests]\\n\";\n\n    std::cout &lt;&lt; \"\\n[Test 1.1] Assignment (Same Dimensions)\\n\";\n    tiny::Mat dst(2, 3), src(2, 3);\n    for (int i = 0; i &lt; 2; ++i)\n        for (int j = 0; j &lt; 3; ++j)\n            src(i, j) = static_cast&lt;float&gt;(i * 3 + j + 1);\n    dst = src;\n    dst.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 1.2] Assignment (Different Dimensions)\\n\";\n    tiny::Mat dst2(4, 2);\n    dst2 = src;\n    dst2.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 1.3] Assignment to Sub-Matrix (Expect Error)\\n\";\n    float data[15] = {0, 1, 2, 3, 0, 4, 5, 6, 7, 0, 8, 9, 10, 11, 0};\n    tiny::Mat base(data, 3, 4, 5);\n    tiny::Mat subView = base.view_roi(1, 1, 2, 2);\n    subView = src;\n    subView.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 1.4] Self-Assignment\\n\";\n    src = src;\n    src.print_matrix(true);\n}\n\n// Test 4.2\nvoid test_matrix_addition()\n{\n    std::cout &lt;&lt; \"\\n[Matrix Addition Tests]\\n\";\n\n    std::cout &lt;&lt; \"\\n[Test 2.1] Matrix Addition (Same Dimensions)\\n\";\n    tiny::Mat A(2, 3), B(2, 3);\n    for (int i = 0; i &lt; 2; ++i)\n        for (int j = 0; j &lt; 3; ++j)\n        {\n            A(i, j) = static_cast&lt;float&gt;(i * 3 + j + 1);\n            B(i, j) = 1.0f;\n        }\n    A += B;\n    A.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 2.2] Sub-Matrix Addition\\n\";\n    float data[20] = {0,1,2,3,0,4,5,6,7,0,8,9,10,11,0,12,13,14,15,0};\n    tiny::Mat base(data, 4, 4, 5);\n    tiny::Mat subA = base.view_roi(1,1,2,2);\n    tiny::Mat subB = base.view_roi(1,1,2,2);\n    subA += subB;\n    subA.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 2.3] Full Matrix + Sub-Matrix Addition\\n\";\n    tiny::Mat full(2,2);\n    for(int i=0;i&lt;2;++i) for(int j=0;j&lt;2;++j) full(i,j)=2.0f;\n    full += subB;\n    full.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 2.4] Addition Dimension Mismatch (Expect Error)\\n\";\n    tiny::Mat wrongDim(3,3);\n    full += wrongDim;\n}\n\n// Test 4.3\nvoid test_constant_addition()\n{\n    std::cout &lt;&lt; \"\\n[Constant Addition Tests]\\n\";\n\n    std::cout &lt;&lt; \"\\n[Test 3.1] Full Matrix + Constant\\n\";\n    tiny::Mat mat1(2,3);\n    for (int i = 0; i &lt; 2; ++i)\n        for (int j = 0; j &lt; 3; ++j)\n            mat1(i,j) = static_cast&lt;float&gt;(i*3 + j);\n    mat1 += 5.0f;\n    mat1.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 3.2] Sub-Matrix + Constant\\n\";\n    float data[20] = {0,1,2,3,0,4,5,6,7,0,8,9,10,11,0,12,13,14,15,0};\n    tiny::Mat base(data,4,4,5);\n    tiny::Mat sub = base.view_roi(1,1,2,2);\n    sub += 3.0f;\n    sub.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 3.3] Add Zero\\n\";\n    tiny::Mat mat2(2,2);\n    mat2(0,0)=1; mat2(0,1)=2; mat2(1,0)=3; mat2(1,1)=4;\n    mat2 += 0.0f;\n    mat2.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 3.4] Add Negative Constant\\n\";\n    tiny::Mat mat3(2,2);\n    mat3(0,0)=10; mat3(0,1)=20; mat3(1,0)=30; mat3(1,1)=40;\n    mat3 += -15.0f;\n    mat3.print_matrix(true);\n}\n\n// Test 4.4\nvoid test_matrix_subtraction()\n{\n    std::cout &lt;&lt; \"\\n[Matrix Subtraction Tests]\\n\";\n\n    std::cout &lt;&lt; \"\\n[Test 4.1] Matrix Subtraction\\n\";\n    tiny::Mat A(2,2), B(2,2);\n    A(0,0)=5; A(0,1)=7; A(1,0)=9; A(1,1)=11;\n    B(0,0)=1; B(0,1)=2; B(1,0)=3; B(1,1)=4;\n    A -= B;\n    A.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 4.2] Subtraction Dimension Mismatch\\n\";\n    tiny::Mat wrong(3,3);\n    A -= wrong;\n}\n\n// Test 4.5\nvoid test_constant_subtraction()\n{\n    std::cout &lt;&lt; \"\\n[Constant Subtraction Tests]\\n\";\n\n    std::cout &lt;&lt; \"\\n[Test 5.1] Full Matrix - Constant\\n\";\n    tiny::Mat mat(2,3);\n    for (int i=0;i&lt;2;++i) for(int j=0;j&lt;3;++j) mat(i,j) = i*3+j+1;\n    mat -= 2.0f;\n    mat.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 5.2] Sub-Matrix - Constant\\n\";\n    float data[15] = {0,1,2,3,0,4,5,6,7,0,8,9,10,11,0};\n    tiny::Mat base(data,3,4,5);\n    tiny::Mat sub = base.view_roi(1,1,2,2);\n    sub -= 1.5f;\n    sub.print_matrix(true);\n}\n\n// Test 4.6\nvoid test_matrix_division()\n{\n    std::cout &lt;&lt; \"\\n[Matrix Element-wise Division Tests]\\n\";\n\n    std::cout &lt;&lt; \"\\n[Test 6.1] Element-wise division (same dimensions, no zero)\\n\";\n    tiny::Mat A(2, 2), B(2, 2);\n    A(0,0) = 10; A(0,1) = 20; A(1,0) = 30; A(1,1) = 40;\n    B(0,0) = 2;  B(0,1) = 4;  B(1,0) = 5;  B(1,1) = 8;\n    A /= B;\n    A.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 6.2] Dimension mismatch (expect error)\\n\";\n    tiny::Mat wrongDim(3, 3);\n    A /= wrongDim;\n\n    std::cout &lt;&lt; \"\\n[Test 6.3] Division by matrix containing zero (expect error)\\n\";\n    tiny::Mat C(2, 2), D(2, 2);\n    C(0,0)=5; C(0,1)=10; C(1,0)=15; C(1,1)=20;\n    D(0,0)=1; D(0,1)=0;  D(1,0)=3;  D(1,1)=4;  // Contains zero\n    C /= D;\n    C.print_matrix(true);  // Should remain unchanged\n}\n\n// Test 4.7\nvoid test_constant_division()\n{\n    std::cout &lt;&lt; \"\\n[Matrix Division by Constant Tests]\\n\";\n\n    std::cout &lt;&lt; \"\\n[Test 7.1] Divide full matrix by positive constant\\n\";\n    tiny::Mat mat1(2, 3);\n    for (int i = 0; i &lt; 2; ++i)\n        for (int j = 0; j &lt; 3; ++j)\n            mat1(i, j) = static_cast&lt;float&gt;(i * 3 + j + 2);  // Avoid zero\n    mat1 /= 2.0f;\n    mat1.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 7.2] Divide matrix by negative constant\\n\";\n    tiny::Mat mat2(2, 2);\n    mat2(0,0)=6; mat2(0,1)=12; mat2(1,0)=18; mat2(1,1)=24;\n    mat2 /= -3.0f;\n    mat2.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 7.3] Division by zero constant (expect error)\\n\";\n    tiny::Mat mat3(2, 2);\n    mat3(0,0)=1; mat3(0,1)=2; mat3(1,0)=3; mat3(1,1)=4;\n    mat3 /= 0.0f;\n    mat3.print_matrix(true);  // Should remain unchanged\n}\n\n// Test 4.8\nvoid test_matrix_exponentiation()\n{\n    std::cout &lt;&lt; \"\\n[Matrix Exponentiation Tests]\\n\";\n\n    std::cout &lt;&lt; \"\\n[Test 8.1] Raise each element to power of 2\\n\";\n    tiny::Mat mat1(2, 2);\n    mat1(0,0)=2; mat1(0,1)=3; mat1(1,0)=4; mat1(1,1)=5;\n    tiny::Mat result1 = mat1 ^ 2;\n    result1.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 8.2] Raise each element to power of 0\\n\";\n    tiny::Mat mat2(2, 2);\n    mat2(0,0)=7; mat2(0,1)=-3; mat2(1,0)=0.5f; mat2(1,1)=10;\n    tiny::Mat result2 = mat2 ^ 0;\n    result2.print_matrix(true);  // Expect all 1\n\n    std::cout &lt;&lt; \"\\n[Test 8.3] Raise each element to power of 1\\n\";\n    tiny::Mat mat3(2, 2);\n    mat3(0,0)=9; mat3(0,1)=8; mat3(1,0)=7; mat3(1,1)=6;\n    tiny::Mat result3 = mat3 ^ 1;\n    result3.print_matrix(true);  // Expect same as original\n\n    std::cout &lt;&lt; \"\\n[Test 8.4] Raise each element to power of -1 (expect error or warning)\\n\";\n    tiny::Mat mat4(2, 2);\n    mat4(0,0)=1; mat4(0,1)=2; mat4(1,0)=4; mat4(1,1)=5;\n    tiny::Mat result4 = mat4 ^ -1;\n    result4.print_matrix(true);\n\n    std::cout &lt;&lt; \"\\n[Test 8.5] Raise matrix containing zero to power of 3\\n\";\n    tiny::Mat mat5(2, 2);\n    mat5(0,0)=0; mat5(0,1)=2; mat5(1,0)=-1; mat5(1,1)=3;\n    tiny::Mat result5 = mat5 ^ 3;\n    result5.print_matrix(true);\n}\n\n// Group 5: Linear Algebra\n// Test 5.1 Transpose\nvoid test_matrix_transpose()\n{\n    std::cout &lt;&lt; \"\\n[Matrix Transpose Test]\\n\";\n\n    // Test 1: Basic 2x3 matrix transpose\n    std::cout &lt;&lt; \"\\n[Test 1] Transpose of 2x3 Matrix\\n\";\n    tiny::Mat mat1(2, 3);\n    int val = 1;\n    for (int i = 0; i &lt; 2; ++i)\n        for (int j = 0; j &lt; 3; ++j)\n            mat1(i, j) = val++;\n\n    std::cout &lt;&lt; \"Original 2x3 Matrix:\\n\";\n    mat1.print_matrix(true);\n\n    tiny::Mat transposed1 = mat1.transpose();\n    std::cout &lt;&lt; \"Transposed 3x2 Matrix:\\n\";\n    transposed1.print_matrix(true);\n\n    // Test 2: Square matrix transpose (3x3)\n    std::cout &lt;&lt; \"\\n[Test 2] Transpose of 3x3 Square Matrix\\n\";\n    tiny::Mat mat2(3, 3);\n    val = 1;\n    for (int i = 0; i &lt; 3; ++i)\n        for (int j = 0; j &lt; 3; ++j)\n            mat2(i, j) = val++;\n\n    std::cout &lt;&lt; \"Original 3x3 Matrix:\\n\";\n    mat2.print_matrix(true);\n\n    tiny::Mat transposed2 = mat2.transpose();\n    std::cout &lt;&lt; \"Transposed 3x3 Matrix:\\n\";\n    transposed2.print_matrix(true);\n\n    // Test 3: Matrix with padding (4x2, stride=3)\n    std::cout &lt;&lt; \"\\n[Test 3] Transpose of Matrix with Padding\\n\";\n    float data[12] = {1, 2, 0, 3, 4, 0, 5, 6, 0, 7, 8, 0};  // stride=3, 4 rows\n    tiny::Mat mat3(data, 4, 2, 3);\n    std::cout &lt;&lt; \"Original 4x2 Matrix (with padding):\\n\";\n    mat3.print_matrix(true);\n\n    tiny::Mat transposed3 = mat3.transpose();\n    std::cout &lt;&lt; \"Transposed 2x4 Matrix:\\n\";\n    transposed3.print_matrix(true);\n\n    // Test 4: Transpose of empty matrix\n    std::cout &lt;&lt; \"\\n[Test 4] Transpose of Empty Matrix\\n\";\n    tiny::Mat mat4;\n    mat4.print_matrix(true);\n\n    tiny::Mat transposed4 = mat4.transpose();\n    transposed4.print_matrix(true);\n}\n\n// Test 5.2 cofactor calculation - prepare the matrix for cofactor calculation\nvoid test_matrix_cofactor()\n{\n    std::cout &lt;&lt; \"\\n[Matrix Cofactor Test]\\n\";\n\n    // Test 1: 3x3 Matrix - Standard Case\n    std::cout &lt;&lt; \"\\n[Test 1] Cofactor of 3x3 Matrix (remove row 1, col 1)\\n\";\n    tiny::Mat mat1(3, 3);\n    int val = 1;\n    for (int i = 0; i &lt; 3; ++i)\n        for (int j = 0; j &lt; 3; ++j)\n            mat1(i, j) = val++;\n\n    std::cout &lt;&lt; \"Original 3x3 Matrix:\\n\";\n    mat1.print_matrix(true);\n\n    tiny::Mat cof1 = mat1.cofactor(1, 1);\n    std::cout &lt;&lt; \"Cofactor Matrix (remove row 1, col 1):\\n\";\n    cof1.print_matrix(true);  // Expected: [[1,3],[7,9]]\n\n    // Test 2: Remove first row and first column\n    std::cout &lt;&lt; \"\\n[Test 2] Remove row 0, col 0\\n\";\n    tiny::Mat cof2 = mat1.cofactor(0, 0);\n    cof2.print_matrix(true);  // Expected: [[5,6],[8,9]]\n\n    // Test 3: Remove last row and last column\n    std::cout &lt;&lt; \"\\n[Test 3] Remove row 2, col 2\\n\";\n    tiny::Mat cof3 = mat1.cofactor(2, 2);\n    cof3.print_matrix(true);  // Expected: [[1,2],[4,5]]\n\n    // Test 4: 4x4 Matrix Example\n    std::cout &lt;&lt; \"\\n[Test 4] Cofactor of 4x4 Matrix (remove row 2, col 1)\\n\";\n    tiny::Mat mat4(4, 4);\n    val = 1;\n    for (int i = 0; i &lt; 4; ++i)\n        for (int j = 0; j &lt; 4; ++j)\n            mat4(i, j) = val++;\n\n    mat4.print_matrix(true);\n    tiny::Mat cof4 = mat4.cofactor(2, 1);\n    std::cout &lt;&lt; \"Cofactor Matrix:\\n\";\n    cof4.print_matrix(true);\n\n    // Test 5: Non-square Matrix (Expect Error)\n    std::cout &lt;&lt; \"\\n[Test 5] Non-square Matrix (Expect Error)\\n\";\n    tiny::Mat rectMat(3, 4);\n    rectMat.cofactor(1, 1).print_matrix(true);  // Should trigger error and return empty matrix\n}\n\n// Test 5.3 determinant calculation\nvoid test_matrix_determinant()\n{\n    std::cout &lt;&lt; \"\\n[Matrix Determinant Test Start]\\n\";\n\n    /*** Test 1: 1x1 Matrix ***/\n    std::cout &lt;&lt; \"\\n[Test 1] 1x1 Matrix Determinant\\n\";\n    tiny::Mat mat1(1, 1);\n    mat1(0, 0) = 7;\n    std::cout &lt;&lt; \"Determinant: \" &lt;&lt; mat1.determinant() &lt;&lt; \"  (Expected: 7)\\n\";\n\n    /*** Test 2: 2x2 Matrix ***/\n    std::cout &lt;&lt; \"\\n[Test 2] 2x2 Matrix Determinant\\n\";\n    tiny::Mat mat2(2, 2);\n    mat2(0, 0) = 3; mat2(0, 1) = 8;\n    mat2(1, 0) = 4; mat2(1, 1) = 6;\n    std::cout &lt;&lt; \"Determinant: \" &lt;&lt; mat2.determinant() &lt;&lt; \"  (Expected: -14)\\n\";\n\n    /*** Test 3: 3x3 Matrix ***/\n    std::cout &lt;&lt; \"\\n[Test 3] 3x3 Matrix Determinant\\n\";\n    tiny::Mat mat3(3, 3);\n    mat3(0,0) = 1; mat3(0,1) = 2; mat3(0,2) = 3;\n    mat3(1,0) = 0; mat3(1,1) = 4; mat3(1,2) = 5;\n    mat3(2,0) = 1; mat3(2,1) = 0; mat3(2,2) = 6;\n    std::cout &lt;&lt; \"Determinant: \" &lt;&lt; mat3.determinant() &lt;&lt; \"  (Expected: 22)\\n\";\n\n    /*** Test 4: 4x4 Matrix ***/\n    std::cout &lt;&lt; \"\\n[Test 4] 4x4 Matrix Determinant\\n\";\n    tiny::Mat mat4(4, 4);\n    int val = 1;\n    for (int i = 0; i &lt; 4; ++i)\n        for (int j = 0; j &lt; 4; ++j)\n            mat4(i, j) = val++;\n    std::cout &lt;&lt; \"Determinant: \" &lt;&lt; mat4.determinant() &lt;&lt; \"  (Expected: 0)\\n\";  \n\n    /*** Test 5: Non-square Matrix (Expect Error) ***/\n    std::cout &lt;&lt; \"\\n[Test 5] Non-square Matrix (Expect Error)\\n\";\n    tiny::Mat rectMat(3, 4);\n    float det_rect = rectMat.determinant();  // should trigger error\n    std::cout &lt;&lt; \"Determinant: \" &lt;&lt; det_rect &lt;&lt; \"  (Expected: 0 with error message)\\n\";\n\n    std::cout &lt;&lt; \"\\n[Matrix Determinant Test End]\\n\";\n}\n\n// Test 5.4 adjoint calculation\nvoid test_matrix_adjoint()\n{\n    std::cout &lt;&lt; \"\\n[Matrix Adjoint Test Start]\\n\";\n\n    /*** Test 1: 1x1 Matrix ***/\n    std::cout &lt;&lt; \"\\n[Test 1] Adjoint of 1x1 Matrix\\n\";\n    tiny::Mat mat1(1, 1);\n    mat1(0, 0) = 5;\n    tiny::Mat adj1 = mat1.adjoint();\n    adj1.print_matrix(true);  // Expected: [1]\n\n    /*** Test 2: 2x2 Matrix ***/\n    std::cout &lt;&lt; \"\\n[Test 2] Adjoint of 2x2 Matrix\\n\";\n    tiny::Mat mat2(2, 2);\n    mat2(0, 0) = 1; mat2(0, 1) = 2;\n    mat2(1, 0) = 3; mat2(1, 1) = 4;\n    tiny::Mat adj2 = mat2.adjoint();\n    adj2.print_matrix(true);  // Expected: [4, -2; -3, 1]\n\n    /*** Test 3: 3x3 Matrix ***/\n    std::cout &lt;&lt; \"\\n[Test 3] Adjoint of 3x3 Matrix\\n\";\n    tiny::Mat mat3(3, 3);\n    mat3(0,0) = 1; mat3(0,1) = 2; mat3(0,2) = 3;\n    mat3(1,0) = 0; mat3(1,1) = 4; mat3(1,2) = 5;\n    mat3(2,0) = 1; mat3(2,1) = 0; mat3(2,2) = 6;\n    tiny::Mat adj3 = mat3.adjoint();\n    adj3.print_matrix(true);\n    // No simple expected value, but should compute correctly\n\n    /*** Test 4: Non-Square Matrix (Expect Error) ***/\n    std::cout &lt;&lt; \"\\n[Test 4] Adjoint of Non-Square Matrix (Expect Error)\\n\";\n    tiny::Mat rectMat(2, 3);\n    tiny::Mat adjRect = rectMat.adjoint();\n    adjRect.print_matrix(true);  // Should be empty or default matrix\n\n    std::cout &lt;&lt; \"\\n[Matrix Adjoint Test End]\\n\";\n}\n\n// Test 5.5 normalization function\nvoid test_matrix_normalize()\n{\n    std::cout &lt;&lt; \"\\n[Test: Matrix Normalization]\\n\";\n\n    /*** Test 1: Standard normalization ***/\n    std::cout &lt;&lt; \"\\n[Test 1] Normalize a standard 2x2 matrix\\n\";\n    tiny::Mat mat1(2, 2);\n    mat1(0, 0) = 3.0f; mat1(0, 1) = 4.0f;\n    mat1(1, 0) = 3.0f; mat1(1, 1) = 4.0f;\n\n    std::cout &lt;&lt; \"Before normalization:\\n\";\n    mat1.print_matrix(true);\n\n    mat1.normalize();\n\n    std::cout &lt;&lt; \"After normalization (Expected L2 norm = 1):\\n\";\n    mat1.print_matrix(true);\n\n    /*** Test 2: Matrix with padding ***/\n    std::cout &lt;&lt; \"\\n[Test 2] Normalize a 2x2 matrix with stride=4 (Padding Test)\\n\";\n    float data_with_padding[8] = {3.0f, 4.0f, 0.0f, 0.0f, 3.0f, 4.0f, 0.0f, 0.0f};\n    tiny::Mat mat2(data_with_padding, 2, 2, 4);  // 2x2 matrix, stride 4\n\n    std::cout &lt;&lt; \"Before normalization:\\n\";\n    mat2.print_matrix(true);\n\n    mat2.normalize();\n\n    std::cout &lt;&lt; \"After normalization:\\n\";\n    mat2.print_matrix(true);\n\n    /*** Test 3: Zero matrix normalization ***/\n    std::cout &lt;&lt; \"\\n[Test 3] Normalize a zero matrix (Expect warning)\\n\";\n    tiny::Mat mat3(2, 2);\n    mat3.clear();  // Assuming clear() sets all elements to zero\n\n    mat3.print_matrix(true);\n    mat3.normalize();  // Should trigger warning\n}\n\n// Test 5.6: Matrix Norm Calculation\nvoid test_matrix_norm()\n{\n    std::cout &lt;&lt; \"\\n[Test: Matrix Norm Calculation]\\n\";\n\n    /*** Test 1: Simple 2x2 Matrix ***/\n    std::cout &lt;&lt; \"\\n[Test 1] 2x2 Matrix Norm (Expect 5.0)\\n\";\n    tiny::Mat mat1(2, 2);\n    mat1(0, 0) = 3.0f; mat1(0, 1) = 4.0f;\n    mat1(1, 0) = 0.0f; mat1(1, 1) = 0.0f;\n    float norm1 = mat1.norm();\n    std::cout &lt;&lt; \"Calculated Norm: \" &lt;&lt; norm1 &lt;&lt; \"\\n\";\n\n    /*** Test 2: Zero Matrix ***/\n    std::cout &lt;&lt; \"\\n[Test 2] Zero Matrix Norm (Expect 0.0)\\n\";\n    tiny::Mat mat2(3, 3);\n    mat2.clear();  // Assuming clear() sets all elements to zero\n    float norm2 = mat2.norm();\n    std::cout &lt;&lt; \"Calculated Norm: \" &lt;&lt; norm2 &lt;&lt; \"\\n\";\n\n    /*** Test 3: Matrix with Negative Values ***/\n    std::cout &lt;&lt; \"\\n[Test 3] Matrix with Negative Values\\n\";\n    tiny::Mat mat3(2, 2);\n    mat3(0, 0) = -1.0f; mat3(0, 1) = -2.0f;\n    mat3(1, 0) = -3.0f; mat3(1, 1) = -4.0f;\n    float norm3 = mat3.norm();\n    std::cout &lt;&lt; \"Calculated Norm: \" &lt;&lt; norm3 &lt;&lt; \"  (Expect sqrt(30) \u2248 5.477)\\n\";\n\n    /*** Test 4: Matrix with Padding ***/\n    std::cout &lt;&lt; \"\\n[Test 4] 2x2 Matrix with Stride=4 (Padding Test)\\n\";\n    float data4[8] = {1.0f, 2.0f, 0.0f, 0.0f, 3.0f, 4.0f, 0.0f, 0.0f};\n    tiny::Mat mat4(data4, 2, 2, 4);  // 2x2 matrix, stride 4\n    float norm4 = mat4.norm();\n    std::cout &lt;&lt; \"Calculated Norm: \" &lt;&lt; norm4 &lt;&lt; \"  (Expect sqrt(30) \u2248 5.477)\\n\";\n}\n\n// Test 5.7: Matrix Inversion\nvoid test_inverse_adjoint_adjoint()\n{\n    std::cout &lt;&lt; \"\\n[Test: Matrix Inverse Calculation]\\n\";\n\n    /*** Test 1: 2x2 Regular Matrix ***/\n    std::cout &lt;&lt; \"\\n[Test 1] Inverse of 2x2 Matrix\\n\";\n    tiny::Mat mat1(2, 2);\n    mat1(0, 0) = 4;  mat1(0, 1) = 7;\n    mat1(1, 0) = 2;  mat1(1, 1) = 6;\n\n    mat1.print_matrix(true);\n    tiny::Mat inv1 = mat1.inverse_adjoint();\n    std::cout &lt;&lt; \"Inverse Matrix:\\n\";\n    inv1.print_matrix(true);\n    std::cout &lt;&lt; \"Expected Approx:\\n[ 0.6  -0.7 ]\\n[ -0.2  0.4 ]\\n\";\n\n    /*** Test 2: Singular Matrix (Determinant = 0) ***/\n    std::cout &lt;&lt; \"\\n[Test 2] Singular Matrix (Expect Error)\\n\";\n    tiny::Mat mat2(2, 2);\n    mat2(0, 0) = 1;  mat2(0, 1) = 2;\n    mat2(1, 0) = 2;  mat2(1, 1) = 4;   // Rank-deficient, det = 0\n\n    mat2.print_matrix(true);\n    tiny::Mat inv2 = mat2.inverse_adjoint();\n    std::cout &lt;&lt; \"Inverse Matrix (Should be zero matrix):\\n\";\n    inv2.print_matrix(true);\n\n    /*** Test 3: 3x3 Regular Matrix ***/\n    std::cout &lt;&lt; \"\\n[Test 3] Inverse of 3x3 Matrix\\n\";\n    tiny::Mat mat3(3, 3);\n    mat3(0,0) = 3; mat3(0,1) = 0; mat3(0,2) = 2;\n    mat3(1,0) = 2; mat3(1,1) = 0; mat3(1,2) = -2;\n    mat3(2,0) = 0; mat3(2,1) = 1; mat3(2,2) = 1;\n\n    mat3.print_matrix(true);\n    tiny::Mat inv3 = mat3.inverse_adjoint();\n    std::cout &lt;&lt; \"Inverse Matrix:\\n\";\n    inv3.print_matrix(true);\n\n    /*** Test 4: Non-Square Matrix (Expect Error) ***/\n    std::cout &lt;&lt; \"\\n[Test 4] Non-Square Matrix (Expect Error)\\n\";\n    tiny::Mat mat4(2, 3);\n    tiny::Mat inv4 = mat4.inverse_adjoint();\n    inv4.print_matrix(true);\n}\n\n// Test 5.8: Matrix Utilities\nvoid test_matrix_utilities()\n{\n    std::cout &lt;&lt; \"\\n[Matrix Utilities Test Start]\\n\";\n\n    /*** Test 1: Identity Matrix (eye) ***/\n    std::cout &lt;&lt; \"\\n[Test 1] Generate Identity Matrix (eye)\\n\";\n    tiny::Mat I3 = tiny::Mat::eye(3);\n    std::cout &lt;&lt; \"3x3 Identity Matrix:\\n\";\n    I3.print_matrix(true);\n\n    tiny::Mat I5 = tiny::Mat::eye(5);\n    std::cout &lt;&lt; \"5x5 Identity Matrix:\\n\";\n    I5.print_matrix(true);\n\n    /*** Test 2: Ones Matrix ***/\n    std::cout &lt;&lt; \"\\n[Test 2] Generate Ones Matrix\\n\";\n    tiny::Mat ones_3x4 = tiny::Mat::ones(3, 4);\n    std::cout &lt;&lt; \"3x4 Ones Matrix:\\n\";\n    ones_3x4.print_matrix(true);\n\n    tiny::Mat ones_4x4 = tiny::Mat::ones(4);\n    std::cout &lt;&lt; \"4x4 Ones Matrix (Square):\\n\";\n    ones_4x4.print_matrix(true);\n\n    /*** Test 3: Matrix Augmentation ***/\n    std::cout &lt;&lt; \"\\n[Test 3] Augment Two Matrices Horizontally [A | B]\\n\";\n\n    // Prepare matrices A (2x2) and B (2x3)\n    tiny::Mat A(2, 2);\n    A(0,0) = 1;  A(0,1) = 2;\n    A(1,0) = 3;  A(1,1) = 4;\n\n    tiny::Mat B(2, 3);\n    B(0,0) = 5;  B(0,1) = 6;  B(0,2) = 7;\n    B(1,0) = 8;  B(1,1) = 9;  B(1,2) = 10;\n\n    std::cout &lt;&lt; \"Matrix A:\\n\";\n    A.print_matrix(true);\n    std::cout &lt;&lt; \"Matrix B:\\n\";\n    B.print_matrix(true);\n\n    tiny::Mat AB = tiny::Mat::augment(A, B);\n    std::cout &lt;&lt; \"Augmented Matrix [A | B]:\\n\";\n    AB.print_matrix(true);\n\n    // Test 3.2: Row mismatch case\n    std::cout &lt;&lt; \"\\n[Test 3.2] Augment with Row Mismatch (Expect Error)\\n\";\n    tiny::Mat C(3, 2);  // 3x2 matrix\n    tiny::Mat invalidAug = tiny::Mat::augment(A, C);\n    invalidAug.print_info();  // Should show empty matrix due to error\n\n    std::cout &lt;&lt; \"\\n[Matrix Utilities Test End]\\n\";\n}\n\n// Test 5.9: Gaussian Elimination\nvoid test_gaussian_eliminate()\n{\n    std::cout &lt;&lt; \"\\n[Gaussian Elimination Test]\\n\";\n\n    /*** Test 1: Simple 3x3 System ***/\n    std::cout &lt;&lt; \"\\n[Test 1] 3x3 Matrix (Simple Upper Triangular)\\n\";\n    tiny::Mat mat1(3, 3);\n    mat1(0,0) = 2; mat1(0,1) = 1; mat1(0,2) = -1;\n    mat1(1,0) = -3; mat1(1,1) = -1; mat1(1,2) = 2;\n    mat1(2,0) = -2; mat1(2,1) = 1; mat1(2,2) = 2;\n\n    std::cout &lt;&lt; \"Original Matrix:\\n\";\n    mat1.print_matrix(true);\n\n    tiny::Mat result1 = mat1.gaussian_eliminate();\n\n    std::cout &lt;&lt; \"After Gaussian Elimination (Should be upper triangular):\\n\";\n    result1.print_matrix(true);\n\n    /*** Test 2: 3x4 Augmented Matrix ***/\n    std::cout &lt;&lt; \"\\n[Test 2] 3x4 Augmented Matrix (Linear System Ax = b)\\n\";\n    tiny::Mat mat2(3, 4);\n    mat2(0,0) = 1; mat2(0,1) = 2; mat2(0,2) = -1; mat2(0,3) =  8;\n    mat2(1,0) = -3; mat2(1,1) = -1; mat2(1,2) = 2; mat2(1,3) = -11;\n    mat2(2,0) = -2; mat2(2,1) = 1; mat2(2,2) = 2; mat2(2,3) = -3;\n\n    std::cout &lt;&lt; \"Original Augmented Matrix [A | b]:\\n\";\n    mat2.print_matrix(true);\n\n    tiny::Mat result2 = mat2.gaussian_eliminate();\n\n    std::cout &lt;&lt; \"After Gaussian Elimination (Row Echelon Form):\\n\";\n    result2.print_matrix(true);\n\n    /*** Test 3: Singular Matrix ***/\n    std::cout &lt;&lt; \"\\n[Test 3] Singular Matrix (No unique solution)\\n\";\n    tiny::Mat mat3(2, 2);\n    mat3(0,0) = 1; mat3(0,1) = 2;\n    mat3(1,0) = 2; mat3(1,1) = 4;  // Linearly dependent rows\n\n    std::cout &lt;&lt; \"Original Singular Matrix:\\n\";\n    mat3.print_matrix(true);\n\n    tiny::Mat result3 = mat3.gaussian_eliminate();\n    std::cout &lt;&lt; \"After Gaussian Elimination (Should show rows of zeros):\\n\";\n    result3.print_matrix(true);\n\n    /*** Test 4: Zero Matrix ***/\n    std::cout &lt;&lt; \"\\n[Test 4] Zero Matrix\\n\";\n    tiny::Mat mat4(3, 3);\n    mat4.clear();  // Assuming clear() sets all elements to zero\n    mat4.print_matrix(true);\n\n    tiny::Mat result4 = mat4.gaussian_eliminate();\n    std::cout &lt;&lt; \"After Gaussian Elimination (Should be a zero matrix):\\n\";\n    result4.print_matrix(true);\n}\n\n\n// Test 5.10: Row Reduce from Gaussian (RREF Calculation)\nvoid test_row_reduce_from_gaussian()\n{\n    std::cout &lt;&lt; \"\\n[Test] Row Reduce From Gaussian (RREF Calculation)\\n\";\n\n    // Example 1: Simple 3x4 augmented matrix (representing a system of equations)\n    std::cout &lt;&lt; \"\\n[Test 1] 3x4 Augmented Matrix\\n\";\n    tiny::Mat mat1(3, 4);\n\n    // Matrix:\n    // [ 1  2 -1  -4 ]\n    // [ 2  3 -1 -11 ]\n    // [-2  0 -3  22 ]\n    mat1(0,0) = 1;  mat1(0,1) = 2;  mat1(0,2) = -1; mat1(0,3) = -4;\n    mat1(1,0) = 2;  mat1(1,1) = 3;  mat1(1,2) = -1; mat1(1,3) = -11;\n    mat1(2,0) = -2; mat1(2,1) = 0;  mat1(2,2) = -3; mat1(2,3) = 22;\n\n    std::cout &lt;&lt; \"Original Matrix:\\n\";\n    mat1.print_matrix(true);\n\n    tiny::Mat rref1 = mat1.gaussian_eliminate().row_reduce_from_gaussian();\n    std::cout &lt;&lt; \"RREF Result:\\n\";\n    rref1.print_matrix(true);\n\n    // Example 2: 2x3 Matrix\n    std::cout &lt;&lt; \"\\n[Test 2] 2x3 Matrix\\n\";\n    tiny::Mat mat2(2, 3);\n    mat2(0,0) = 1; mat2(0,1) = 2;  mat2(0,2) = 3;\n    mat2(1,0) = 4; mat2(1,1) = 5;  mat2(1,2) = 6;\n\n    std::cout &lt;&lt; \"Original Matrix:\\n\";\n    mat2.print_matrix(true);\n\n    tiny::Mat rref2 = mat2.gaussian_eliminate().row_reduce_from_gaussian();\n    std::cout &lt;&lt; \"RREF Result:\\n\";\n    rref2.print_matrix(true);\n\n    // Example 3: Already reduced matrix (should remain the same)\n    std::cout &lt;&lt; \"\\n[Test 3] Already Reduced Matrix\\n\";\n    tiny::Mat mat3(2, 3);\n    mat3(0,0) = 1; mat3(0,1) = 0; mat3(0,2) = 2;\n    mat3(1,0) = 0; mat3(1,1) = 1; mat3(1,2) = 3;\n\n    std::cout &lt;&lt; \"Original Matrix:\\n\";\n    mat3.print_matrix(true);\n\n    tiny::Mat rref3 = mat3.row_reduce_from_gaussian();\n    std::cout &lt;&lt; \"RREF Result:\\n\";\n    rref3.print_matrix(true);\n}\n\n// Test 5.11 gaussian inverse\nvoid test_inverse_gje()\n{\n    std::cout &lt;&lt; \"\\n--- Test: Gaussian Inverse ---\\n\";\n\n    /*** Test1: Regular 2x2 Matrix ***/\n    std::cout &lt;&lt; \"[Test 1: 2x2 Matrix Inverse]\\n\";\n    tiny::Mat mat1(2, 2);\n    mat1(0, 0) = 4; mat1(0, 1) = 7;\n    mat1(1, 0) = 2; mat1(1, 1) = 6;\n    std::cout &lt;&lt; \"Original matrix (mat1):\\n\";\n    mat1.print_matrix(true);\n\n    tiny::Mat invMat1 = mat1.inverse_gje();\n    std::cout &lt;&lt; \"Inverse matrix (mat1):\\n\";\n    invMat1.print_matrix(true);\n\n    /*** Test2: Identity Matrix (should return identity matrix) ***/\n    std::cout &lt;&lt; \"[Test 2: Identity Matrix Inverse]\\n\";\n    tiny::Mat mat2 = tiny::Mat::eye(3);\n    std::cout &lt;&lt; \"Original matrix (Identity):\\n\";\n    mat2.print_matrix(true);\n\n    tiny::Mat invMat2 = mat2.inverse_gje();\n    std::cout &lt;&lt; \"Inverse matrix (Identity):\\n\";\n    invMat2.print_matrix(true); // Expected: Identity matrix\n\n    /*** Test3: Singular Matrix (should return empty matrix or indicate error) ***/\n    std::cout &lt;&lt; \"[Test 3: Singular Matrix (Expected: No Inverse)]\\n\";\n    tiny::Mat mat3(3, 3);\n    mat3(0, 0) = 1; mat3(0, 1) = 2; mat3(0, 2) = 3;\n    mat3(1, 0) = 4; mat3(1, 1) = 5; mat3(1, 2) = 6;\n    mat3(2, 0) = 7; mat3(2, 1) = 8; mat3(2, 2) = 9;  // Determinant is 0\n    std::cout &lt;&lt; \"Original matrix (singular):\\n\";\n    mat3.print_matrix(true);\n\n    tiny::Mat invMat3 = mat3.inverse_gje();\n    std::cout &lt;&lt; \"Inverse matrix (singular):\\n\";\n    invMat3.print_matrix(true); // Expected: empty matrix or error message\n\n    /*** Test4: 3x3 Matrix with a valid inverse ***/\n    std::cout &lt;&lt; \"[Test 4: 3x3 Matrix Inverse]\\n\";\n    tiny::Mat mat4(3, 3);\n    mat4(0, 0) = 4; mat4(0, 1) = 7; mat4(0, 2) = 2;\n    mat4(1, 0) = 3; mat4(1, 1) = 5; mat4(1, 2) = 1;\n    mat4(2, 0) = 8; mat4(2, 1) = 6; mat4(2, 2) = 9;\n    std::cout &lt;&lt; \"Original matrix (mat4):\\n\";\n    mat4.print_matrix(true);\n\n    tiny::Mat invMat4 = mat4.inverse_gje();\n    std::cout &lt;&lt; \"Inverse matrix (mat4):\\n\";\n    invMat4.print_matrix(true); // Check that the inverse is calculated correctly\n\n    /*** Test5: Non-square Matrix (should return error or empty matrix) ***/\n    std::cout &lt;&lt; \"[Test 5: Non-square Matrix Inverse (Expected Error)]\\n\";\n    tiny::Mat mat5(2, 3);\n    mat5(0, 0) = 1; mat5(0, 1) = 2; mat5(0, 2) = 3;\n    mat5(1, 0) = 4; mat5(1, 1) = 5; mat5(1, 2) = 6;\n    std::cout &lt;&lt; \"Original matrix (non-square):\\n\";\n    mat5.print_matrix(true);\n\n    tiny::Mat invMat5 = mat5.inverse_gje();\n    std::cout &lt;&lt; \"Inverse matrix (non-square):\\n\";\n    invMat5.print_matrix(true); // Expected: Error message or empty matrix\n}\n\n// Test 5.12: Dot Product\nvoid test_dotprod()\n{\n    std::cout &lt;&lt; \"\\n--- Test: Dot Product ---\\n\";\n\n    // Test 1: Valid Dot Product Calculation (Same Length Vectors)\n    std::cout &lt;&lt; \"[Test 1] Valid Dot Product (Same Length Vectors)\\n\";\n    tiny::Mat vectorA(3, 1);  // Create a 3x1 vector\n    tiny::Mat vectorB(3, 1);  // Create a 3x1 vector\n\n    // Initialize vectors\n    vectorA(0, 0) = 1.0f;\n    vectorA(1, 0) = 2.0f;\n    vectorA(2, 0) = 3.0f;\n\n    vectorB(0, 0) = 4.0f;\n    vectorB(1, 0) = 5.0f;\n    vectorB(2, 0) = 6.0f;\n\n    // Compute the dot product\n    float result = vectorA.dotprod(vectorA, vectorB);\n    std::cout &lt;&lt; \"Dot product of vectorA and vectorB: \" &lt;&lt; result &lt;&lt; std::endl;  // Expected result: 1*4 + 2*5 + 3*6 = 32\n\n    // Test 2: Dot Product with Dimension Mismatch (Different Length Vectors)\n    std::cout &lt;&lt; \"[Test 2] Invalid Dot Product (Dimension Mismatch)\\n\";\n    tiny::Mat vectorC(2, 1);  // Create a 2x1 vector (different size)\n    vectorC(0, 0) = 1.0f;\n    vectorC(1, 0) = 2.0f;\n\n    float invalidResult = vectorA.dotprod(vectorA, vectorC);  // Should print an error and return 0\n    std::cout &lt;&lt; \"Dot product (dimension mismatch): \" &lt;&lt; invalidResult &lt;&lt; std::endl;  // Expected: 0 and error message\n\n    // Test 3: Dot Product of Zero Vectors\n    std::cout &lt;&lt; \"[Test 3] Dot Product of Zero Vectors\\n\";\n    tiny::Mat zeroVectorA(3, 1);  // Create a 3x1 zero vector\n    tiny::Mat zeroVectorB(3, 1);  // Create a 3x1 zero vector\n\n    // Initialize vectors\n    zeroVectorA(0, 0) = 0.0f;\n    zeroVectorA(1, 0) = 0.0f;\n    zeroVectorA(2, 0) = 0.0f;\n\n    zeroVectorB(0, 0) = 0.0f;\n    zeroVectorB(1, 0) = 0.0f;\n    zeroVectorB(2, 0) = 0.0f;\n\n    float zeroResult = zeroVectorA.dotprod(zeroVectorA, zeroVectorB);\n    std::cout &lt;&lt; \"Dot product of zero vectors: \" &lt;&lt; zeroResult &lt;&lt; std::endl;  // Expected: 0\n\n    std::cout &lt;&lt; \"[Dot Product Test End]\\n\";\n}\n\n// Test 5.13: Solve Linear System\nvoid test_solve()\n{\n    std::cout &lt;&lt; \"\\n[Test: Solve Linear System Ax = b]\\n\";\n\n    // Test 1: Solving a simple 2x2 system\n    std::cout &lt;&lt; \"[Test1] Solving a simple 2x2 system Ax = b\\n\";\n    tiny::Mat A(2, 2);\n    tiny::Mat b(2, 1);\n\n    A(0, 0) = 2; A(0, 1) = 1;\n    A(1, 0) = 1; A(1, 1) = 3;\n\n    b(0, 0) = 5;\n    b(1, 0) = 6;\n\n    tiny::Mat solution = A.solve(A, b);\n    std::cout &lt;&lt; \"Solution: \\n\";\n    solution.print_matrix(true);\n\n    // Test 2: Solving a 3x3 system\n    std::cout &lt;&lt; \"[Test2] Solving a 3x3 system Ax = b\\n\";\n    tiny::Mat A2(3, 3);\n    tiny::Mat b2(3, 1);\n\n    A2(0, 0) = 1; A2(0, 1) = 2; A2(0, 2) = 1;\n    A2(1, 0) = 2; A2(1, 1) = 0; A2(1, 2) = 3;\n    A2(2, 0) = 3; A2(2, 1) = 2; A2(2, 2) = 1;\n\n    b2(0, 0) = 9;\n    b2(1, 0) = 8;\n    b2(2, 0) = 7;\n\n    tiny::Mat solution2 = A2.solve(A2, b2);\n    std::cout &lt;&lt; \"Solution: \\n\";\n    solution2.print_matrix(true);\n\n    // Test 3: Solving a system where one row is all zeros\n    std::cout &lt;&lt; \"[Test3] Solving a system where one row is all zeros (expect failure or infinite solutions)\\n\";\n    tiny::Mat A3(3, 3);\n    tiny::Mat b3(3, 1);\n\n    A3(0, 0) = 1; A3(0, 1) = 2; A3(0, 2) = 3;\n    A3(1, 0) = 0; A3(1, 1) = 0; A3(1, 2) = 0; // Zero row\n    A3(2, 0) = 4; A3(2, 1) = 5; A3(2, 2) = 6;\n\n    b3(0, 0) = 9;\n    b3(1, 0) = 0; // Inconsistent, no solution should be possible\n    b3(2, 0) = 15;\n\n    tiny::Mat solution3 = A3.solve(A3, b3);\n    std::cout &lt;&lt; \"Solution: \\n\";\n    solution3.print_matrix(true);\n\n    // Test 4: Solving a system with zero determinant (singular matrix)\n    std::cout &lt;&lt; \"[Test4] Solving a system with zero determinant (singular matrix)\\n\";\n    tiny::Mat A4(3, 3);\n    tiny::Mat b4(3, 1);\n\n    A4(0, 0) = 2; A4(0, 1) = 4; A4(0, 2) = 1;\n    A4(1, 0) = 1; A4(1, 1) = 2; A4(1, 2) = 3;\n    A4(2, 0) = 3; A4(2, 1) = 6; A4(2, 2) = 2; // The matrix is singular (row 2 = 2 * row 1)\n\n    b4(0, 0) = 5;\n    b4(1, 0) = 6;\n    b4(2, 0) = 7;\n\n    tiny::Mat solution4 = A4.solve(A4, b4);\n    std::cout &lt;&lt; \"Solution: \\n\";\n    solution4.print_matrix(true); // Expect no solution or an error message\n\n    // Test 5: Solving a system with linearly dependent rows\n    std::cout &lt;&lt; \"[Test5] Solving a system with linearly dependent rows (expect failure or infinite solutions)\\n\";\n    tiny::Mat A5(3, 3);\n    tiny::Mat b5(3, 1);\n\n    A5(0, 0) = 1; A5(0, 1) = 1; A5(0, 2) = 1;\n    A5(1, 0) = 2; A5(1, 1) = 2; A5(1, 2) = 2;\n    A5(2, 0) = 3; A5(2, 1) = 3; A5(2, 2) = 3; // All rows are linearly dependent\n\n    b5(0, 0) = 6;\n    b5(1, 0) = 12;\n    b5(2, 0) = 18;\n\n    tiny::Mat solution5 = A5.solve(A5, b5);\n    std::cout &lt;&lt; \"Solution: \\n\";\n    solution5.print_matrix(true); // Expect an error message or infinite solutions\n\n    // Test 6: Solving a larger 4x4 system\n    std::cout &lt;&lt; \"[Test6] Solving a larger 4x4 system Ax = b\\n\";\n    tiny::Mat A6(4, 4);\n    tiny::Mat b6(4, 1);\n\n    A6(0, 0) = 4; A6(0, 1) = 2; A6(0, 2) = 3; A6(0, 3) = 1;\n    A6(1, 0) = 2; A6(1, 1) = 5; A6(1, 2) = 1; A6(1, 3) = 2;\n    A6(2, 0) = 3; A6(2, 1) = 1; A6(2, 2) = 6; A6(2, 3) = 3;\n    A6(3, 0) = 1; A6(3, 1) = 2; A6(3, 2) = 3; A6(3, 3) = 4;\n\n    b6(0, 0) = 10;\n    b6(1, 0) = 12;\n    b6(2, 0) = 14;\n    b6(3, 0) = 16;\n\n    tiny::Mat solution6 = A6.solve(A6, b6);\n    std::cout &lt;&lt; \"Solution: \\n\";\n    solution6.print_matrix(true); // Should print the solution vector\n\n    std::cout &lt;&lt; \"[Test end]\\n\";\n}\n\n// Test 5.14: Band Solve\nvoid test_band_solve()\n{\n    std::cout &lt;&lt; \"\\n[band_solve Test]\\n\";\n\n    /*** Test 1: Simple 3x3 Band Matrix ***/\n    std::cout &lt;&lt; \"[Test 1] Simple 3x3 Band Matrix\\n\";\n    tiny::Mat A1(3, 3);\n    tiny::Mat b1(3, 1);\n\n    // Define the matrix A and vector b for the system Ax = b\n    A1(0, 0) = 2; A1(0, 1) = 1; A1(0, 2) = 0;\n    A1(1, 0) = 1; A1(1, 1) = 3; A1(1, 2) = 2;\n    A1(2, 0) = 0; A1(2, 1) = 1; A1(2, 2) = 4;\n\n    b1(0, 0) = 5;\n    b1(1, 0) = 6;\n    b1(2, 0) = 7;\n\n    // Solve Ax = b using band_solve\n    tiny::Mat solution1 = A1.band_solve(A1, b1, 3);\n    std::cout &lt;&lt; \"Solution: \\n\";\n    solution1.print_matrix(true);\n\n    /*** Test 2: 4x4 Band Matrix with different right-hand side vector ***/\n    std::cout &lt;&lt; \"[Test 2] 4x4 Band Matrix\\n\";\n    tiny::Mat A2(4, 4);\n    tiny::Mat b2(4, 1);\n\n    // Define the matrix A and vector b\n    A2(0, 0) = 2; A2(0, 1) = 1; A2(0, 2) = 0; A2(0, 3) = 0;\n    A2(1, 0) = 1; A2(1, 1) = 3; A2(1, 2) = 2; A2(1, 3) = 0;\n    A2(2, 0) = 0; A2(2, 1) = 1; A2(2, 2) = 4; A2(2, 3) = 2;\n    A2(3, 0) = 0; A2(3, 1) = 0; A2(3, 2) = 1; A2(3, 3) = 5;\n\n    b2(0, 0) = 8;\n    b2(1, 0) = 9;\n    b2(2, 0) = 10;\n    b2(3, 0) = 11;\n\n    // Solve Ax = b using band_solve\n    tiny::Mat solution2 = A2.band_solve(A2, b2, 3);\n    std::cout &lt;&lt; \"Solution: \\n\";\n    solution2.print_matrix(true);\n\n    /*** Test 3: Incompatible dimensions (expect error) ***/\n    std::cout &lt;&lt; \"[Test 3] Incompatible Dimensions (Expect Error)\\n\";\n    tiny::Mat A3(3, 3);\n    tiny::Mat b3(2, 1);  // Incompatible dimension\n\n    A3(0, 0) = 1; A3(0, 1) = 2; A3(0, 2) = 3;\n    A3(1, 0) = 4; A3(1, 1) = 5; A3(1, 2) = 6;\n    A3(2, 0) = 7; A3(2, 1) = 8; A3(2, 2) = 9;\n\n    b3(0, 0) = 10;\n    b3(1, 0) = 11;\n\n    // This should print an error because of incompatible dimensions\n    tiny::Mat solution3 = A3.band_solve(A3, b3, 3);\n    std::cout &lt;&lt; \"Solution: \\n\";\n    solution3.print_matrix(true);\n\n    /*** Test 4: Singular Matrix (Should fail) ***/\n    std::cout &lt;&lt; \"[Test 4] Singular Matrix (No unique solution)\\n\";\n    tiny::Mat A4(3, 3);\n    tiny::Mat b4(3, 1);\n\n    // Define a singular matrix (linearly dependent rows)\n    A4(0, 0) = 1; A4(0, 1) = 2; A4(0, 2) = 3;\n    A4(1, 0) = 2; A4(1, 1) = 4; A4(1, 2) = 6;\n    A4(2, 0) = 3; A4(2, 1) = 6; A4(2, 2) = 9;\n\n    b4(0, 0) = 10;\n    b4(1, 0) = 20;\n    b4(2, 0) = 30;\n\n    // This should print an error as the matrix is singular and does not have a unique solution\n    tiny::Mat solution4 = A4.band_solve(A4, b4, 3);\n    std::cout &lt;&lt; \"Solution: \\n\";\n    solution4.print_matrix(true);\n}\n\n// Test 5.15: Roots\nvoid test_roots()\n{\n    std::cout &lt;&lt; \"\\n[Roots Test]\\n\";\n\n    /*** Test 1: Simple 2x2 System ***/\n    std::cout &lt;&lt; \"[Test 1] Solving a simple 2x2 system Ax = b\\n\";\n    tiny::Mat A1(2, 2);\n    tiny::Mat b1(2, 1);\n\n    // Define the matrix A and vector b for the system Ax = b\n    A1(0, 0) = 2; A1(0, 1) = 1;\n    A1(1, 0) = 1; A1(1, 1) = 3;\n\n    b1(0, 0) = 5;\n    b1(1, 0) = 6;\n\n    // Solve Ax = b using roots\n    tiny::Mat solution1 = A1.roots(A1, b1);\n    std::cout &lt;&lt; \"Solution: \\n\";\n    solution1.print_matrix(true);\n\n    /*** Test 2: 3x3 System ***/\n    std::cout &lt;&lt; \"[Test 2] Solving a 3x3 system Ax = b\\n\";\n    tiny::Mat A2(3, 3);\n    tiny::Mat b2(3, 1);\n\n    A2(0, 0) = 1; A2(0, 1) = 2; A2(0, 2) = 1;\n    A2(1, 0) = 2; A2(1, 1) = 0; A2(1, 2) = 3;\n    A2(2, 0) = 3; A2(2, 1) = 2; A2(2, 2) = 1;\n\n    b2(0, 0) = 9;\n    b2(1, 0) = 8;\n    b2(2, 0) = 7;\n\n    // Solve Ax = b using roots\n    tiny::Mat solution2 = A2.roots(A2, b2);\n    std::cout &lt;&lt; \"Solution: \\n\";\n    solution2.print_matrix(true);\n\n    /*** Test 3: Singular Matrix ***/\n    std::cout &lt;&lt; \"[Test 3] Singular Matrix (No unique solution)\\n\";\n    tiny::Mat A3(2, 2);\n    tiny::Mat b3(2, 1);\n\n    // Define a singular matrix (linearly dependent rows)\n    A3(0, 0) = 1; A3(0, 1) = 2;\n    A3(1, 0) = 2; A3(1, 1) = 4;\n\n    b3(0, 0) = 5;\n    b3(1, 0) = 6;\n\n    // This should print an error as the matrix is singular and does not have a unique solution\n    tiny::Mat solution3 = A3.roots(A3, b3);\n    std::cout &lt;&lt; \"Solution: \\n\";\n    solution3.print_matrix(true);\n\n    /*** Test 4: Incompatible Dimensions (Expect Error) ***/\n    std::cout &lt;&lt; \"[Test 4] Incompatible Dimensions (Expect Error)\\n\";\n    tiny::Mat A4(3, 3);\n    tiny::Mat b4(2, 1);  // Incompatible dimension\n\n    A4(0, 0) = 1; A4(0, 1) = 2; A4(0, 2) = 3;\n    A4(1, 0) = 4; A4(1, 1) = 5; A4(1, 2) = 6;\n    A4(2, 0) = 7; A4(2, 1) = 8; A4(2, 2) = 9;\n\n    b4(0, 0) = 10;\n    b4(1, 0) = 11;\n\n    // This should print an error because of incompatible dimensions\n    tiny::Mat solution4 = A4.roots(A4, b4);\n    std::cout &lt;&lt; \"Solution: \\n\";\n    solution4.print_matrix(true);\n}\n\n// Group 6: Stream Operators\nvoid test_stream_operators()\n{\n    std::cout &lt;&lt; \"\\n[Test: Stream Operators]\\n\";\n\n    // Test 1: Test stream insertion operator (&lt;&lt;) for Mat\n    std::cout &lt;&lt; \"[Test 1] Stream Insertion Operator (&lt;&lt;) for Mat\\n\";\n    tiny::Mat mat1(3, 3);\n    mat1(0, 0) = 1; mat1(0, 1) = 2; mat1(0, 2) = 3;\n    mat1(1, 0) = 4; mat1(1, 1) = 5; mat1(1, 2) = 6;\n    mat1(2, 0) = 7; mat1(2, 1) = 8; mat1(2, 2) = 9;\n\n    std::cout &lt;&lt; \"Matrix mat1:\\n\";\n    std::cout &lt;&lt; mat1 &lt;&lt; std::endl; // Use the &lt;&lt; operator to print mat1\n\n    // Test 2: Test stream insertion operator (&lt;&lt;) for Mat::ROI\n    std::cout &lt;&lt; \"[Test 2] Stream Insertion Operator (&lt;&lt;) for Mat::ROI\\n\";\n    tiny::Mat::ROI roi(1, 2, 3, 4);\n    std::cout &lt;&lt; \"ROI roi:\\n\";\n    std::cout &lt;&lt; roi &lt;&lt; std::endl; // Use the &lt;&lt; operator to print roi\n\n    // Test 3: Test stream extraction operator (&gt;&gt;) for Mat\n    std::cout &lt;&lt; \"[Test 3] Stream Extraction Operator (&gt;&gt;) for Mat\\n\";\n    tiny::Mat mat2(2, 2);\n    std::cout &lt;&lt; \"Please enter 4 elements for a 2x2 matrix:\\n\";\n    std::cin &gt;&gt; mat2; // Use the &gt;&gt; operator to input mat2\n    std::cout &lt;&lt; \"Matrix mat2 after input:\\n\";\n    std::cout &lt;&lt; mat2 &lt;&lt; std::endl; // Use the &lt;&lt; operator to print mat2\n\n    // Test 4: Test stream extraction operator (&gt;&gt;) for Mat (with invalid input)\n    std::cout &lt;&lt; \"[Test 4] Stream Extraction Operator (&gt;&gt;) for Mat with invalid input\\n\";\n    tiny::Mat mat3(2, 3);\n    std::cout &lt;&lt; \"Please enter 6 elements for a 2x3 matrix:\\n\";\n    std::cin &gt;&gt; mat3; // Use the &gt;&gt; operator to input mat3\n    std::cout &lt;&lt; \"Matrix mat3 after input:\\n\";\n    std::cout &lt;&lt; mat3 &lt;&lt; std::endl; // Use the &lt;&lt; operator to print mat3\n}\n\n// Group 7: Global Arithmetic Operators\n\nvoid test_matrix_operations()\n{\n    std::cout &lt;&lt; \"\\n[Test: Matrix Operations]\\n\";\n\n    /*** Test 1: Matrix Addition (operator+) ***/\n    std::cout &lt;&lt; \"\\n[Test 1] Matrix Addition (operator+)\\n\";\n    tiny::Mat matA(2, 2);\n    tiny::Mat matB(2, 2);\n\n    matA(0, 0) = 1; matA(0, 1) = 2;\n    matA(1, 0) = 3; matA(1, 1) = 4;\n\n    matB(0, 0) = 5; matB(0, 1) = 6;\n    matB(1, 0) = 7; matB(1, 1) = 8;\n\n    tiny::Mat resultAdd = matA + matB;\n    std::cout &lt;&lt; \"matA + matB:\\n\";\n    std::cout &lt;&lt; resultAdd &lt;&lt; std::endl;  // Expected: [6, 8], [10, 12]\n\n    /*** Test 2: Matrix Addition with Constant (operator+) ***/\n    std::cout &lt;&lt; \"\\n[Test 2] Matrix Addition with Constant (operator+)\\n\";\n    tiny::Mat resultAddConst = matA + 5.0f;\n    std::cout &lt;&lt; \"matA + 5.0f:\\n\";\n    std::cout &lt;&lt; resultAddConst &lt;&lt; std::endl;  // Expected: [6, 7], [8, 9]\n\n    /*** Test 3: Matrix Subtraction (operator-) ***/\n    std::cout &lt;&lt; \"\\n[Test 3] Matrix Subtraction (operator-)\\n\";\n    tiny::Mat resultSub = matA - matB;\n    std::cout &lt;&lt; \"matA - matB:\\n\";\n    std::cout &lt;&lt; resultSub &lt;&lt; std::endl;  // Expected: [-4, -4], [-4, -4]\n\n    /*** Test 4: Matrix Subtraction with Constant (operator-) ***/\n    std::cout &lt;&lt; \"\\n[Test 4] Matrix Subtraction with Constant (operator-)\\n\";\n    tiny::Mat resultSubConst = matA - 2.0f;\n    std::cout &lt;&lt; \"matA - 2.0f:\\n\";\n    std::cout &lt;&lt; resultSubConst &lt;&lt; std::endl;  // Expected: [-1, 0], [1, 2]\n\n    /*** Test 5: Matrix Multiplication (operator*) ***/\n    std::cout &lt;&lt; \"\\n[Test 5] Matrix Multiplication (operator*)\\n\";\n    tiny::Mat matC(2, 3);\n    tiny::Mat matD(3, 2);\n\n    matC(0, 0) = 1; matC(0, 1) = 2; matC(0, 2) = 3;\n    matC(1, 0) = 4; matC(1, 1) = 5; matC(1, 2) = 6;\n\n    matD(0, 0) = 7; matD(0, 1) = 8;\n    matD(1, 0) = 9; matD(1, 1) = 10;\n    matD(2, 0) = 11; matD(2, 1) = 12;\n\n    tiny::Mat resultMul = matC * matD;\n    std::cout &lt;&lt; \"matC * matD:\\n\";\n    std::cout &lt;&lt; resultMul &lt;&lt; std::endl;  // Expected: [58, 64], [139, 154]\n\n    /*** Test 6: Matrix Multiplication with Constant (operator*) ***/\n    std::cout &lt;&lt; \"\\n[Test 6] Matrix Multiplication with Constant (operator*)\\n\";\n    tiny::Mat resultMulConst = matA * 2.0f;\n    std::cout &lt;&lt; \"matA * 2.0f:\\n\";\n    std::cout &lt;&lt; resultMulConst &lt;&lt; std::endl;  // Expected: [2, 4], [6, 8]\n\n    /*** Test 7: Matrix Division (operator/) ***/\n    std::cout &lt;&lt; \"\\n[Test 7] Matrix Division (operator/)\\n\";\n    tiny::Mat resultDiv = matA / 2.0f;\n    std::cout &lt;&lt; \"matA / 2.0f:\\n\";\n    std::cout &lt;&lt; resultDiv &lt;&lt; std::endl;  // Expected: [0.5, 1], [1.5, 2]\n\n    /*** Test 8: Matrix Division Element-wise (operator/) ***/\n    std::cout &lt;&lt; \"\\n[Test 8] Matrix Division Element-wise (operator/)\\n\";\n    tiny::Mat resultDivElem = matA / matB;\n    std::cout &lt;&lt; \"matA / matB:\\n\";\n    std::cout &lt;&lt; resultDivElem &lt;&lt; std::endl;  // Expected: [0.2, 0.333], [0.428, 0.5]\n\n    /*** Test 9: Matrix Comparison (operator==) ***/\n    std::cout &lt;&lt; \"\\n[Test 9] Matrix Comparison (operator==)\\n\";\n    tiny::Mat matE(2, 2);\n    matE(0, 0) = 1; matE(0, 1) = 2;\n    matE(1, 0) = 3; matE(1, 1) = 4;\n\n    tiny::Mat matF(2, 2);\n    matF(0, 0) = 1; matF(0, 1) = 2;\n    matF(1, 0) = 3; matF(1, 1) = 4;\n\n    bool isEqual = (matE == matF);\n    std::cout &lt;&lt; \"matE == matF: \" &lt;&lt; (isEqual ? \"True\" : \"False\") &lt;&lt; std::endl;  // Expected: True\n\n    matF(0, 0) = 5;  // Modify matF\n    isEqual = (matE == matF);\n    std::cout &lt;&lt; \"matE == matF after modification: \" &lt;&lt; (isEqual ? \"True\" : \"False\") &lt;&lt; std::endl;  // Expected: False\n}\n\nvoid tiny_matrix_test()\n{\n    std::cout &lt;&lt; \"============ [tiny_matrix_test start] ============\\n\";\n\n    // Group 1: constructor &amp; destructor\n    test_constructor_destructor();\n\n    // Group 2: element access\n    // test_element_access();\n\n    // Group 3: ROI operations\n    // test_roi_operations();\n\n    // Group 4: arithmetic operators\n    // test_assignment_operator();\n    // test_matrix_addition();\n    // test_constant_addition();\n    // test_matrix_subtraction();\n    // test_constant_subtraction();\n    // test_matrix_division();\n    // test_constant_division();\n    // test_matrix_exponentiation();\n\n    // Group 5: Linear algebra tests\n    // test_matrix_transpose();\n    // test_matrix_cofactor();\n    // test_matrix_determinant();\n    // test_matrix_adjoint();\n    // test_matrix_normalize();\n    // test_matrix_norm();\n    // test_inverse_adjoint();\n    // test_matrix_utilities();\n    // test_gaussian_eliminate();\n    // test_row_reduce_from_gaussian();\n    // test_inverse_gje();\n    // test_dotprod();\n    // test_solve();\n    // test_band_solve();\n    // test_roots();\n\n    // Group 6: Stream operators\n    // test_stream_operators();\n    // test_matrix_operations();\n\n    std::cout &lt;&lt; \"============ [tiny_matrix_test end] ============\\n\";\n}\n</code></pre>"},{"location":"MATH/USAGE/usage/","title":"USAGE INSTRUCTIONS","text":"<p>Usage Instructions</p> <p>This document provides usage instructions for the <code>tiny_math</code> module.</p>"},{"location":"MATH/USAGE/usage/#import-tinymath-as-a-whole","title":"Import TinyMath as a Whole","text":"<p>Info</p> <p>Suitable for C projects or projects with a simple structure in C++.</p> <pre><code>#include \"tiny_math.h\"\n</code></pre>"},{"location":"MATH/USAGE/usage/#import-tinymath-by-module","title":"Import TinyMath by Module","text":"<p>Info</p> <p>Suitable for projects that require precise control over module imports or complex C++ projects.</p> <pre><code>#include \"tiny_vec.h\" // Import vector module\n#include \"tiny_mat.h\" // Import matrix module\n</code></pre> <pre><code>#include \"tiny_matrix.hpp\" // Import advanced matrix module\n</code></pre> <p>Note</p> <ul> <li> <p><code>tiny_vec.h</code> and <code>tiny_mat.h</code> are header files for the C language version, suitable for C programming.</p> </li> <li> <p><code>tiny_matrix.hpp</code> is a header file for the C++ language version, suitable for C++ programming.</p> </li> </ul> <p>In simple terms, C language projects can only use <code>tiny_vec.h</code> and <code>tiny_mat.h</code>, while C++ projects can use <code>tiny_vec.h</code>, <code>tiny_mat.h</code>, and <code>tiny_matrix.hpp</code>.</p> <p>Tip</p> <p>For specific usage methods, please refer to the test code.</p>"},{"location":"MATH/VECTOR/api/","title":"VECTOR OPERATIONS","text":""},{"location":"MATH/VECTOR/api/#list-of-functions","title":"LIST OF FUNCTIONS","text":"<pre><code>// Addition\ntiny_error_t tiny_vec_add_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_addc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n// Subtraction\ntiny_error_t tiny_vec_sub_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_subc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n// Multiplication\ntiny_error_t tiny_vec_mul_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_mulc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n// Division\ntiny_error_t tiny_vec_div_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out, bool allow_divide_by_zero);\ntiny_error_t tiny_vec_divc_f32(const float *input, float *output, int len, float C, int step_in, int step_out, bool allow_divide_by_zero);\n// Square root\ntiny_error_t tiny_vec_sqrt_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_sqrtf_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_inv_sqrt_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_inv_sqrtf_f32(const float *input, float *output, int len);\n// Dot product\ntiny_error_t tiny_vec_dotprod_f32(const float *src1, const float *src2, float *dest, int len);\ntiny_error_t tiny_vec_dotprode_f32(const float *src1, const float *src2, float *dest, int len, int step1, int step2);\n</code></pre>"},{"location":"MATH/VECTOR/api/#addition","title":"ADDITION","text":""},{"location":"MATH/VECTOR/api/#addition-of-two-vectors","title":"Addition of Two Vectors","text":"<pre><code>tiny_error_t tiny_vec_add_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\n</code></pre> <p>Function: Computes the element-wise addition of two vectors.</p> <p>Parameters:</p> <ul> <li><code>input1</code>: Pointer to the first input vector.</li> <li><code>input2</code>: Pointer to the second input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vectors.</li> <li><code>step1</code>: Step size for the first input vector.</li> <li><code>step2</code>: Step size for the second input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#addition-of-a-vector-and-a-constant","title":"Addition of a Vector and a Constant","text":"<pre><code>tiny_error_t tiny_vec_addc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n</code></pre> <p>Function: Computes the element-wise addition of a vector and a constant.</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> <li><code>C</code>: Constant value to be added.</li> <li><code>step_in</code>: Step size for the input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#subtraction","title":"SUBTRACTION","text":""},{"location":"MATH/VECTOR/api/#subtraction-of-two-vectors","title":"Subtraction of Two Vectors","text":"<pre><code>tiny_error_t tiny_vec_sub_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\n</code></pre> <p>Function: Computes the element-wise subtraction of two vectors.</p> <p>Parameters:</p> <ul> <li><code>input1</code>: Pointer to the first input vector.</li> <li><code>input2</code>: Pointer to the second input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vectors.</li> <li><code>step1</code>: Step size for the first input vector.</li> <li><code>step2</code>: Step size for the second input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#subtraction-of-a-vector-and-a-constant","title":"Subtraction of a Vector and a Constant","text":"<pre><code>tiny_error_t tiny_vec_subc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n</code></pre> <p>Function: Computes the element-wise subtraction of a vector and a constant.</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> <li><code>C</code>: Constant value to be subtracted.</li> <li><code>step_in</code>: Step size for the input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#multiplication","title":"MULTIPLICATION","text":""},{"location":"MATH/VECTOR/api/#multiplication-of-two-vectors","title":"Multiplication of Two Vectors","text":"<pre><code>tiny_error_t tiny_vec_mul_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\n</code></pre> <p>Function: Computes the element-wise multiplication of two vectors.</p> <p>Parameters:</p> <ul> <li><code>input1</code>: Pointer to the first input vector.</li> <li><code>input2</code>: Pointer to the second input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vectors.</li> <li><code>step1</code>: Step size for the first input vector.</li> <li><code>step2</code>: Step size for the second input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#multiplication-of-a-vector-and-a-constant","title":"Multiplication of a Vector and a Constant","text":"<pre><code>tiny_error_t tiny_vec_mulc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n</code></pre> <p>Function: Computes the element-wise multiplication of a vector and a constant.</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> <li><code>C</code>: Constant value to be multiplied.</li> <li><code>step_in</code>: Step size for the input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#division","title":"DIVISION","text":""},{"location":"MATH/VECTOR/api/#division-of-two-vectors","title":"Division of Two Vectors","text":"<pre><code>tiny_error_t tiny_vec_div_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out, bool allow_divide_by_zero);\n</code></pre> <p>Function: Computes the element-wise division of two vectors.</p> <p>Parameters:</p> <ul> <li><code>input1</code>: Pointer to the first input vector.</li> <li><code>input2</code>: Pointer to the second input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vectors.</li> <li><code>step1</code>: Step size for the first input vector.</li> <li><code>step2</code>: Step size for the second input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> <li><code>allow_divide_by_zero</code>: Flag to allow division by zero (true or false).</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#division-of-a-vector-and-a-constant","title":"Division of a Vector and a Constant","text":"<pre><code>tiny_error_t tiny_vec_divc_f32(const float *input, float *output, int len, float C, int step_in, int step_out, bool allow_divide_by_zero);\n</code></pre> <p>Function: Computes the element-wise division of a vector and a constant.</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> <li><code>C</code>: Constant value to be divided.</li> <li><code>step_in</code>: Step size for the input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> <li><code>allow_divide_by_zero</code>: Flag to allow division by zero (true or false).</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#square-root","title":"SQUARE ROOT","text":""},{"location":"MATH/VECTOR/api/#square-root-of-a-vector","title":"Square Root of a Vector","text":"<pre><code>tiny_error_t tiny_vec_sqrt_f32(const float *input, float *output, int len);\n</code></pre> <p>Function: Computes the element-wise square root of a vector.</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#square-root-of-a-vector-fast","title":"Square Root of a Vector (Fast)","text":"<pre><code>tiny_error_t tiny_vec_sqrtf_f32(const float *input, float *output, int len);\n</code></pre> <p>Function: Computes the element-wise square root of a vector (fast version).</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#inverse-square-root-of-a-vector","title":"Inverse Square Root of a Vector","text":"<pre><code>tiny_error_t tiny_vec_inv_sqrt_f32(const float *input, float *output, int len);\n</code></pre> <p>Function: Computes the element-wise inverse square root of a vector.</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#inverse-square-root-of-a-vector-fast","title":"Inverse Square Root of a Vector (Fast)","text":"<pre><code>tiny_error_t tiny_vec_inv_sqrtf_f32(const float *input, float *output, int len);\n</code></pre> <p>Function: Computes the element-wise inverse square root of a vector (fast version).</p> <p>Parameters:</p> <ul> <li><code>input</code>: Pointer to the input vector.</li> <li><code>output</code>: Pointer to the output vector.</li> <li><code>len</code>: Length of the vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#dot-product","title":"DOT PRODUCT","text":""},{"location":"MATH/VECTOR/api/#dot-product-of-two-vectors","title":"Dot Product of Two Vectors","text":"<pre><code>tiny_error_t tiny_vec_dotprod_f32(const float *src1, const float *src2, float *dest, int len);\n</code></pre> <p>Function: Computes the dot product of two vectors.</p> <p>Parameters:</p> <ul> <li><code>src1</code>: Pointer to the first input vector.</li> <li><code>src2</code>: Pointer to the second input vector.</li> <li><code>dest</code>: Pointer to the output scalar value.</li> <li><code>len</code>: Length of the vectors.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/api/#dot-product-of-two-vectors-with-different-steps","title":"Dot Product of Two Vectors with Different Steps","text":"<pre><code>tiny_error_t tiny_vec_dotprode_f32(const float *src1, const float *src2, float *dest, int len, int step1, int step2);\n</code></pre> <p>Function: Computes the dot product of two vectors with different step sizes.</p> <p>Parameters:</p> <ul> <li><code>src1</code>: Pointer to the first input vector.</li> <li><code>src2</code>: Pointer to the second input vector.</li> <li><code>dest</code>: Pointer to the output scalar value.</li> <li><code>len</code>: Length of the vectors.</li> <li><code>step1</code>: Step size for the first input vector.</li> <li><code>step2</code>: Step size for the second input vector.</li> <li><code>step_out</code>: Step size for the output vector.</li> </ul> <p>Returns: Returns a <code>tiny_error_t</code> type error code indicating whether the operation was successful.</p>"},{"location":"MATH/VECTOR/code/","title":"CODE","text":""},{"location":"MATH/VECTOR/code/#tiny_vech","title":"tiny_vec.h","text":"<pre><code>/**\n * @file tiny_vec.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the submodule vec of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY__VEC__\n#define __TINY__VEC__\n\n/* DEPENDENCIES */\n#include \"tiny_math_config.h\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* FUNCTION PROTOTYPES */\ntiny_error_t tiny_vec_add_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_addc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\ntiny_error_t tiny_vec_sub_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_subc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\ntiny_error_t tiny_vec_mul_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_mulc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\ntiny_error_t tiny_vec_div_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out, bool allow_divide_by_zero);\ntiny_error_t tiny_vec_divc_f32(const float *input, float *output, int len, float C, int step_in, int step_out, bool allow_divide_by_zero);\ntiny_error_t tiny_vec_sqrt_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_sqrtf_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_inv_sqrt_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_inv_sqrtf_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_dotprod_f32(const float *src1, const float *src2, float *dest, int len);\ntiny_error_t tiny_vec_dotprode_f32(const float *src1, const float *src2, float *dest, int len, int step1, int step2);\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY__VEC__ */\n</code></pre>"},{"location":"MATH/VECTOR/code/#tiny_vecc","title":"tiny_vec.c","text":"<pre><code>/**\n * @file tiny_vec.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the source file for the submodule vec of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n *\n */\n\n#include \"tiny_vec.h\"\n\n// #ifdef __cplusplus\n\n/* ADDITION */\n\n// vector + vector | float\n\n/**\n * @name tiny_vec_add_f32\n * @brief Adds two vectors element-wise.\n * @param input1 Pointer to the first input vector.\n * @param input2 Pointer to the second input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param step1 Step size for the first input vector.\n * @param step2 Step size for the second input vector.\n * @param step_out Step size for the output vector.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function performs element-wise addition of two vectors with specified step sizes, and the output is also specified with a step size.\n */\ntiny_error_t tiny_vec_add_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out)\n{\n    if (NULL == input1 || NULL == input2 || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (len &lt;= 0 || step1 &lt;= 0 || step2 &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized vector addition\n    dsps_add_f32(input1, input2, output, len, step1, step2, step_out);\n#else\n    // Fallback to a simple loop for vector addition\n    for (int i = 0; i &lt; len; i++)\n    {\n        output[i * step_out] = input1[i * step1] + input2[i * step2];\n    }\n\n#endif\n\n    return TINY_OK;\n}\n\n// vector + constant | float\n/**\n * @name tiny_vec_addc_f32\n * @brief Adds a constant to each element of a vector.\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param C Constant value to be added.\n * @param step_in Step size for the input vector.\n * @param step_out Step size for the output vector.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function adds a constant value to each element of the input vector, with specified step sizes for both input and output vectors.\n */\ntiny_error_t tiny_vec_addc_f32(const float *input, float *output, int len, float C, int step_in, int step_out)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (len &lt;= 0 || step_in &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized vector addition\n    dsps_addc_f32(input, output, len, C, step_in, step_out);\n#else\n    // Fallback to a simple loop for vector addition\n    for (int i = 0; i &lt; len; i++)\n    {\n        output[i * step_out] = input[i * step_in] + C;\n    }\n#endif\n    return TINY_OK;\n}\n\n/* SUBTRACTION */\n\n// vector - vector | float\n/**\n * @name tiny_vec_sub_f32\n * @brief Subtracts two vectors element-wise.\n * @param input1 Pointer to the first input vector.\n * @param input2 Pointer to the second input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param step1 Step size for the first input vector.\n * @param step2 Step size for the second input vector.\n * @param step_out Step size for the output vector.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function performs element-wise subtraction of two vectors with specified step sizes, and the output is also specified with a step size.\n */\ntiny_error_t tiny_vec_sub_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out)\n{\n    if (NULL == input1 || NULL == input2 || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (len &lt;= 0 || step1 &lt;= 0 || step2 &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized vector subtraction\n    dsps_sub_f32(input1, input2, output, len, step1, step2, step_out);\n#else\n    // Fallback to a simple loop for vector subtraction\n    for (int i = 0; i &lt; len; i++)\n    {\n        output[i * step_out] = input1[i * step1] - input2[i * step2];\n    }\n#endif\n    return TINY_OK;\n}\n\n// vector - constant (add -c) | float\n/**\n * @name tiny_vec_subc_f32\n * @brief Subtracts a constant from each element of a vector.\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param C Constant value to be subtracted.\n * @param step_in Step size for the input vector.\n * @param step_out Step size for the output vector.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function subtracts a constant value from each element of the input vector, with specified step sizes for both input and output vectors.\n */\ntiny_error_t tiny_vec_subc_f32(const float *input, float *output, int len, float C, int step_in, int step_out)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (len &lt;= 0 || step_in &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized vector subtraction\n    dsps_addc_f32(input, output, len, -C, step_in, step_out);\n#else\n    // Fallback to a simple loop for vector subtraction\n    for (int i = 0; i &lt; len; i++)\n    {\n        output[i * step_out] = input[i * step_in] - C;\n    }\n#endif\n    return TINY_OK;\n}\n\n/* MULTIPLICATION */\n\n// vector * vector (elementwise) | float\n/**\n * @name tiny_vec_mul_f32\n * @brief Multiplies two vectors element-wise.\n * @param input1 Pointer to the first input vector.\n * @param input2 Pointer to the second input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param step1 Step size for the first input vector.\n * @param step2 Step size for the second input vector.\n * @param step_out Step size for the output vector.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function performs element-wise multiplication of two vectors with specified step sizes, and the output is also specified with a step size.\n */\ntiny_error_t tiny_vec_mul_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out)\n{\n    if (NULL == input1 || NULL == input2 || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (len &lt;= 0 || step1 &lt;= 0 || step2 &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized vector multiplication\n    dsps_mul_f32(input1, input2, output, len, step1, step2, step_out);\n#else\n    // Fallback to a simple loop for vector multiplication\n    for (int i = 0; i &lt; len; i++)\n    {\n        output[i * step_out] = input1[i * step1] * input2[i * step2];\n    }\n#endif\n        return TINY_OK;\n}\n\n// vector * constant | float\n/**\n * @name tiny_vec_mulc_f32\n * @brief Multiplies each element of a vector by a constant.\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param C Constant value to be multiplied.\n * @param step_in Step size for the input vector.\n * @param step_out Step size for the output vector.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function multiplies each element of the input vector by a constant value, with specified step sizes for both input and output vectors.\n */\ntiny_error_t tiny_vec_mulc_f32(const float *input, float *output, int len, float C, int step_in, int step_out)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (len &lt;= 0 || step_in &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized vector multiplication\n    dsps_mulc_f32(input, output, len, C, step_in, step_out);\n#else\n    // Fallback to a simple loop for vector multiplication\n    for (int i = 0; i &lt; len; i++)\n    {\n        output[i * step_out] = input[i * step_in] * C;\n    }\n#endif\n    return TINY_OK;\n}\n\n/* DIVISION */\n\n// vector / vector (elementwise) | float\n/**\n * @name tiny_vec_div_f32\n * @brief Divides one vector by another element-wise.\n * @param input1 Pointer to the numerator vector.\n * @param input2 Pointer to the denominator vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param step1 Step size for the numerator vector.\n * @param step2 Step size for the denominator vector.\n * @param step_out Step size for the output vector.\n * @param allow_divide_by_zero Whether to safely handle zero denominators (true: set output to 0; false: return error if any zero is found).\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function performs element-wise division with specified step sizes.\n *       If allow_divide_by_zero is false, the function will first scan for zero denominators and return an error immediately if any are found.\n */\ntiny_error_t tiny_vec_div_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out, bool allow_divide_by_zero)\n{\n    if (NULL == input1 || NULL == input2 || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n    if (len &lt;= 0 || step1 &lt;= 0 || step2 &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n    const float epsilon = TINY_MATH_MIN_DENOMINATOR;\n\n    // Step 1: Pre-check for zero denominators if not allowed\n    if (!allow_divide_by_zero)\n    {\n        for (int i = 0; i &lt; len; i++)\n        {\n            if (fabsf(input2[i * step2]) &lt; epsilon)\n            {\n                return TINY_ERR_MATH_ZERO_DIVISION;\n            }\n        }\n    }\n\n    // Step 2: Perform element-wise division\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    for (int i = 0; i &lt; len; i++)\n    {\n        float denom = input2[i * step2];\n        float numer = input1[i * step1];\n        if (fabsf(denom) &lt; epsilon)\n        {\n            output[i * step_out] = allow_divide_by_zero ? 0.0f : numer / denom; // fallback if user forced it\n        }\n        else\n        {\n            output[i * step_out] = numer / denom;\n        }\n    }\n#else\n    for (int i = 0; i &lt; len; i++)\n    {\n        float denom = input2[i * step2];\n        float numer = input1[i * step1];\n        if (fabsf(denom) &lt; epsilon)\n        {\n            output[i * step_out] = allow_divide_by_zero ? 0.0f : numer / denom;\n        }\n        else\n        {\n            output[i * step_out] = numer / denom;\n        }\n    }\n#endif\n\n    return TINY_OK;\n}\n\n// vector / constant | float\n/**\n * @name tiny_vec_divc_f32\n * @brief Divides each element of a vector by a constant using multiplication for performance.\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @param C Constant value to divide by.\n * @param step_in Step size for the input vector.\n * @param step_out Step size for the output vector.\n * @param allow_divide_by_zero Whether to safely handle zero constant (true: set output to 0; false: return error if C is near zero).\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function divides each element of the input vector by a constant using multiplication for performance.\n *       If allow_divide_by_zero is false and C is near zero, the function returns an error.\n *       Otherwise, 1/C is precomputed and used as a multiplier.\n */\ntiny_error_t tiny_vec_divc_f32(const float *input, float *output, int len, float C, int step_in, int step_out, bool allow_divide_by_zero)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n\n    if (len &lt;= 0 || step_in &lt;= 0 || step_out &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n    const float epsilon = TINY_MATH_MIN_DENOMINATOR;\n\n    // Step 1: Handle constant C\n    if (fabsf(C) &lt; epsilon)\n    {\n        if (!allow_divide_by_zero)\n        {\n            return TINY_ERR_MATH_ZERO_DIVISION;\n        }\n\n        // Safe fallback: set all outputs to 0\n        for (int i = 0; i &lt; len; i++)\n        {\n            output[i * step_out] = 0.0f;\n        }\n        return TINY_OK;\n    }\n\n    // Step 2: Use 1/C for performance\n    float invC = 1.0f / C;\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    dsps_mulc_f32(input, output, len, invC, step_in, step_out);\n#else\n    for (int i = 0; i &lt; len; i++)\n    {\n        output[i * step_out] = input[i * step_in] * invC;\n    }\n#endif\n\n    return TINY_OK;\n}\n\n/* SQUARE ROOT */\n\n// vector ^ 0.5 (sqrt-based)| float\n/**\n * @name tiny_vec_sqrt_f32\n * @brief Computes the square root of each element in a vector using standard library sqrtf.\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function provides accurate results using math library sqrtf().\n *       It returns TINY_ERR_MATH_NEGATIVE_SQRT immediately if any element is negative.\n */\ntiny_error_t tiny_vec_sqrt_f32(const float *input, float *output, int len)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n\n    if (len &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n    for (int i = 0; i &lt; len; i++)\n    {\n        float x = input[i];\n        if (x &lt; 0.0f)\n        {\n            return TINY_ERR_MATH_NEGATIVE_SQRT;\n        }\n\n        output[i] = sqrtf(x);  // high-precision sqrt\n    }\n\n    return TINY_OK;\n}\n\n// single value sqrt\n/**\n * @name tiny_sqrtf_f32\n * @brief Computes the square root of a single float value using bit manipulation.\n * @param f Input float value.\n * @return Square root of the input value.\n * @note This function uses bit manipulation to compute the square root of a float value.\n *       It returns 0.0f for negative inputs to prevent sqrt of negative values.\n */\ninline float tiny_sqrtf_f32(float f)\n{\n    if (f &lt; 0.0f) {\n        return 0.0f;  // Prevent sqrt of negative values\n    }\n\n    int result;\n    int *f_ptr = (int *)&amp;f;\n    result = 0x1fbb4000 + (*f_ptr &gt;&gt; 1);\n    const int *p = &amp;result;\n    float *f_result = (float *)p;\n    return *f_result;\n}\n\n// vector ^ 0.5 (sqrtf-based)| float\n/**\n * @name tiny_vec_sqrtf_f32\n * @brief Computes the square root of each element in a vector.\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function computes the square root of each element in the input vector and stores the result in the output vector.\n *       It returns TINY_ERR_MATH_NEGATIVE_SQRT immediately if any element is negative.\n */\ntiny_error_t tiny_vec_sqrtf_f32(const float *input, float *output, int len)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n\n    if (len &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n    for (int i = 0; i &lt; len; i++)\n    {\n        float x = input[i];\n        if (x &lt; 0.0f)\n        {\n            return TINY_ERR_MATH_NEGATIVE_SQRT;\n        }\n\n        output[i] = tiny_sqrtf_f32(x);\n    }\n\n    return TINY_OK;\n}\n\n// vector ^ -0.5 (sqrt-based) | float\n/**\n * @name tiny_vec_inv_sqrt_f32\n * @brief Computes the inverse square root of each element in a vector using standard sqrtf().\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function provides accurate inverse square root results using 1.0f / sqrtf(x).\n *       It returns TINY_ERR_NOT_ALLOWED immediately if any element is less than TINY_MATH_MIN_POSITIVE_INPUT_F32.\n */\ntiny_error_t tiny_vec_inv_sqrt_f32(const float *input, float *output, int len)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n\n    if (len &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n    for (int i = 0; i &lt; len; i++)\n    {\n        float x = input[i];\n        if (x &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32)\n        {\n            return TINY_ERR_NOT_ALLOWED;\n        }\n\n        output[i] = 1.0f / sqrtf(x);  // Accurate inverse square root\n    }\n\n    return TINY_OK;\n}\n\n\n// single value inv sqrt\n/**\n * @name tiny_inverted_sqrtf_f32\n * @brief Computes the inverse square root of a single float value using bit manipulation.\n * @param data Input float value.\n * @return Inverse square root of the input value.\n * @note This function uses bit manipulation to compute the inverse square root of a float value.\n *       It returns 0.0f for negative or near-zero inputs to prevent division by zero.\n */\nfloat tiny_inverted_sqrtf_f32(float data)\n{\n    if (data &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32) {\n        return 0.0f;  // Avoid division by near-zero or zero\n    }\n\n    const float x2 = data * 0.5F;\n    const float threehalfs = 1.5F;\n\n    union {\n        float f;\n        uint32_t i;\n    } conv = {data};\n\n    conv.i  = 0x5f3759df - (conv.i &gt;&gt; 1);\n    conv.f  = conv.f * (threehalfs - (x2 * conv.f * conv.f));\n\n    return conv.f;\n}\n\n// vector ^ -0.5 (sqrtf-based) | float\n/**\n * @name tiny_vec_inv_sqrtf_f32\n * @brief Computes the inverse square root of each element in a vector.\n * @param input Pointer to the input vector.\n * @param output Pointer to the output vector.\n * @param len Length of the vectors.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function computes the inverse square root of each element in the input vector and stores the result in the output vector.\n *       If any element is less than TINY_MATH_MIN_POSITIVE_INPUT_F32, the function returns TINY_ERR_NOT_ALLOWED.\n */\ntiny_error_t tiny_vec_inv_sqrtf_f32(const float *input, float *output, int len)\n{\n    if (NULL == input || NULL == output)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n\n    if (len &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n\n    for (int i = 0; i &lt; len; i++)\n    {\n        float x = input[i];\n        if (x &lt; TINY_MATH_MIN_POSITIVE_INPUT_F32)\n        {\n            return TINY_ERR_NOT_ALLOWED;\n        }\n\n        output[i] = tiny_inverted_sqrtf_f32(x);\n    }\n\n    return TINY_OK;\n}\n\n/* DOT PRODUCT */\n\n// vector * vector (dot product) | float\n/**\n * @name tiny_vec_dotprod_f32\n * @brief Computes the dot product of two vectors.\n * @param src1 Pointer to the first input vector.\n * @param src2 Pointer to the second input vector.\n * @param dest Pointer to the output scalar result.\n * @param len Length of the vectors.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function computes the dot product of two vectors and stores the result in a single float value.\n *       It returns TINY_ERR_MATH_NULL_POINTER if any pointer is NULL.\n *       The function uses the ESP-DSP library for optimized computation.\n */\ntiny_error_t tiny_vec_dotprod_f32(const float *src1, const float *src2, float *dest, int len)\n{\n    if (NULL == src1 || NULL == src2 || NULL == dest)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n\n    if (len &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized dot product\n    dsps_dotprod_f32(src1, src2, dest, len);\n#else\n    // Fallback to a simple loop for dot product\n    float acc = 0.0f;\n    for (int i = 0; i &lt; len; i++)\n    {\n        acc += src1[i] * src2[i];\n    }\n    *dest = acc;\n#endif\n    return TINY_OK;\n}\n\n// vector * vector (dot product - step support) | float\n/**\n * @name tiny_vec_dotprode_f32\n * @brief Computes the dot product of two vectors with step support.\n * @param src1 Pointer to the first input vector.\n * @param src2 Pointer to the second input vector.\n * @param dest Pointer to the output scalar result.\n * @param len Length of the vectors.\n * @param step1 Step size for the first input vector.\n * @param step2 Step size for the second input vector.\n * @return tiny_error_t Error code indicating success or failure.\n * @note This function computes the dot product of two vectors with specified step sizes and stores the result in a single float value.\n */\ntiny_error_t tiny_vec_dotprode_f32(const float *src1, const float *src2, float *dest, int len, int step1, int step2)\n{\n    if (NULL == src1 || NULL == src2 || NULL == dest)\n    {\n        return TINY_ERR_MATH_NULL_POINTER;\n    }\n\n    if (len &lt;= 0 || step1 &lt;= 0 || step2 &lt;= 0)\n    {\n        return TINY_ERR_INVALID_ARG;\n    }\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // Use the ESP-DSP library for optimized dot product with step support\n    dsps_dotprode_f32(src1, src2, dest, len, step1, step2);\n#else\n    // Fallback to a simple loop for dot product with step support\n    float acc = 0.0f;\n    for (int i = 0; i &lt; len; i++)\n    {\n        acc += src1[i * step1] * src2[i * step2];\n    }\n    *dest = acc;\n#endif\n    return TINY_OK;\n}\n</code></pre>"},{"location":"MATH/VECTOR/test/","title":"VECTOR OPERATIONS TEST","text":"<p>Vector Operations Test</p> <p>This test is designed to evaluate the performance of vector-related functions.</p>"},{"location":"MATH/VECTOR/test/#test-code","title":"Test Code","text":""},{"location":"MATH/VECTOR/test/#tiny_vec_testh","title":"tiny_vec_test.h","text":"<pre><code>/**\n * @file tiny_vec_test.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the test header file for the submodule vec of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n */\n\n#ifndef __TINY_VEC_TEST_H__\n#define __TINY_VEC_TEST_H__\n\n#include \"tiny_math_config.h\"\n#include \"tiny_vec.h\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n    /**\n     * @name tiny_vec_test\n     * @brief Run unit tests and timing benchmarks for the tiny_vec module.\n     */\n    void tiny_vec_test(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n/** End of __TINY_VEC_TEST_H__ */\n#endif /* __TINY_VEC_TEST_H__ */\n</code></pre>"},{"location":"MATH/VECTOR/test/#tiny_vec_testc","title":"tiny_vec_test.c","text":"<pre><code>/**\n * @file tiny_vec_test.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file implements test functions for the submodule vec of the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n */\n\n#include \"tiny_vec_test.h\"\n\n#define LEN 6\n\n#define RUN_VEC_TEST(FUNC, ...)                              \\\n    do                                                       \\\n    {                                                        \\\n        TinyTimeMark_t t0 = tiny_get_running_time();         \\\n        tiny_error_t err = FUNC(__VA_ARGS__);                \\\n        TinyTimeMark_t t1 = tiny_get_running_time();         \\\n        double dt = (double)(t1 - t0);                       \\\n        printf(\"%-24s | Output: \", #FUNC);                   \\\n        for (int i = 0; i &lt; LEN; i++)                        \\\n        {                                                    \\\n            printf(\"%10.6f \", out[i]);                       \\\n        }                                                    \\\n        printf(\"| Time: %6.2f us | Error: %d\\n\\r\", dt, err); \\\n    } while (0)\n\nvoid tiny_vec_test(void)\n{\n    float a[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};\n    float b[] = {6.0f, 5.0f, 4.0f, 3.0f, 2.0f, 1.0f};\n    float out[LEN];\n    float C = 2.0f;\n    float dot_result = 0.0f;\n\n    printf(\"============ [tiny_vec_test] ============\\n\\r\");\n\n    printf(\"Input Vector a:        \");\n    for (int i = 0; i &lt; LEN; i++)\n        printf(\"%10.6f \", a[i]);\n    printf(\"\\n\\r\");\n\n    printf(\"Input Vector b:        \");\n    for (int i = 0; i &lt; LEN; i++)\n        printf(\"%10.6f \", b[i]);\n    printf(\"\\n\\r\");\n\n    printf(\"Constant C:            %10.6f\\n\\r\\n\\r\", C);\n\n    RUN_VEC_TEST(tiny_vec_add_f32, a, b, out, LEN, 1, 1, 1);\n    RUN_VEC_TEST(tiny_vec_addc_f32, a, out, LEN, C, 1, 1);\n    RUN_VEC_TEST(tiny_vec_sub_f32, a, b, out, LEN, 1, 1, 1);\n    RUN_VEC_TEST(tiny_vec_subc_f32, a, out, LEN, C, 1, 1);\n    RUN_VEC_TEST(tiny_vec_mul_f32, a, b, out, LEN, 1, 1, 1);\n    RUN_VEC_TEST(tiny_vec_mulc_f32, a, out, LEN, C, 1, 1);\n    RUN_VEC_TEST(tiny_vec_div_f32, a, b, out, LEN, 1, 1, 1, true);\n    RUN_VEC_TEST(tiny_vec_divc_f32, a, out, LEN, C, 1, 1, true);\n    RUN_VEC_TEST(tiny_vec_sqrt_f32, a, out, LEN);\n    RUN_VEC_TEST(tiny_vec_sqrtf_f32, a, out, LEN);\n    RUN_VEC_TEST(tiny_vec_inv_sqrt_f32, a, out, LEN);\n    RUN_VEC_TEST(tiny_vec_inv_sqrtf_f32, a, out, LEN);\n\n    // Dot product (non-strided)\n    {\n        TinyTimeMark_t t0 = tiny_get_running_time();\n        tiny_error_t err = tiny_vec_dotprod_f32(a, b, &amp;dot_result, LEN);\n        TinyTimeMark_t t1 = tiny_get_running_time();\n        double dt = (double)(t1 - t0);\n        printf(\"%-24s | Output: %10.6f | Time: %6.2f us | Error: %d\\n\\r\", \"tiny_vec_dotprod_f32\", dot_result, dt, err);\n    }\n\n    // Dot product (strided)\n    {\n        TinyTimeMark_t t0 = tiny_get_running_time();\n        tiny_error_t err = tiny_vec_dotprode_f32(a, b, &amp;dot_result, LEN, 1, 1);\n        TinyTimeMark_t t1 = tiny_get_running_time();\n        double dt = (double)(t1 - t0);\n        printf(\"%-24s | Output: %10.6f | Time: %6.2f us | Error: %d\\n\\r\", \"tiny_vec_dotprode_f32\", dot_result, dt, err);\n    }\n\n    printf(\"============ [test complete] ============\\n\\r\");\n}\n</code></pre>"},{"location":"MATH/VECTOR/test/#test-output","title":"Test Output","text":""},{"location":"MEASUREMENT/code/","title":"CODE","text":"<p>Warning</p> <p>The following code should be based on the code in the release code, which may have been updated.</p>"},{"location":"MEASUREMENT/code/#cmakeliststxt","title":"CMakeLists.txt","text":"<pre><code>set(src_dirs\n    .\n)\n\nset(include_dirs\n    include\n)\n\nset(requires\n    driver\n    tim\n    esp_rtc\n    spi_sdcard\n    mpu6050\n    exit\n    lcd\n    led\n    wifi\n    esp32_mqtt\n    tiny_toolbox\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"MEASUREMENT/code/#measurementh","title":"measurement.h","text":"<pre><code>/**\n * @file measurement.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the measurement module.\n * @version 1.0\n * @date 2025-04-01\n * @copyright Copyright (c) 2025\n * @note Currently, the sesning is realized by FreeRTOS, and therefore the upper limit sampling rate is 1kHz.\n * @todo Sampling by timer + interrupt\n * @todo Sampling by DMA\n */\n\n#ifndef __MEASUREMENT_H__\n#define __MEASUREMENT_H__\n\n/* DEPENDENCIES */\n// SYSTEM\n#include \"esp_system.h\" // ESP32 System\n#include \"esp_log.h\"    // ESP32 Logging\n\n// RTOS\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/event_groups.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/timers.h\"\n#include \"freertos/semphr.h\"\n\n// BSP\n#include \"driver/gptimer.h\"\n#include \"led.h\"\n#include \"lcd.h\"\n#include \"tim.h\"\n#include \"esp_rtc.h\"\n#include \"spi_sdcard.h\"\n#include \"wifi_wpa2_enterprise.h\"\n#include \"mqtt.h\"\n#include \"mpu6050.h\"\n\n// TinyAuton/TinySHM\n#include \"TinyAdapter.h\"\n\n/* VARIABLES */\nextern struct SenseConfig streamline_config; // Streamline configuration\nextern struct SenseConfig sense_config; // Sense configuration\n\n/* FUNCTIONS */\n/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters);\n\n/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters);\n\n#endif /* __MEASUREMENT_H__ */\n</code></pre>"},{"location":"MEASUREMENT/code/#measurementc","title":"measurement.c","text":"<pre><code>/**\n * @file measurement.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the source file for the measurement module.\n * @version 1.0\n * @date 2025-04-01\n * @copyright Copyright (c) 2025\n * @note Currently, the sesning is realized by FreeRTOS, and therefore the upper limit sampling rate is 1kHz.\n * @todo Sampling by timer + interrupt\n * @todo Sampling by DMA\n */\n\n/* DEPENDENCIES */\n#include \"measurement.h\"\n\n/* VARIABLES */\nstatic const char *TAG = \"TinySHM-Measurement\"; // Tag for logging\n\n// static uint8_t mpu6050_deviceid;    // MPU6050 Device ID\nstatic mpu6050_acce_value_t acce; // MPU6050 Accelerometer Value\n// static mpu6050_gyro_value_t gyro;   // MPU6050 Gyroscope Value\nstatic mpu6050_temp_value_t temp; // MPU6050 Temperature Value\n// static complimentary_angle_t angle; // Complimentary Angle\n\n/* DEFINITION */\nstruct SenseConfig\n{\n    int sample_rate;\n    int sample_duration;\n    bool temperature_sense; // whether to sense temperature\n    bool printout;          // not recommened for high sample rate as it will slow down the process\n    bool mqtt_pub;          // not recommened for high sample rate as it will slow down the process\n};\n\nstruct DataStruct\n{\n    int sample_rate;\n    int sample_duration;\n    float sensor_temperature;\n    TinyTimeMark_t start_time_stamp;\n    TinyTimeMark_t *time_stamp;\n    float *acc_data;\n    float *temperature;\n};\n\n/* VARIABLES */\n// for streamline configuration\nstruct SenseConfig streamline_config = {\n    .sample_rate = 1,          // Sample rate in Hz. For local printout + mqtt, at most 25Hz; for only mqtt, at most 200Hz.\n    .temperature_sense = true, // Whether to sense temperature\n    .printout = true,          // Only available for sampling rate &lt;= 100Hz\n    .mqtt_pub = true           // Only available for sampling rate &lt;= 100Hz\n};\n\n// for sensing configuration\nstruct SenseConfig sense_config = {\n    .sample_rate = 500,   // Sample rate in Hz, only can be (1, 2, 5, 10, 20, 25, 50, 100, 200, 500) for FreeRTOS based sensing. Note can not be 1000Hz (no time to feed the watchdog).\n    .sample_duration = 1, // Sample duration in seconds\n    .printout = true      // Only available for sampling rate &lt;= 100Hz\n};\n\n// for data structure\nstruct DataStruct data_struct = {\n    .sample_rate = 0,     // Sample rate in Hz\n    .sample_duration = 0, // Sample duration in seconds\n    .sensor_temperature = 0.0,\n    .start_time_stamp = 0,\n    .acc_data = NULL};\n\n/* FUNCTION PROTOTYPES */\n/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters)\n{\n\n    // streamline variables\n    float acc_x, acc_y, acc_z, temperature;\n    TinyTimeMark_t time_stamp;\n\n    // MQTT publish buffer\n    char streamline_buff[256];\n\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n\n    if (config-&gt;sample_rate &gt; 100 &amp;&amp; config-&gt;printout)\n    {\n        ESP_LOGW(TAG, \"Printout is disabled for sample rate &gt; 100Hz.\");\n        config-&gt;printout = false;\n    }\n\n    while (1)\n    {\n        // get the time stamp\n        time_stamp = tiny_get_running_time();\n\n        // get accelerometer data\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        acc_x = acce.acce_x;\n        acc_y = acce.acce_y;\n        acc_z = acce.acce_z;\n\n        // get temperature\n        mpu6050_get_temp(mpu6050, &amp;temp);\n        temperature = temp.temp;\n\n        // sprintf\n        if (config-&gt;printout || config-&gt;mqtt_pub)\n        {\n            snprintf(streamline_buff, sizeof(streamline_buff), \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Sensor Temperature: %4.2f \u00b0C\", time_stamp, acc_x, acc_y, acc_z, temperature);\n        }\n\n        // print out the data - comment out for higher sample rate\n        if (config-&gt;printout)\n        {\n            ESP_LOGI(TAG, \"%s\", streamline_buff);\n        }\n\n        // MQTT publish\n        if (config-&gt;mqtt_pub)\n        {\n            esp_mqtt_client_publish(s_mqtt_client, MQTT_PUBLIC_TOPIC, streamline_buff, strlen(streamline_buff), 0, 0); // for streamline, data quality is not expected to be high, so QoS = 0; data retaintion is also not required, so 0.\n        }\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n    ESP_LOGI(TAG, \"Streamline terminated. Task will delete itself.\");\n    vTaskDelete(NULL);\n}\n\n/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters)\n{\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n    int total_samples = config-&gt;sample_rate * config-&gt;sample_duration;\n\n    // Fill global data_struct\n    data_struct.sample_rate = config-&gt;sample_rate;\n    data_struct.sample_duration = config-&gt;sample_duration;\n    mpu6050_get_temp(mpu6050, &amp;temp);\n    data_struct.sensor_temperature = temp.temp;\n    data_struct.start_time_stamp = tiny_get_running_time();\n\n    // Allocate memory\n    data_struct.acc_data = malloc(sizeof(float) * 3 * total_samples);\n    data_struct.temperature = malloc(sizeof(float) * total_samples);\n    data_struct.time_stamp = malloc(sizeof(TinyTimeMark_t) * total_samples);\n\n    if (data_struct.acc_data == NULL || data_struct.temperature == NULL || data_struct.time_stamp == NULL)\n    {\n        ESP_LOGE(TAG, \"Failed to allocate memory for sensing data.\");\n        if (data_struct.acc_data)\n            free(data_struct.acc_data);\n        if (data_struct.temperature)\n            free(data_struct.temperature);\n        if (data_struct.time_stamp)\n            free(data_struct.time_stamp);\n        vTaskDelete(NULL);\n    }\n\n    ESP_LOGI(TAG, \"Sampling started: %d Hz for %d seconds (%d samples)\",\n             config-&gt;sample_rate, config-&gt;sample_duration, total_samples);\n\n    for (int i = 0; i &lt; total_samples; i++)\n    {\n        TinyTimeMark_t now = tiny_get_running_time();\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        mpu6050_get_temp(mpu6050, &amp;temp);\n\n        // Store data\n        data_struct.time_stamp[i] = now;\n        data_struct.acc_data[i * 3 + 0] = acce.acce_x;\n        data_struct.acc_data[i * 3 + 1] = acce.acce_y;\n        data_struct.acc_data[i * 3 + 2] = acce.acce_z;\n        data_struct.temperature[i] = temp.temp;\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n\n    ESP_LOGI(TAG, \"Sampling complete.\");\n\n    // Print metadata\n    ESP_LOGI(TAG, \"-----------------------------\");\n    ESP_LOGI(TAG, \"Sensor Temperature : %.2f \u00b0C\", data_struct.sensor_temperature);\n    ESP_LOGI(TAG, \"Start Time Stamp   : %ld\", (long)data_struct.start_time_stamp);\n    ESP_LOGI(TAG, \"Sample Rate        : %d Hz\", data_struct.sample_rate);\n    ESP_LOGI(TAG, \"Sample Duration    : %d sec\", data_struct.sample_duration);\n    ESP_LOGI(TAG, \"Total Samples      : %d\", total_samples);\n    ESP_LOGI(TAG, \"Data Size          : %.2f KB\",\n             (sizeof(float) * 4 + sizeof(TinyTimeMark_t)) * total_samples / 1024.0f);\n    ESP_LOGI(TAG, \"-----------------------------\");\n\n    // Print collected data if enabled\n    if (config-&gt;printout)\n    {\n        for (int i = 0; i &lt; total_samples; i++)\n        {\n            ESP_LOGI(TAG, \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Temperature: %.2f \u00b0C\",\n                     (long)data_struct.time_stamp[i],\n                     data_struct.acc_data[i * 3 + 0],\n                     data_struct.acc_data[i * 3 + 1],\n                     data_struct.acc_data[i * 3 + 2],\n                     data_struct.temperature[i]);\n\n            // Release CPU for a short time to avoid blocking\n            if ((i % 10) == 0)\n            {\n                vTaskDelay(pdMS_TO_TICKS(10));\n            }\n        }\n    }\n\n    // Free allocated memory\n    if (data_struct.acc_data)\n    {\n        free(data_struct.acc_data);\n        data_struct.acc_data = NULL;\n    }\n    if (data_struct.temperature)\n    {\n        free(data_struct.temperature);\n        data_struct.temperature = NULL;\n    }\n    if (data_struct.time_stamp)\n    {\n        free(data_struct.time_stamp);\n        data_struct.time_stamp = NULL;\n    }\n\n    vTaskDelete(NULL);\n}\n</code></pre>"},{"location":"MEASUREMENT/log/","title":"DEV LOG","text":"<p>2025-04-03</p> <ul> <li>Sampling configuration structure</li> <li>Sampling data structure</li> <li>Real-time sampling function / regular sampling function</li> <li>Sampling frequency upper limit test: real-time (25Hz-local output + MQTT; 200Hz-only MQTT); regular (500Hz)</li> <li>Server-side visualization program</li> <li>Server-side data storage</li> </ul>"},{"location":"MEASUREMENT/measurement/","title":"MEASUREMENT","text":"<p>Measurement</p> <p>High quality measurement/sampling is the basis of data analysis, and TinySHM fully considers this in its design. We have implemented a variety of measurement/sampling methods in TinySHM, and users can choose according to their needs.</p> <p>Warning</p> <p>Currently, development is based on ESP32, and migration to platforms like STM32 will require some modifications to the adaptation layer.</p>"},{"location":"MEASUREMENT/notes/","title":"NOTES","text":""},{"location":"MEASUREMENT/notes/#dependencies","title":"DEPENDENCIES","text":"<p>SYSTEM</p> <pre><code>#include \"esp_system.h\" // ESP32 System\n#include \"esp_log.h\"    // ESP32 Logging\n</code></pre> <p>RTOS</p> <pre><code>#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/event_groups.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/timers.h\"\n#include \"freertos/semphr.h\"\n</code></pre> <p>BSP</p> <pre><code>#include \"driver/gptimer.h\"\n#include \"led.h\"\n#include \"lcd.h\"\n#include \"tim.h\"\n#include \"esp_rtc.h\"\n#include \"spi_sdcard.h\"\n#include \"wifi_wpa2_enterprise.h\"\n#include \"mqtt.h\"\n#include \"mpu6050.h\"\n</code></pre> <p>TinyAuton/TinySHM</p> <pre><code>#include \"TinyAdapter.h\"\n</code></pre>"},{"location":"MEASUREMENT/notes/#sampling-configuration-struct","title":"SAMPLING CONFIGURATION STRUCT","text":"<p>Definition</p> <pre><code>struct SenseConfig\n{\n    int sample_rate;\n    int sample_duration;\n    bool temperature_sense; // whether to sense temperature\n    bool printout;          // not recommened for high sample rate as it will slow down the process\n    bool mqtt_pub;          // not recommened for high sample rate as it will slow down the process\n};\n</code></pre> <p>Usage - Streamline</p> <pre><code>// for streamline configuration\nstruct SenseConfig streamline_config = {\n    .sample_rate = 1,          // Sample rate in Hz. For local printout + mqtt, at most 25Hz; for only mqtt, at most 200Hz.\n    .temperature_sense = true, // Whether to sense temperature\n    .printout = true,          // Only available for sampling rate &lt;= 100Hz\n    .mqtt_pub = true           // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre> <p>Usage - Normal</p> <pre><code>// for sensing configuration\nstruct SenseConfig sense_config = {\n    .sample_rate = 500,   // Sample rate in Hz, only can be (1, 2, 5, 10, 20, 25, 50, 100, 200, 500) for FreeRTOS based sensing. Note can not be 1000Hz (no time to feed the watchdog).\n    .sample_duration = 1, // Sample duration in seconds\n    .printout = true      // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre>"},{"location":"MEASUREMENT/notes/#sampling-data-struct","title":"SAMPLING DATA STRUCT","text":"<pre><code>struct DataStruct\n{\n    int sample_rate;\n    int sample_duration;\n    float sensor_temperature;\n    TinyTimeMark_t start_time_stamp;\n    TinyTimeMark_t *time_stamp;\n    float *acc_data;\n    float *temperature;\n};\n</code></pre> <p>usage</p> <pre><code>// for data structure\nstruct DataStruct data_struct = {\n    .sample_rate = 0,     // Sample rate in Hz\n    .sample_duration = 0, // Sample duration in seconds\n    .sensor_temperature = 0.0,\n    .start_time_stamp = 0,\n    .acc_data = NULL}; \n</code></pre>"},{"location":"MEASUREMENT/notes/#sampling-principle","title":"SAMPLING PRINCIPLE","text":"<ul> <li>FreeRTOS based sampling</li> <li>Timer &amp; Interrupt based sampling (to be developed)</li> </ul>"},{"location":"MEASUREMENT/notes/#sampling-modes-and-tasks","title":"SAMPLING MODES AND TASKS","text":"<p>Currently, there are two sampling modes: - Streamline mode - Normal mode</p>"},{"location":"MEASUREMENT/notes/#streamline-sampling","title":"Streamline Sampling","text":"<p>Definition</p> <pre><code>/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters)\n{\n\n    // streamline variables\n    float acc_x, acc_y, acc_z, temperature;\n    TinyTimeMark_t time_stamp;\n\n    // MQTT publish buffer\n    char streamline_buff[256];\n\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n\n    if (config-&gt;sample_rate &gt; 100 &amp;&amp; config-&gt;printout)\n    {\n        ESP_LOGW(TAG, \"Printout is disabled for sample rate &gt; 100Hz.\");\n        config-&gt;printout = false;\n    }\n\n    while (1)\n    {\n        // get the time stamp\n        time_stamp = tiny_get_running_time();\n\n        // get accelerometer data\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        acc_x = acce.acce_x;\n        acc_y = acce.acce_y;\n        acc_z = acce.acce_z;\n\n        // get temperature\n        mpu6050_get_temp(mpu6050, &amp;temp);\n        temperature = temp.temp;\n\n        // sprintf\n        if (config-&gt;printout || config-&gt;mqtt_pub)\n        {\n            snprintf(streamline_buff, sizeof(streamline_buff), \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Sensor Temperature: %4.2f \u00b0C\", time_stamp, acc_x, acc_y, acc_z, temperature);\n        }\n\n        // print out the data - comment out for higher sample rate\n        if (config-&gt;printout)\n        {\n            ESP_LOGI(TAG, \"%s\", streamline_buff);\n        }\n\n        // MQTT publish\n        if (config-&gt;mqtt_pub)\n        {\n            esp_mqtt_client_publish(s_mqtt_client, MQTT_PUBLIC_TOPIC, streamline_buff, strlen(streamline_buff), 0, 0); // for streamline, data quality is not expected to be high, so QoS = 0; data retaintion is also not required, so 0.\n        }\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n    ESP_LOGI(TAG, \"Streamline terminated. Task will delete itself.\");\n    vTaskDelete(NULL);\n}\n</code></pre> <p>Usage</p> <pre><code>xTaskCreate(acc_streamline_task, \"Accel_Streamline_Task\", 4096, &amp;streamline_config, 5, NULL);\n</code></pre>"},{"location":"MEASUREMENT/notes/#normal-sampling","title":"Normal Sampling","text":"<p>Definition</p> <pre><code>/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters)\n{\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n    int total_samples = config-&gt;sample_rate * config-&gt;sample_duration;\n\n    // Fill global data_struct\n    data_struct.sample_rate = config-&gt;sample_rate;\n    data_struct.sample_duration = config-&gt;sample_duration;\n    mpu6050_get_temp(mpu6050, &amp;temp);\n    data_struct.sensor_temperature = temp.temp;\n    data_struct.start_time_stamp = tiny_get_running_time();\n\n    // Allocate memory\n    data_struct.acc_data = malloc(sizeof(float) * 3 * total_samples);\n    data_struct.temperature = malloc(sizeof(float) * total_samples);\n    data_struct.time_stamp = malloc(sizeof(TinyTimeMark_t) * total_samples);\n\n    if (data_struct.acc_data == NULL || data_struct.temperature == NULL || data_struct.time_stamp == NULL)\n    {\n        ESP_LOGE(TAG, \"Failed to allocate memory for sensing data.\");\n        if (data_struct.acc_data)\n            free(data_struct.acc_data);\n        if (data_struct.temperature)\n            free(data_struct.temperature);\n        if (data_struct.time_stamp)\n            free(data_struct.time_stamp);\n        vTaskDelete(NULL);\n    }\n\n    ESP_LOGI(TAG, \"Sampling started: %d Hz for %d seconds (%d samples)\",\n             config-&gt;sample_rate, config-&gt;sample_duration, total_samples);\n\n    for (int i = 0; i &lt; total_samples; i++)\n    {\n        TinyTimeMark_t now = tiny_get_running_time();\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        mpu6050_get_temp(mpu6050, &amp;temp);\n\n        // Store data\n        data_struct.time_stamp[i] = now;\n        data_struct.acc_data[i * 3 + 0] = acce.acce_x;\n        data_struct.acc_data[i * 3 + 1] = acce.acce_y;\n        data_struct.acc_data[i * 3 + 2] = acce.acce_z;\n        data_struct.temperature[i] = temp.temp;\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n\n    ESP_LOGI(TAG, \"Sampling complete.\");\n\n    // Print metadata\n    ESP_LOGI(TAG, \"-----------------------------\");\n    ESP_LOGI(TAG, \"Sensor Temperature : %.2f \u00b0C\", data_struct.sensor_temperature);\n    ESP_LOGI(TAG, \"Start Time Stamp   : %ld\", (long)data_struct.start_time_stamp);\n    ESP_LOGI(TAG, \"Sample Rate        : %d Hz\", data_struct.sample_rate);\n    ESP_LOGI(TAG, \"Sample Duration    : %d sec\", data_struct.sample_duration);\n    ESP_LOGI(TAG, \"Total Samples      : %d\", total_samples);\n    ESP_LOGI(TAG, \"Data Size          : %.2f KB\",\n             (sizeof(float) * 4 + sizeof(TinyTimeMark_t)) * total_samples / 1024.0f);\n    ESP_LOGI(TAG, \"-----------------------------\");\n\n    // Print collected data if enabled\n    if (config-&gt;printout)\n    {\n        for (int i = 0; i &lt; total_samples; i++)\n        {\n            ESP_LOGI(TAG, \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Temperature: %.2f \u00b0C\",\n                     (long)data_struct.time_stamp[i],\n                     data_struct.acc_data[i * 3 + 0],\n                     data_struct.acc_data[i * 3 + 1],\n                     data_struct.acc_data[i * 3 + 2],\n                     data_struct.temperature[i]);\n\n            // Release CPU for a short time to avoid blocking\n            if ((i % 10) == 0)\n            {\n                vTaskDelay(pdMS_TO_TICKS(10));\n            }\n        }\n    }\n\n    // Free allocated memory\n    if (data_struct.acc_data)\n    {\n        free(data_struct.acc_data);\n        data_struct.acc_data = NULL;\n    }\n    if (data_struct.temperature)\n    {\n        free(data_struct.temperature);\n        data_struct.temperature = NULL;\n    }\n    if (data_struct.time_stamp)\n    {\n        free(data_struct.time_stamp);\n        data_struct.time_stamp = NULL;\n    }\n\n    vTaskDelete(NULL);\n}\n</code></pre> <p>Usage</p> <pre><code>xTaskCreate(acc_sense_task, \"Accel_Sense_Task\", 8192, &amp;sense_config, 5, NULL);\n</code></pre>"},{"location":"MEASUREMENT/notes/#to-be-developed","title":"TO BE DEVELOPED","text":"<ul> <li>Standard time stamp</li> <li>Calibration</li> <li>Timer &amp; Interrupt based sampling</li> <li>DMA</li> <li>ADC + Analog Sensor</li> <li>Data post-processing</li> <li>Batch data MQTT upload</li> <li>Real-time processing function development</li> </ul>"},{"location":"RELEASES/releases/","title":"RELEASES","text":""},{"location":"RELEASES/releases/#dnesp32s3m-stable","title":"DNESP32S3M-STABLE","text":"<p>Stable version</p>"},{"location":"RELEASES/releases/#dnesp32s3m-latest","title":"DNESP32S3M-LATEST","text":"<p>Latest feature version</p>"},{"location":"TOOLBOX/toolbox/","title":"TOOLBOX","text":"<p>tiny_toolbox</p> <p>tiny_toolbox is a library designed for platform adaptation and optimization, providing various practical tools to serve edge computing and application development. Note that the adaptation and tools are included in the same library because many tools utilize the functions provided by the platform at a lower level. Therefore, placing platform adaptation and various tools together facilitates usage and maintenance.</p> <p>Warning</p> <p>Currently, development is based on ESP32, and migration to platforms like STM32 requires some modifications to the adaptation layer.</p>"},{"location":"TOOLBOX/toolbox/#component-dependencies","title":"COMPONENT DEPENDENCIES","text":"<pre><code>set(src_dirs\n    .\n    time\n)\n\nset(include_dirs\n    .\n    time\n)\n\nset(requires\n    esp_timer\n    esp_rtc\n    espressif__esp-dsp\n    espressif__esp_jpeg\n    espressif__esp-dl\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"TOOLBOX/toolbox/#architecture-and-function-directory","title":"ARCHITECTURE AND FUNCTION DIRECTORY","text":"<pre><code>    tiny_toolbox\n    \u251c\u2500\u2500 CMakeLists.txt\n    \u251c\u2500\u2500 tiny_toolbox.h // serves as a directory, integrating all submodules\n    \u251c\u2500\u2500 time\n    \u2502   \u251c\u2500\u2500 tiny_time.h // submodule for time management - header file\n    \u2502   \u251c\u2500\u2500 tiny_time.c // submodule for time management - source file\n    \u2502   \u2514\u2500\u2500 ...\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"TOOLBOX/toolbox/#time","title":"TIME","text":"<ul> <li>Get Running Time: <code>tiny_get_running_time()</code></li> <li>SNTP Time Synchronization: <code>sync_time_with_timezone(\"CST-8\")</code></li> <li>Get World Time: <code>tiny_get_current_time(1)</code></li> </ul> <p>TODO:</p> <ul> <li>Local Time Synchronization for Wireless Sensor Networks - Microsecond Level</li> </ul>"},{"location":"TOOLBOX/toolbox/#code","title":"CODE","text":"<p>Tip</p> <p>tiny_toolbox.h serves merely as a directory, integrating all submodules. The specific functionalities are implemented in each submodule. tiny_toolbox.c is just a formal source file without specific functionality.</p>"},{"location":"TOOLBOX/toolbox/#cmakeliststxt","title":"CMakeLists.txt","text":"<pre><code>set(src_dirs\n    .\n)\n\nset(include_dirs\n    include\n)\n\nset(requires\n    esp_timer\n    espressif__esp-dsp\n    espressif__esp_jpeg\n    espressif__esp-dl\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"TOOLBOX/toolbox/#tiny_toolboxh","title":"tiny_toolbox.h","text":"<pre><code>/**\n * @file tiny_toolbox.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the tiny_toolbox middleware.\n * @version 1.0\n * @date 2025-03-26\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_TOOLBOX__\n#define __TINY_TOOLBOX__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* DEPENDENCIES */\n// system\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n#include \"esp_timer.h\"\n#include \"esp_heap_caps.h\"\n\n// customized drivers\n#include \"esp_rtc.h\"\n\n/* SUBMODULES */\n#include \"tiny_time.h\" // Time\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_TOOLBOX__ */\n</code></pre>"},{"location":"TOOLBOX/TIME/code/","title":"TIME","text":""},{"location":"TOOLBOX/TIME/code/#tiny_timeh","title":"tiny_time.h","text":"<pre><code>/**\n * @file tiny_time.h    \n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief Submodule for TinyToolbox - header file\n * @version 1.0\n * @date 2025-04-10\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_TIME__\n#define __TINY_TIME__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* CONFIGURATIONS */\n\n/* ================================ DEPENDENCIES ================================ */\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n#include &lt;sys/time.h&gt;\n#include \"esp_log.h\"\n#include \"esp_timer.h\"\n#include \"esp_sntp.h\"\n// customized drivers\n#include \"esp_rtc.h\"\n\n/* ================================ DEFINITIONS ================================= */\ntypedef TickType_t TinyTimeMark_t;\n\n/**\n * @brief Structure to hold date and time\n */\ntypedef struct TinyDateTime_t\n{\n    int year;\n    int month;\n    int day;\n    int hour;\n    int minute;\n    int second;\n    long microsecond;\n} TinyDateTime_t;\n\n/* ================================ FUNCTIONS =================================== */\n/* LOCAL RUNNING TIME IN MICROSECONDS */\n/**\n * @brief Get the running time in microseconds\n * @return TinyTimeMark_t\n */\nTinyTimeMark_t tiny_get_running_time(void);\n\n/* WORLD CURRENT TIME - SNTP */\n/**\n * @brief Obtain the current time with timezone\n * @param timezone_str Timezone string (e.g., \"CST-8\")\n * @note The timezone string should be in the format \"TZ=GMT+/-HH:MM\"\n * @note To use this function, in application, insert \"sync_time_with_timezone(\"CST-8\");\" will do\n * @return None\n */\nvoid sync_time_with_timezone(const char *timezone_str);\n\n/* WORLD CURRENT TIME - GET TIME */\n/**\n * @name tiny_get_current_time\n * @brief Get the current time as a TinyDateTime_t struct\n * @param print_flag Flag to indicate whether to print the time\n * @return TinyDateTime_t structure containing the current date and time\n */\nTinyDateTime_t tiny_get_current_time(bool print_flag);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_TIME__ */\n</code></pre>"},{"location":"TOOLBOX/TIME/code/#tiny_timec","title":"tiny_time.c","text":"<pre><code>/**\n * @file tiny_time.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief Submodule for TinyToolbox - source file\n * @version 1.0\n * @date 2025-04-10\n * @copyright Copyright (c) 2025\n *\n */\n\n/* ================================ DEPENDENCIES ================================ */\n#include \"tiny_time.h\" // Time\n\n/* ================================ DEFINITIONS ================================= */\n/* CONFIGURATIONS */\n\n/* TAGS */\nstatic const char *TAG_SNTP = \"NTP_SYNC\";\nstatic const char *TAG_TIME = \"TIME\";\n\n/* ================================ FUNCTIONS =================================== */\n/* LOCAL RUNNING TIME IN MICROSECONDS */\n/**\n * @brief Get the running time in microseconds\n * @return TinyTimeMark_t\n */\nTinyTimeMark_t tiny_get_running_time(void)\n{\n    return esp_timer_get_time();\n}\n\n/* WORLD CURRENT TIME - SNTP */\n/**\n * @brief Callback function for time synchronization notification\n * @param tv Pointer to the timeval structure containing the synchronized time\n * @return None\n */\nvoid time_sync_notification_cb(struct timeval *tv)\n{\n    ESP_LOGI(TAG_SNTP, \"Time synchronized!\");\n}\n\n/**\n * @brief Initialize SNTP\n * @return None\n */\nvoid initialize_sntp(void)\n{\n    ESP_LOGI(TAG_SNTP, \"Initializing SNTP\");\n    sntp_setoperatingmode(SNTP_OPMODE_POLL);\n    sntp_setservername(0, \"pool.ntp.org\"); // NTP server // pool.ntp.org // ntp.aliyun.com\n    sntp_set_time_sync_notification_cb(time_sync_notification_cb);\n    sntp_init();\n}\n\n/**\n * @brief Obtain the current time with timezone\n * @param timezone_str Timezone string (e.g., \"CST-8\")\n * @note The timezone string should be in the format \"TZ=GMT+/-HH:MM\"\n * @note To use this function, in application, after internet connection, insert \"sync_time_with_timezone(\"CST-8\");\" will do\n * @return None\n */\nvoid sync_time_with_timezone(const char *timezone_str)\n{\n    // Set system timezone\n    setenv(\"TZ\", timezone_str, 1);\n    tzset();\n\n    // Initialize SNTP and start time sync\n    initialize_sntp();\n\n    // Wait for system time to be set\n    time_t now = 0;\n    struct tm timeinfo = { 0 };\n    int retry = 0;\n    const int retry_count = 15;\n\n    while (timeinfo.tm_year &lt; (2020 - 1900) &amp;&amp; ++retry &lt; retry_count) {\n        ESP_LOGI(TAG_SNTP, \"Waiting for system time to be set... (%d/%d)\", retry, retry_count);\n        vTaskDelay(2000 / portTICK_PERIOD_MS);\n        time(&amp;now);\n        localtime_r(&amp;now, &amp;timeinfo);\n    }\n\n    if (timeinfo.tm_year &gt;= (2020 - 1900)) {\n        rtc_set_time(timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday,\n                    timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec); // defined in esp_rtc.c\n        ESP_LOGI(TAG_SNTP, \"System time is set.\");\n    } else {\n        ESP_LOGW(TAG_SNTP, \"Failed to sync time.\");\n        return;\n    }\n\n    // Log current local time\n    ESP_LOGI(TAG_SNTP, \"Current time: %s\", asctime(&amp;timeinfo));\n\n    // vTaskDelay(10000 / portTICK_PERIOD_MS); // Wait for 10 second\n    // rtc_get_time(); // uncomment to check the RTC time\n    // ESP_LOGI(TAG_SNTP, \"Current RTC time: %04d-%02d-%02d %02d:%02d:%02d\",\n    //          calendar.year, calendar.month, calendar.date,\n    //          calendar.hour, calendar.min, calendar.sec); // uncomment to check the RTC time\n\n}\n\n/* WORLD CURRENT TIME - GET TIME */\n/**\n * @name tiny_get_current_time\n * @brief Get the current time as a TinyDateTime_t struct\n * @param print_flag Flag to indicate whether to print the time\n * @return TinyDateTime_t structure containing the current date and time\n */\nTinyDateTime_t tiny_get_current_time(bool print_flag)\n{\n    struct timeval tv;\n    gettimeofday(&amp;tv, NULL);  // Get current time (seconds + microseconds)\n\n    time_t now = tv.tv_sec;\n    struct tm timeinfo;\n    localtime_r(&amp;now, &amp;timeinfo);  // Convert to local time\n\n    TinyDateTime_t result;\n    result.year   = timeinfo.tm_year + 1900;\n    result.month  = timeinfo.tm_mon + 1;\n    result.day    = timeinfo.tm_mday;\n    result.hour   = timeinfo.tm_hour;\n    result.minute = timeinfo.tm_min;\n    result.second = timeinfo.tm_sec;\n    result.microsecond = tv.tv_usec;\n\n    if (print_flag)\n    {\n        ESP_LOGI(TAG_TIME, \"Current Time: %04d-%02d-%02d %02d:%02d:%02d.%06ld\",\n                 result.year, result.month, result.day,\n                 result.hour, result.minute, result.second, tv.tv_usec);\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"TOOLBOX/TIME/log/","title":"LOG","text":"<p>2025-04-10</p> <ul> <li>Get Running Time: <code>tiny_get_running_time()</code></li> <li>SNTP Time Synchronization: <code>sync_time_with_timezone(\"CST-8\")</code></li> <li>Get World Time: <code>tiny_get_current_time(1)</code></li> </ul> <p>TODO:</p> <ul> <li>Local Time Synchronization for Wireless Sensor Networks - Microsecond Level</li> </ul>"},{"location":"TOOLBOX/TIME/notes/","title":"TIME","text":"<p>Time</p> <p>Time related functions are of vital importance for MCU devices. This section provides a series of time related definitions and functions for developers to use.</p> <p>In MCU, time can be divided into the following types:</p> <ul> <li> <p>Running Time: The time from the power-on of the MCU to now.</p> </li> <li> <p>World Time: The time of the time zone where the MCU is located. World time can be represented by standard year, month, day, hour, minute, and second, or it can be represented as a UNIX timestamp.</p> </li> </ul>"},{"location":"TOOLBOX/TIME/notes/#running-time","title":"RUNNING TIME","text":"<p>ESP has its own function to get the running time, <code>esp_timer_get_time</code>, which depends on the <code>esp_timer</code> library. This function returns the time from power-on to now, in microseconds.</p> <p>To facilitate usage, TinyToolbox redefines the data type <code>TinyTimeMark_t</code> and provides a function <code>tiny_get_running_time</code> to get the running time. The time returned by this function is in the unit of TickType_t, which is the time unit defined in FreeRTOS.</p> <pre><code>typedef TickType_t TinyTimeMark_t;\n</code></pre> <pre><code>/**\n * @brief Get the running time in microseconds\n * @return TinyTimeMark_t\n */\nTinyTimeMark_t tiny_get_running_time(void)\n{\n    return esp_timer_get_time();\n}\n</code></pre> <p>Usage reference:</p> <pre><code>void app_main(void)\n{\n    // Get running time\n    TinyTimeMark_t running_time = tiny_get_running_time();\n    ESP_LOGI(TAG_TIME, \"Running Time: %lld us\", running_time);\n}\n</code></pre>"},{"location":"TOOLBOX/TIME/notes/#world-time","title":"WORLD TIME","text":"<p>Warning</p> <p>Note that obtaining world time requires a successful network connection. In other words, the function to obtain world time needs to be called after the network connection is successfully established.</p>"},{"location":"TOOLBOX/TIME/notes/#ntp-time-synchronization","title":"NTP TIME SYNCHRONIZATION","text":"<p>NTP Time Synchronization</p> <p>NTP (Network Time Protocol) is a protocol used to synchronize time in computer networks. It can obtain accurate time information through the Internet or local area network. NTP protocol uses UDP for communication, with the default port being 123. NTP servers periodically send time information to clients, and clients adjust their system time based on this information.</p> <pre><code>    Client                      Server\n      |-------------------&gt;      |     T1\uff1aRequest sent\n      |                          |\n      |         &lt;--------------- |     T2/T3\uff1aServer received &amp; replied\n      |                          |\n      |-------------------&gt;      |     T4\uff1aClient received response\n</code></pre> <p>NTP Time Synchronization Principle</p> <p>NTP time synchronization is based on four timestamps: 1. Timestamp T1 when the client sends the request 2. Timestamp T2 when the server receives the request 3. Timestamp T3 when the server sends the response 4. Timestamp T4 when the client receives the response. Based on these four timestamps, we can calculate Network Delay Delay = (T4 - T1) - (T3 - T2), and Time Offset Offset = ((T2 - T1) + (T3 - T4)) / 2.</p> <p>ESP32 SNTP Time Synchronization</p> <p>In ESP32, SNTP (Simple Network Time Protocol) is used. SNTP is a simplified version of NTP, suitable for scenarios where time accuracy is not critical. The time synchronization in ESP32 relies on the <code>esp_sntp</code> library. The working principle of SNTP is similar to that of NTP, but the implementation of SNTP is relatively simple, making it suitable for embedded devices. Its accuracy is usually at the millisecond level, which is sufficient for most application scenarios.</p> <p>First, define a callback function to receive time synchronization notifications:</p> <p><pre><code>/* WORLD CURRENT TIME - SNTP */\n/**\n * @brief Callback function for time synchronization notification\n * @param tv Pointer to the timeval structure containing the synchronized time\n * @return None\n */\nvoid time_sync_notification_cb(struct timeval *tv)\n{\n    ESP_LOGI(TAG_SNTP, \"Time synchronized!\");\n}\n</code></pre> Next is the SNTP initialization function, which is also the core function of time synchronization. It is usually called when the system is initialized and the network is connected. Note that the time synchronization server address can be modified as needed. After the time synchronization is completed, ESP32 will set the local time at the bottom layer.</p> <pre><code>/**\n * @brief Initialize SNTP\n * @return None\n */\nvoid initialize_sntp(void)\n{\n    ESP_LOGI(TAG_SNTP, \"Initializing SNTP\");\n    sntp_setoperatingmode(SNTP_OPMODE_POLL);\n    sntp_setservername(0, \"pool.ntp.org\"); // NTP server // pool.ntp.org // ntp.aliyun.com\n    sntp_set_time_sync_notification_cb(time_sync_notification_cb);\n    sntp_init();\n}\n</code></pre> <p>Next is a further encapsulation of the above functions, including time zone settings. Note that the following function includes the RTC setting <code>rtc_set_time</code>, which depends on the RTC driver at the driver layer. Here I use my custom rtc driver, if there is no related function, you can comment it out directly.</p> <pre><code>/**\n * @brief Obtain the current time with timezone\n * @param timezone_str Timezone string (e.g., \"CST-8\")\n * @note The timezone string should be in the format \"TZ=GMT+/-HH:MM\"\n * @note To use this function, in application, after internet connection, insert \"sync_time_with_timezone(\"CST-8\");\" will do\n * @return None\n */\nvoid sync_time_with_timezone(const char *timezone_str)\n{\n    // Set system timezone\n    setenv(\"TZ\", timezone_str, 1);\n    tzset();\n\n    // Initialize SNTP and start time sync\n    initialize_sntp();\n\n    // Wait for system time to be set\n    time_t now = 0;\n    struct tm timeinfo = { 0 };\n    int retry = 0;\n    const int retry_count = 15;\n\n    while (timeinfo.tm_year &lt; (2020 - 1900) &amp;&amp; ++retry &lt; retry_count) {\n        ESP_LOGI(TAG_SNTP, \"Waiting for system time to be set... (%d/%d)\", retry, retry_count);\n        vTaskDelay(2000 / portTICK_PERIOD_MS);\n        time(&amp;now);\n        localtime_r(&amp;now, &amp;timeinfo);\n    }\n\n    if (timeinfo.tm_year &gt;= (2020 - 1900)) {\n        rtc_set_time(timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday,\n                    timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec); // defined in esp_rtc.c\n        ESP_LOGI(TAG_SNTP, \"System time is set.\");\n    } else {\n        ESP_LOGW(TAG_SNTP, \"Failed to sync time.\");\n        return;\n    }\n\n    // Log current local time\n    ESP_LOGI(TAG_SNTP, \"Current time: %s\", asctime(&amp;timeinfo));\n\n    // vTaskDelay(10000 / portTICK_PERIOD_MS); // Wait for 10 second\n    // rtc_get_time(); // uncomment to check the RTC time\n    // ESP_LOGI(TAG_SNTP, \"Current RTC time: %04d-%02d-%02d %02d:%02d:%02d\",\n    //          calendar.year, calendar.month, calendar.date,\n    //          calendar.hour, calendar.min, calendar.sec); // uncomment to check the RTC time\n\n}\n</code></pre>"},{"location":"TOOLBOX/TIME/notes/#world-time-getting","title":"WORLD TIME GETTING","text":"<p>In order to facilitate the acquisition of world time, we first define a data structure <code>DateTime_t</code> to store information such as year, month, day, hour, minute, and second. Then we define a function <code>tiny_get_current_time</code> to obtain the current world time. This function returns a <code>DateTime_t</code> structure, which contains the current year, month, day, hour, minute, and second information. When using it, pass in a Boolean value <code>print_flag</code> to control whether to print the current time.</p> <pre><code>/**\n * @brief Structure to hold date and time\n */\ntypedef struct TinyDateTime_t\n{\n    int year;\n    int month;\n    int day;\n    int hour;\n    int minute;\n    int second;\n    long microsecond;\n} TinyDateTime_t; \n</code></pre> <pre><code>/* WORLD CURRENT TIME - GET TIME */\n/**\n * @name tiny_get_current_time\n * @brief Get the current time as a TinyDateTime_t struct\n * @param print_flag Flag to indicate whether to print the time\n * @return TinyDateTime_t structure containing the current date and time\n */\nTinyDateTime_t tiny_get_current_time(bool print_flag)\n{\n    struct timeval tv;\n    gettimeofday(&amp;tv, NULL);  // Get current time (seconds + microseconds)\n\n    time_t now = tv.tv_sec;\n    struct tm timeinfo;\n    localtime_r(&amp;now, &amp;timeinfo);  // Convert to local time\n\n    TinyDateTime_t result;\n    result.year   = timeinfo.tm_year + 1900;\n    result.month  = timeinfo.tm_mon + 1;\n    result.day    = timeinfo.tm_mday;\n    result.hour   = timeinfo.tm_hour;\n    result.minute = timeinfo.tm_min;\n    result.second = timeinfo.tm_sec;\n    result.microsecond = tv.tv_usec;\n\n    if (print_flag)\n    {\n        ESP_LOGI(TAG_TIME, \"Current Time: %04d-%02d-%02d %02d:%02d:%02d.%06ld\",\n                 result.year, result.month, result.day,\n                 result.hour, result.minute, result.second, tv.tv_usec);\n    }\n\n    return result;\n}\n</code></pre> <p>Usage</p> <pre><code>void app_main(void)\n{\n    // Initialize SNTP and sync time\n    sync_time_with_timezone(\"CST-8\");\n\n    // Get current time\n    TinyDateTime_t current_time = tiny_get_current_time(true);\n\n    // Print current time\n    ESP_LOGI(TAG_TIME, \"Current Time: %04d-%02d-%02d %02d:%02d:%02d.%06ld\",\n             current_time.year, current_time.month, current_time.day,\n             current_time.hour, current_time.minute, current_time.second, current_time.microsecond);\n}\n</code></pre> <p>Example Output</p> <p></p> <p>Danger</p> <p>The SNTP accuracy is at ms level.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"zh/","title":"TinySHM\uff1a\u9762\u5411\u5fae\u63a7\u5236\u5668\u7684\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u5206\u5e03\u5f0f\u667a\u80fd\u8d4b\u80fd\u6846\u67b6","text":""},{"location":"zh/#_1","title":"\u9879\u76ee\u6982\u8ff0","text":"<p>\u8be5\u9879\u76ee\u65e8\u5728\u5f00\u53d1\u4e00\u4e2a\u8d4b\u80fd\u6846\u67b6\uff0c\u4f7fMCU\u7ea7\u522b\u7684\u7269\u8054\u7f51\u8bbe\u5907\u5177\u5907\u5206\u5e03\u5f0f\u8ba1\u7b97\u548c\u667a\u80fd\u80fd\u529b\uff0c\u4ece\u800c\u63d0\u5347\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u5e94\u7528\u7684\u6548\u679c\u3002\u5982\u679c\u4f60\u5bf9\u8fd9\u4e2a\u9879\u76ee\u611f\u5174\u8da3\uff0c\u8bf7\u7ed9\u4e2a\u661f\u5e76\u4fdd\u6301\u5173\u6ce8\u3002</p> <p>TinySHM</p> <p>\"TinySHM\" \u662f \"Tiny\" \u548c \"SHM\" \u7684\u7ec4\u5408\u3002\"Tiny\" \u610f\u5473\u7740\u4ee3\u7801\u88ab\u8bbe\u8ba1\u4e3a\u8fd0\u884c\u5728 MCU \u8bbe\u5907\u4e0a\uff0c\u800c \"SHM\" \u662f \"Structural Health Monitoring\" \u7684\u7f29\u5199\u3002</p>"},{"location":"zh/#_2","title":"\u76ee\u6807\u786c\u4ef6","text":"<ul> <li>MCU \u8bbe\u5907\uff08\u76ee\u524d\u4ee5 ESP32 \u4e3a\u4e3b\u8981\u76ee\u6807\uff09</li> </ul>"},{"location":"zh/#_3","title":"\u8986\u76d6\u8303\u56f4","text":"<ul> <li>\u5e73\u53f0\u9002\u914d\u4e0e\u5404\u7c7b\u5404\u7c7b\u5de5\u5177\uff08\u65f6\u95f4\u3001\u901a\u8baf\u7b49\uff09</li> <li>\u57fa\u672c\u6570\u5b66\u8fd0\u7b97</li> <li>\u6570\u5b57\u4fe1\u53f7\u5904\u7406</li> <li>TinyML / \u8fb9\u7f18\u4eba\u5de5\u667a\u80fd</li> <li>\u6d4b\u91cf</li> <li>\u7cfb\u7edf\u8bc6\u522b</li> <li>\u635f\u4f24\u76d1\u6d4b\u3001\u5b9a\u4f4d\u3001\u8bc4\u4f30</li> </ul>"},{"location":"zh/#_4","title":"\u5f00\u53d1\u8f7d\u4f53","text":"<p>Tip</p> <p>\u4ee5\u4e0b\u786c\u4ef6\u4ec5\u505a\u5c55\u793a\u7528\u9014\uff0c\u672c\u9879\u76ee\u5e76\u4e0d\u5c40\u9650\u4e8e\u6b64\uff0c\u53ef\u4ee5\u79fb\u690d\u5230\u5176\u4ed6\u7c7b\u578b\u7684\u786c\u4ef6\u4e0a\u3002</p> <ul> <li>Alientek \u7684 DNESP32S3M\uff08ESP32-S3\uff09</li> </ul> <ul> <li> <p> NexNode</p> <p>  \u4ee3\u7801 </p> <p>  \u6587\u6863 </p> </li> </ul>"},{"location":"zh/#_5","title":"\u9879\u76ee\u67b6\u6784","text":"<pre><code>+------------------------------+\n|   - damage_detection         | &lt;-- \u635f\u4f24\u68c0\u6d4b,\u5b9a\u4f4d\u548c\u8bc4\u4f30\n|   - system_identification    | &lt;-- \u7cfb\u7edf\u8bc6\u522b\n|   - measurement              | &lt;-- \u6d4b\u91cf\n| \u5e94\u7528\u5c42                        |\n+------------------------------+\n|   - TinyAI                   | &lt;-- AI \u51fd\u6570\n|   - TinyDSP                  | &lt;-- DSP \u51fd\u6570\n|   - TinyMath                 | &lt;-- \u5e38\u7528\u6570\u5b66\u51fd\u6570\n|   - TinyToolbox              | &lt;-- \u5e73\u53f0\u5e95\u5c42\u4f18\u5316 + \u5404\u79cd\u5de5\u5177\n| \u4e2d\u95f4\u4ef6                        |\n+------------------------------+\n| \u9a71\u52a8\u5c42                        |\n+------------------------------+\n| \u786c\u4ef6\u5c42                        |\n+------------------------------+\n</code></pre>"},{"location":"zh/ABOUT/about/","title":"TinySHM\uff1a\u9762\u5411\u5fae\u63a7\u5236\u5668\u7684\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u5206\u5e03\u5f0f\u667a\u80fd\u8d4b\u80fd\u6846\u67b6","text":""},{"location":"zh/ABOUT/about/#_1","title":"\u9879\u76ee\u6982\u8ff0","text":"<p>\u8be5\u9879\u76ee\u65e8\u5728\u5f00\u53d1\u4e00\u4e2a\u8d4b\u80fd\u6846\u67b6\uff0c\u4f7fMCU\u7ea7\u522b\u7684\u7269\u8054\u7f51\u8bbe\u5907\u5177\u5907\u5206\u5e03\u5f0f\u8ba1\u7b97\u548c\u667a\u80fd\u80fd\u529b\uff0c\u4ece\u800c\u63d0\u5347\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u5e94\u7528\u7684\u6548\u679c\u3002\u5982\u679c\u4f60\u5bf9\u8fd9\u4e2a\u9879\u76ee\u611f\u5174\u8da3\uff0c\u8bf7\u7ed9\u4e2a\u661f\u5e76\u4fdd\u6301\u5173\u6ce8\u3002</p> <p>TinySHM</p> <p>\"TinySHM\" \u662f \"Tiny\" \u548c \"SHM\" \u7684\u7ec4\u5408\u3002\"Tiny\" \u610f\u5473\u7740\u4ee3\u7801\u88ab\u8bbe\u8ba1\u4e3a\u8fd0\u884c\u5728 MCU \u8bbe\u5907\u4e0a\uff0c\u800c \"SHM\" \u662f \"Structural Health Monitoring\" \u7684\u7f29\u5199\u3002</p>"},{"location":"zh/ABOUT/about/#_2","title":"\u76ee\u6807\u786c\u4ef6","text":"<ul> <li>MCU \u8bbe\u5907\uff08\u76ee\u524d\u4ee5 ESP32 \u4e3a\u4e3b\u8981\u76ee\u6807\uff09</li> </ul>"},{"location":"zh/ABOUT/about/#_3","title":"\u8986\u76d6\u8303\u56f4","text":"<ul> <li>\u5e73\u53f0\u9002\u914d\u4e0e\u5404\u7c7b\u5404\u7c7b\u5de5\u5177\uff08\u65f6\u95f4\u3001\u901a\u8baf\u7b49\uff09</li> <li>\u57fa\u672c\u6570\u5b66\u8fd0\u7b97</li> <li>\u6570\u5b57\u4fe1\u53f7\u5904\u7406</li> <li>TinyML / \u8fb9\u7f18\u4eba\u5de5\u667a\u80fd</li> <li>\u6d4b\u91cf</li> <li>\u7cfb\u7edf\u8bc6\u522b</li> <li>\u635f\u4f24\u76d1\u6d4b\u3001\u5b9a\u4f4d\u3001\u8bc4\u4f30</li> </ul>"},{"location":"zh/ABOUT/about/#_4","title":"\u5f00\u53d1\u8f7d\u4f53","text":"<p>Tip</p> <p>\u4ee5\u4e0b\u786c\u4ef6\u4ec5\u505a\u5c55\u793a\u7528\u9014\uff0c\u672c\u9879\u76ee\u5e76\u4e0d\u5c40\u9650\u4e8e\u6b64\uff0c\u53ef\u4ee5\u79fb\u690d\u5230\u5176\u4ed6\u7c7b\u578b\u7684\u786c\u4ef6\u4e0a\u3002</p> <ul> <li>Alientek \u7684 DNESP32S3M\uff08ESP32-S3\uff09</li> </ul> <p></p> <p></p> <ul> <li> <p> NexNode</p> <p>  \u4ee3\u7801 </p> <p>  \u6587\u6863 </p> </li> </ul>"},{"location":"zh/ABOUT/about/#_5","title":"\u9879\u76ee\u67b6\u6784","text":"<pre><code>+------------------------------+\n|   - damage_detection         | &lt;-- \u635f\u4f24\u68c0\u6d4b,\u5b9a\u4f4d\u548c\u8bc4\u4f30\n|   - system_identification    | &lt;-- \u7cfb\u7edf\u8bc6\u522b\n|   - measurement              | &lt;-- \u6d4b\u91cf\n| \u5e94\u7528\u5c42                        |\n+------------------------------+\n|   - TinyAI                   | &lt;-- AI \u51fd\u6570\n|   - TinyDSP                  | &lt;-- DSP \u51fd\u6570\n|   - TinyMath                 | &lt;-- \u5e38\u7528\u6570\u5b66\u51fd\u6570\n|   - TinyToolbox              | &lt;-- \u5e73\u53f0\u5e95\u5c42\u4f18\u5316 + \u5404\u79cd\u5de5\u5177\n| \u4e2d\u95f4\u4ef6                        |\n+------------------------------+\n| \u9a71\u52a8\u5c42                        |\n+------------------------------+\n| \u786c\u4ef6\u5c42                        |\n+------------------------------+\n</code></pre>"},{"location":"zh/ABOUT/about/#_6","title":"\u5f00\u53d1\u8ba1\u5212\u4e0e\u8fdb\u5ea6","text":"<p>\u2705 - \u5df2\u5b8c\u6210</p> <p>\ud83c\udfd7\ufe0f - \u5f00\u53d1\u4e2d</p> <p>\ud83d\udcc6 - \u89c4\u5212\u4e2d</p> <pre><code>&lt;tiny_toolbox&gt;\n- time \u2705\n- command \ud83d\udcc6\n\n&lt;tiny_math&gt;\n- vector \u2705\n- matrix \u2705\n\n&lt;tiny_dsp&gt;\n- signal \ud83c\udfd7\ufe0f\n    - convolution \u2705\n    - correlation \u2705\n- filter \ud83d\udcc6\n- transform \ud83d\udcc6\n- support \ud83d\udcc6\n\n&lt;tiny_ai&gt;\n</code></pre>"},{"location":"zh/AI/ai/","title":"\u4eba\u5de5\u667a\u80fd","text":"<ul> <li> <p> ESP-DL</p> <p>  \u5728\u7ebf\u6587\u6863 </p> </li> </ul>"},{"location":"zh/DSP/dsp/","title":"\u6570\u5b57\u4fe1\u53f7\u5904\u7406","text":"<p>Note</p> <p>\u8be5\u7ec4\u4ef6\u7528\u4e8e\u65e8\u5728\u4e3a\u8fb9\u7f18\u8bbe\u5907\u63d0\u4f9b\u4fe1\u53f7\u5904\u7406\u7684\u4e00\u7cfb\u5217\u51fd\u6570\uff0c\u8bbe\u8ba1\u4e3b\u65e8\u4e3a\u8f7b\u91cf\u9ad8\u6548\uff0c\u8303\u56f4\u4e3a\u5e38\u7528\u91cd\u8981\u7684\u4fe1\u53f7\u5904\u7406\u7b97\u6cd5\u3002</p> <p>Note</p> <p>\u8be5\u7ec4\u4ef6\u57fa\u4e8eESP32\u5b98\u65b9\u6570\u5b57\u4fe1\u53f7\u5904\u7406\u5e93 ESP-DSP \u8fdb\u884c\u5c01\u88c5\u548c\u6269\u5c55\uff0c\u63d0\u4f9b\u4e86\u66f4\u9ad8\u5c42\u6b21\u7684API\u63a5\u53e3\u3002\u5148\u524dTinyMath\u5df2\u7ecf\u5bf9\u5e94\u4e86ESP-DSP\u4e2d\u7684Math, Matrix, DotProduct\u6a21\u5757\uff0cESP-DSP\u4e2d\u7684\u5176\u4f59\u6a21\u5757\u5bf9\u5e94\u672c\u7ec4\u4ef6TinyDSP\u5e93\u3002\u9664\u6b64\u4ee5\u5916\uff0cTinyDSP\u8fd8\u63d0\u4f9b\u4e86ESP-DSP\u4e2d\u672a\u66fe\u63d0\u4f9b\u7684\u4e00\u4e9b\u529f\u80fd\uff0c\u91cd\u70b9\u8986\u76d6\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u7b49\u573a\u666f\u3002</p>"},{"location":"zh/DSP/dsp/#_2","title":"\u7ec4\u4ef6\u4f9d\u8d56","text":"<pre><code>set(src_dirs\n    .\n    signal\n    filter\n    transform\n    support\n)\n\nset(include_dirs\n    .\n    include\n    signal\n    filter\n    transform\n    support\n)\n\nset(requires\n    tiny_math\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"zh/DSP/dsp/#_3","title":"\u67b6\u6784\u4e0e\u529f\u80fd\u76ee\u5f55","text":""},{"location":"zh/DSP/dsp/#_4","title":"\u4f9d\u8d56\u5173\u7cfb\u793a\u610f\u56fe","text":""},{"location":"zh/DSP/dsp/#_5","title":"\u4ee3\u7801\u6811","text":"<pre><code>tiny_dsp/\n\u251c\u2500\u2500 include/                     \n\u2502   \u251c\u2500\u2500 tiny_dsp.h               # entrance header file\n\u2502   \u2514\u2500\u2500 tiny_dsp_config.h        # dsp module configuration file\n\u2502\n\u251c\u2500\u2500 signal/\n\u2502   \u251c\u2500\u2500 tiny_conv.h              # convolution - header file\n\u2502   \u251c\u2500\u2500 tiny_conv.c              # convolution - source file\n\u2502   \u251c\u2500\u2500 tiny_corr.h              # correlation - header file\n\u2502   \u2514\u2500\u2500 tiny_corr.c              # correlation - source file\n\u2502\n\u251c\u2500\u2500 filter/\n\u2502\n\u251c\u2500\u2500 transform/\n\u2502\n\u2514\u2500\u2500 support/\n</code></pre>"},{"location":"zh/DSP/HEADER-FILE/tiny_dsp/","title":"TinyDSP \u5934\u6587\u4ef6","text":"<p>Info</p> <p>\u8fd9\u662fTinyDSP\u5e93\u7684\u4e3b\u5934\u6587\u4ef6\u3002\u5b83\u5305\u542b\u6240\u6709\u5fc5\u8981\u7684\u5934\u6587\u4ef6\uff0c\u5e76\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7edf\u4e00\u7684\u63a5\u53e3\u6765\u4f7f\u7528\u5e93\u7684\u529f\u80fd\u3002\u5728\u9879\u76ee\u4e2d\u5b8c\u6210\u8be5\u5e93\u7684\u79fb\u690d\u540e\uff0c\u5728\u9700\u8981\u4f7f\u7528\u76f8\u5173\u51fd\u6570\u7684\u5730\u65b9\u63d2\u5165\u8be5\u5934\u6587\u4ef6\u5373\u53ef\u4f7f\u7528\u5e93\u5185\u7684\u6240\u6709\u51fd\u6570\u3002\u6587\u6863\u66f4\u65b0\u901f\u5ea6\u8f83\u6162\uff0c\u53ef\u80fd\u4e0e\u5b9e\u9645\u4ee3\u7801\u4e0d\u4e00\u81f4\uff0c\u8bf7\u4ee5\u5b9e\u9645\u4ee3\u7801\u4e3a\u51c6\u3002</p> <pre><code>/**\n * @file tiny_dsp.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief tiny_dsp | entrance file\n * @version 1.0\n * @date 2025-04-28\n * @copyright Copyright (c) 2025\n *\n */\n\n#pragma once\n\n/* DEPENDENCIES */\n\n// tiny_dsp configuration file\n#include \"tiny_dsp_config.h\"\n\n// [signal]\n\n// signal - tiny_conv\n#include \"tiny_conv.h\"\n#include \"tiny_conv_test.h\"\n\n// signal - correlation &amp; crosss correlation\n#include \"tiny_corr.h\"\n#include \"tiny_corr_test.h\"\n\n// [filter]\n\n// [transform]\n\n// [support]\n\n\n\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>"},{"location":"zh/DSP/HEADER-FILE/tiny_dsp_config/","title":"TinyDSP \u914d\u7f6e","text":"<p>Info</p> <p>\u8fd9\u4e2a\u5934\u6587\u4ef6\u8d77\u5230\u914d\u7f6e\u6574\u4e2aTinyDSP\u6a21\u5757\u7684\u4f5c\u7528\uff0c\u6bcf\u4e2a\u5b50\u6a21\u5757\u90fd\u5305\u542b\u4e86\u6b64\u5934\u6587\u4ef6\u3002\u5b83\u5b9a\u4e49\u4e86TinyDSP\u7684\u914d\u7f6e\u9009\u9879\u548c\u5b8f\uff0c\u5141\u8bb8\u7528\u6237\u6839\u636e\u9700\u8981\u8fdb\u884c\u81ea\u5b9a\u4e49\u8bbe\u7f6e\u3002\u901a\u8fc7\u4fee\u6539\u8fd9\u4e2a\u5934\u6587\u4ef6\u4e2d\u7684\u914d\u7f6e\u9009\u9879\uff0c\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u5730\u8c03\u6574TinyDSP\u7684\u884c\u4e3a\u548c\u529f\u80fd\uff0c\u4ee5\u6ee1\u8db3\u7279\u5b9a\u7684\u9700\u6c42\u3002\u6587\u6863\u66f4\u65b0\u901f\u5ea6\u8f83\u6162\uff0c\u53ef\u80fd\u4f1a\u4e0e\u5b9e\u9645\u4ee3\u7801\u4e0d\u4e00\u81f4\uff0c\u8bf7\u4ee5\u4ee3\u7801\u4e3a\u51c6\u3002</p> <p>Tip</p> <p>\u5e73\u53f0\u52a0\u901f\u9009\u9879\u8bf7\u5230TinyMath\u914d\u7f6e\u6587\u4ef6\u4e2d\u8fdb\u884c\u8bbe\u7f6e\u3002</p> <pre><code>/**\n * @file tiny_dsp_config.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief The configuration file for the tiny_dsp middleware.\n * @version 1.0\n * @date 2025-04-27\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_DSPP_CONFIG__\n#define __TINY_DSPP_CONFIG__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* DEPENDENCIES */\n#include \"tiny_math.h\"\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_DSPP_CONFIG__ */\n</code></pre>"},{"location":"zh/DSP/SIGNAL/CONVOLUTION/code/","title":"\u4ee3\u7801","text":""},{"location":"zh/DSP/SIGNAL/CONVOLUTION/notes/","title":"\u8bf4\u660e","text":""},{"location":"zh/DSP/SIGNAL/CONVOLUTION/notes/#_2","title":"\u5377\u79ef\u7684\u6570\u5b66\u539f\u7406","text":"<p>\u5377\u79ef\u662f\u4fe1\u53f7\u5904\u7406\u4e2d\u7684\u4e00\u79cd\u91cd\u8981\u64cd\u4f5c\uff0c\u7528\u4e8e\u63cf\u8ff0\u4e24\u4e2a\u4fe1\u53f7\u4e4b\u95f4\u7684\u5173\u7cfb\u3002\u5b83\u53ef\u4ee5\u770b\u4f5c\u662f\u4e00\u4e2a\u4fe1\u53f7\u4e0e\u53e6\u4e00\u4e2a\u4fe1\u53f7\u7684\u52a0\u6743\u5e73\u5747\u3002\u5377\u79ef\u7684\u6570\u5b66\u5b9a\u4e49\u5982\u4e0b\uff1a</p> \\[y(t) = \\int_{-\\infty}^{\\infty} x(\\tau) h(t - \\tau) d\\tau\\] <p>\u5176\u4e2d\uff0c\\(x(t)\\) \u662f\u8f93\u5165\u4fe1\u53f7\uff0c\\(h(t)\\) \u662f\u7cfb\u7edf\u7684\u8109\u51b2\u54cd\u5e94\uff0c\\(y(t)\\) \u662f\u8f93\u51fa\u4fe1\u53f7\u3002\u5377\u79ef\u7684\u7ed3\u679c\u662f\u4e00\u4e2a\u65b0\u7684\u4fe1\u53f7\uff0c\u5b83\u5305\u542b\u4e86\u8f93\u5165\u4fe1\u53f7\u548c\u7cfb\u7edf\u8109\u51b2\u54cd\u5e94\u4e4b\u95f4\u7684\u6240\u6709\u4fe1\u606f\u3002</p> <p></p>"},{"location":"zh/DSP/SIGNAL/CONVOLUTION/notes/#_3","title":"\u7f16\u7a0b\u601d\u8def","text":"<p>\u672c\u5e93\u4e2d\u7684\u5377\u79ef\u64cd\u4f5c\u5b9e\u9645\u4e0a\u662f\u5c06\u5377\u79ef\u6838\u8c03\u8f6c\u65b9\u5411\u7136\u540e\u4e0e\u8f93\u5165\u4fe1\u53f7\u8fdb\u884c\u9010\u70b9\u76f8\u4e58\u5e76\u6c42\u548c\u3002</p>"},{"location":"zh/DSP/SIGNAL/CONVOLUTION/notes/#tiny_conv_f32","title":"tiny_conv_f32","text":"<pre><code>/**\n * @name: tiny_conv_f32\n * @brief Convolution function\n * \n * @param Signal The input signal array\n * @param siglen The length of the input signal array\n * @param Kernel The input kernel array\n * @param kernlen The length of the input kernel array\n * @param convout The output array for the convolution result\n * \n * @return tiny_error_t \n */\ntiny_error_t tiny_conv_f32(const float *Signal, const int siglen, const float *Kernel, const int kernlen, float *convout)\n{\n    if (NULL == Signal || NULL == Kernel || NULL == convout)\n    {\n        return TINY_ERR_DSP_NULL_POINTER;\n    }\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    // ESP32 DSP library\n    dsps_conv_f32(Signal, siglen, Kernel, kernlen, convout);\n#else\n    float *sig = (float *)Signal;\n    float *kern = (float *)Kernel;\n    int lsig = siglen;\n    int lkern = kernlen;\n\n    // swap the signal and kernel to ensure the signal is longer than the kernel\n    if (siglen &lt; kernlen)\n    {\n        sig = (float *)Kernel;\n        kern = (float *)Signal;\n        lsig = kernlen;\n        lkern = siglen;\n    }\n\n    // stage I\n    for (int n = 0; n &lt; lkern; n++)\n    {\n        size_t k;\n\n        convout[n] = 0;\n\n        for (k = 0; k &lt;= n; k++)\n        {\n            convout[n] += sig[k] * kern[n - k];\n        }\n    }\n\n    // stage II\n    for (int n = lkern; n &lt; lsig; n++)\n    {\n        size_t kmin, kmax, k;\n\n        convout[n] = 0;\n\n        kmin = n - lkern + 1;\n        kmax = n;\n        for (k = kmin; k &lt;= kmax; k++)\n        {\n            convout[n] += sig[k] * kern[n - k];\n        }\n    }\n\n    // stage III\n    for (int n = lsig; n &lt; lsig + lkern - 1; n++)\n    {\n        size_t kmin, kmax, k;\n\n        convout[n] = 0;\n\n        kmin = n - lkern + 1;\n        kmax = lsig - 1;\n        for (k = kmin; k &lt;= kmax; k++)\n        {\n            convout[n] += sig[k] * kern[n - k];\n        }\n    }\n#endif\n\n    return TINY_OK;\n}\n</code></pre> <p>\u63cf\u8ff0\uff1a\u8be5\u51fd\u6570\u5b9e\u73b0\u4e86\u5bf9\u8f93\u5165\u4fe1\u53f7\u548c\u5377\u79ef\u6838\u7684\u5377\u79ef\u64cd\u4f5c\u3002\u5b83\u9996\u5148\u68c0\u67e5\u8f93\u5165\u53c2\u6570\u662f\u5426\u4e3aNULL\uff0c\u7136\u540e\u6839\u636e\u5e73\u53f0\u9009\u62e9\u4f7f\u7528ESP32 DSP\u5e93\u6216\u6807\u51c6C\u5b9e\u73b0\u8fdb\u884c\u5377\u79ef\u8ba1\u7b97\u3002\u51fd\u6570\u8fd4\u56de\u5377\u79ef\u7ed3\u679c\u3002</p> <p>\u7279\u70b9\uff1a</p> <ul> <li> <p>\u652f\u6301ESP32 DSP\u5e93\u52a0\u901f</p> </li> <li> <p>\u652f\u6301\u5377\u79ef\u6838\u548c\u4fe1\u53f7\u4e92\u6362\u4ee5\u4fdd\u8bc1\u4fe1\u53f7\u957f\u5ea6\u5927\u4e8e\u5377\u79ef\u6838\u957f\u5ea6</p> </li> </ul> <p>\u53c2\u6570\uff1a</p> <ul> <li> <p><code>Signal</code>\uff1a\u8f93\u5165\u4fe1\u53f7\u6570\u7ec4</p> </li> <li> <p><code>siglen</code>\uff1a\u8f93\u5165\u4fe1\u53f7\u6570\u7ec4\u7684\u957f\u5ea6</p> </li> <li> <p><code>Kernel</code>\uff1a\u8f93\u5165\u5377\u79ef\u6838\u6570\u7ec4</p> </li> <li> <p><code>kernlen</code>\uff1a\u8f93\u5165\u5377\u79ef\u6838\u6570\u7ec4\u7684\u957f\u5ea6</p> </li> <li> <p><code>convout</code>\uff1a\u8f93\u51fa\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u50a8\u5377\u79ef\u7ed3\u679c</p> </li> </ul> <p>\u8fd4\u56de\u503c\uff1a</p> <ul> <li> <p><code>TINY_OK</code>\uff1a\u5377\u79ef\u6210\u529f</p> </li> <li> <p><code>TINY_ERR_DSP_NULL_POINTER</code>\uff1a\u8f93\u5165\u53c2\u6570\u4e3aNULL</p> </li> </ul>"},{"location":"zh/DSP/SIGNAL/CONVOLUTION/test/","title":"\u6d4b\u8bd5","text":""},{"location":"zh/DSP/SIGNAL/CONVOLUTION/test/#_2","title":"\u6d4b\u8bd5\u7ed3\u679c","text":"<pre><code>Convolution Output:\n  conv_output[0] = 0.500\n  conv_output[1] = 2.000\n  conv_output[2] = 3.500\n  conv_output[3] = 5.000\n  conv_output[4] = 6.500\n  conv_output[5] = 5.000\n[Test Passed] tiny_conv_f32 output matches expected results.\n</code></pre>"},{"location":"zh/DSP/SIGNAL/CORRELATION/code/","title":"\u4ee3\u7801","text":""},{"location":"zh/DSP/SIGNAL/CORRELATION/notes/","title":"\u8bf4\u660e","text":"<p>\u8bf4\u660e</p> <p>\u76f8\u5173\u6027\u662f\u4fe1\u53f7\u5904\u7406\u4e2d\u7684\u4e00\u4e2a\u91cd\u8981\u6982\u5ff5\uff0c\u901a\u5e38\u7528\u4e8e\u5206\u6790\u4fe1\u53f7\u4e4b\u95f4\u7684\u76f8\u4f3c\u6027\u6216\u4f9d\u8d56\u6027\u3002\u5b83\u5728\u8bb8\u591a\u5e94\u7528\u4e2d\u90fd\u5f88\u6709\u7528\uff0c\u4f8b\u5982\u6a21\u5f0f\u8bc6\u522b\u3001\u65f6\u95f4\u5e8f\u5217\u5206\u6790\u548c\u4fe1\u53f7\u68c0\u6d4b\u3002</p>"},{"location":"zh/DSP/SIGNAL/CORRELATION/notes/#_2","title":"\u6ed1\u52a8\u76f8\u5173","text":""},{"location":"zh/DSP/SIGNAL/CORRELATION/notes/#_3","title":"\u6570\u5b66\u539f\u7406","text":"<p>\u76f8\u5173\u8ba1\u7b97\u516c\u5f0f\u4e3a\uff1a</p> \\[ \\text{Correlation}[n] = \\sum_{m=0}^{L_p - 1} S[n + m] \\cdot P[m] \\] <p>\u5176\u4e2d\uff1a - \\( S \\) \u4e3a\u8f93\u5165\u4fe1\u53f7\uff0c\u957f\u5ea6\u4e3a \\( L_s \\)</p> <ul> <li> <p>\\( P \\) \u4e3a\u6a21\u5f0f\u5e8f\u5217\uff08Pattern\uff09\uff0c\u957f\u5ea6\u4e3a \\( L_p \\)</p> </li> <li> <p>\\( n \\in [0, L_s - L_p] \\)</p> </li> </ul> <p>\u8f93\u51fa\u957f\u5ea6\u8ba1\u7b97\uff1a</p> \\[ L_{\\text{out}} = L_s - L_p + 1 \\]"},{"location":"zh/DSP/SIGNAL/CORRELATION/notes/#tiny_corr_f32","title":"tiny_corr_f32","text":"<pre><code>/**\n * @name: tiny_corr_f32\n * @brief Correlation function\n *\n * @param Signal: input signal array\n * @param siglen: length of the signal array\n * @param Pattern: input pattern array\n * @param patlen: length of the pattern array\n * @param dest: output array for the correlation result\n *\n * @return tiny_error_t\n */\ntiny_error_t tiny_corr_f32(const float *Signal, const int siglen, const float *Pattern, const int patlen, float *dest)\n{\n    if (NULL == Signal || NULL == Pattern || NULL == dest)\n    {\n        return TINY_ERR_DSP_NULL_POINTER;\n    }\n\n    if (siglen &lt; patlen) // signal length shoudl be greater than pattern length\n    {\n        return TINY_ERR_DSP_MISMATCH;\n    }\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    dsps_corr_f32(Signal, siglen, Pattern, patlen, dest);\n#else\n\n    for (size_t n = 0; n &lt;= (siglen - patlen); n++)\n    {\n        float k_corr = 0;\n        for (size_t m = 0; m &lt; patlen; m++)\n        {\n            k_corr += Signal[n + m] * Pattern[m];\n        }\n        dest[n] = k_corr;\n    }\n\n#endif\n\n    return TINY_OK;\n}\n</code></pre> <p>\u63cf\u8ff0: \u8ba1\u7b97\u4fe1\u53f7\u548c\u6a21\u5f0f\u4e4b\u95f4\u7684\u76f8\u5173\u6027\u3002</p> <p>\u7279\u70b9</p> <ul> <li>\u652f\u6301\u5e73\u53f0\u52a0\u901f</li> </ul> <p>\u53c2\u6570:</p> <ul> <li> <p><code>Signal</code>: \u8f93\u5165\u4fe1\u53f7\u6570\u7ec4</p> </li> <li> <p><code>siglen</code>: \u4fe1\u53f7\u6570\u7ec4\u7684\u957f\u5ea6</p> </li> <li> <p><code>Pattern</code>: \u8f93\u5165\u6a21\u5f0f\u6570\u7ec4</p> </li> <li> <p><code>patlen</code>: \u6a21\u5f0f\u6570\u7ec4\u7684\u957f\u5ea6</p> </li> <li> <p><code>dest</code>: \u8f93\u51fa\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u50a8\u76f8\u5173\u6027\u7ed3\u679c</p> </li> </ul> <p>\u8fd4\u56de\u503c: \u8fd4\u56de\u6210\u529f\u6216\u9519\u8bef\u4ee3\u7801\u3002</p>"},{"location":"zh/DSP/SIGNAL/CORRELATION/notes/#_4","title":"\u4ea4\u53c9\u76f8\u5173\u51fd\u6570","text":""},{"location":"zh/DSP/SIGNAL/CORRELATION/notes/#_5","title":"\u6570\u5b66\u539f\u7406","text":"<p>\u4e92\u76f8\u5173\u8ba1\u7b97\u516c\u5f0f\u4e3a\uff1a</p> \\[ R_{xy}[n] = \\sum_{k} x[k] \\cdot y[k + n] \\] <p>\u5176\u4e2d\uff1a</p> <ul> <li> <p>\\( x \\) \u4e3a\u4fe1\u53f7\u5e8f\u5217\uff0c\u957f\u5ea6\u4e3a \\( L_x \\)</p> </li> <li> <p>\\( y \\) \u4e3a\u5377\u79ef\u6838\uff08Kernel\uff09\uff0c\u957f\u5ea6\u4e3a \\( L_y \\)</p> </li> <li> <p>\\( n \\in [0, L_x + L_y - 2] \\)</p> </li> </ul> <p>\u8f93\u51fa\u957f\u5ea6\u8ba1\u7b97\uff1a</p> \\[ L_{\\text{out}} = L_x + L_y - 1 \\]"},{"location":"zh/DSP/SIGNAL/CORRELATION/notes/#tiny_ccorr_f32","title":"tiny_ccorr_f32","text":"<pre><code>/**\n * @name: tiny_ccorr_f32\n * @brief Cross-correlation function\n *\n * @param Signal: input signal array\n * @param siglen: length of the signal array\n * @param Kernel: input kernel array\n * @param kernlen: length of the kernel array\n * @param corrvout: output array for the cross-correlation result\n *\n * @return tiny_error_t\n */\ntiny_error_t tiny_ccorr_f32(const float *Signal, const int siglen, const float *Kernel, const int kernlen, float *corrvout)\n{\n    if (NULL == Signal || NULL == Kernel || NULL == corrvout)\n    {\n        return TINY_ERR_DSP_NULL_POINTER;\n    }\n\n    float *sig = (float *)Signal;\n    float *kern = (float *)Kernel;\n    int lsig = siglen;\n    int lkern = kernlen;\n\n    // swap signal and kernel if needed\n    if (siglen &lt; kernlen)\n    {\n        sig = (float *)Kernel;\n        kern = (float *)Signal;\n        lsig = kernlen;\n        lkern = siglen;\n    }\n\n#if MCU_PLATFORM_SELECTED == MCU_PLATFORM_ESP32\n    dsps_ccorr_f32(Signal, siglen, Kernel, kernlen, corrvout);\n#else\n    // stage I\n    for (int n = 0; n &lt; lkern; n++)\n    {\n        size_t k;\n        size_t kmin = lkern - 1 - n;\n        corrvout[n] = 0;\n\n        for (k = 0; k &lt;= n; k++)\n        {\n            corrvout[n] += sig[k] * kern[kmin + k];\n        }\n    }\n\n    // stage II\n    for (int n = lkern; n &lt; lsig; n++)\n    {\n        size_t kmin, kmax, k;\n\n        corrvout[n] = 0;\n\n        kmin = n - lkern + 1;\n        kmax = n;\n        for (k = kmin; k &lt;= kmax; k++)\n        {\n            corrvout[n] += sig[k] * kern[k - kmin];\n        }\n    }\n\n    // stage III\n    for (int n = lsig; n &lt; lsig + lkern - 1; n++)\n    {\n        size_t kmin, kmax, k;\n\n        corrvout[n] = 0;\n\n        kmin = n - lkern + 1;\n        kmax = lsig - 1;\n\n        for (k = kmin; k &lt;= kmax; k++)\n        {\n            corrvout[n] += sig[k] * kern[k - kmin];\n        }\n    }\n#endif\n    return TINY_OK;\n}\n</code></pre> <p>\u63cf\u8ff0: \u8ba1\u7b97\u4fe1\u53f7\u548c\u5377\u79ef\u6838\u4e4b\u95f4\u7684\u4e92\u76f8\u5173\u6027\u3002</p> <p>\u7279\u70b9</p> <ul> <li>\u652f\u6301\u5e73\u53f0\u52a0\u901f</li> </ul> <p>\u53c2\u6570:</p> <ul> <li> <p><code>Signal</code>: \u8f93\u5165\u4fe1\u53f7\u6570\u7ec4</p> </li> <li> <p><code>siglen</code>: \u4fe1\u53f7\u6570\u7ec4\u7684\u957f\u5ea6</p> </li> <li> <p><code>Kernel</code>: \u8f93\u5165\u5377\u79ef\u6838\u6570\u7ec4</p> </li> <li> <p><code>kernlen</code>: \u5377\u79ef\u6838\u6570\u7ec4\u7684\u957f\u5ea6</p> </li> <li> <p><code>corrvout</code>: \u8f93\u51fa\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u50a8\u4e92\u76f8\u5173\u6027\u7ed3\u679c</p> </li> </ul> <p>\u8fd4\u56de\u503c: \u8fd4\u56de\u6210\u529f\u6216\u9519\u8bef\u4ee3\u7801\u3002</p>"},{"location":"zh/DSP/SIGNAL/CORRELATION/test/","title":"\u6d4b\u8bd5","text":""},{"location":"zh/DSP/SIGNAL/CORRELATION/test/#_2","title":"\u6d4b\u8bd5\u7ed3\u679c","text":"<pre><code>========== Correlation &amp; Cross-Correlation Test ==========\n\n--- Test 1: tiny_corr_f32 ---\nInput Signal : [1.00, 2.00, 3.00, 4.00, 2.00, 1.00]\nPattern      : [2.00, 1.00, 0.00]\nOutput vs Expected:\n  [0] Output = 4.000 | Expected = 4.000\n  [1] Output = 7.000 | Expected = 7.000\n  [2] Output = 10.000 | Expected = 10.000\n  [3] Output = 10.000 | Expected = 10.000\n[tiny_corr_f32 Test] [PASS]\n\n--- Test 2: tiny_ccorr_f32 ---\nInput Signal X: [1.00, 3.00, 2.00, 0.00, 1.00, 2.00]\nInput Signal Y: [2.00, 1.00, 0.00, -1.00]\nOutput vs Expected:\n  [0] Output = -1.000 | Expected = -1.000\n  [1] Output = -3.000 | Expected = -3.000\n  [2] Output = -1.000 | Expected = -1.000\n  [3] Output = 5.000 | Expected = 5.000\n  [4] Output = 7.000 | Expected = 7.000\n  [5] Output = 2.000 | Expected = 2.000\n  [6] Output = 1.000 | Expected = 1.000\n  [7] Output = 4.000 | Expected = 4.000\n  [8] Output = 4.000 | Expected = 4.000\n[tiny_ccorr_f32 Test] [PASS]\n==========================================================\n</code></pre>"},{"location":"zh/DSP/USAGE/usage/","title":"\u4f7f\u7528\u8bf4\u660e","text":"<p>\u4f7f\u7528\u8bf4\u660e</p> <p>\u8be5\u6587\u6863\u662f\u5bf9 <code>tiny_dsp</code> \u6a21\u5757\u7684\u4f7f\u7528\u8bf4\u660e\u3002</p>"},{"location":"zh/DSP/USAGE/usage/#tinydsp","title":"\u6574\u4f53\u5f15\u5165TinyDSP","text":"<p>Info</p> <p>\u9002\u7528\u4e8eC\u9879\u76ee\uff0c\u6216\u8005\u7ed3\u6784\u8f83\u4e3a\u7b80\u5355\u7684C++\u9879\u76ee\u3002</p> <pre><code>#include \"tiny_dsp.h\"\n</code></pre>"},{"location":"zh/DSP/USAGE/usage/#tinydsp_1","title":"\u5206\u6a21\u5757\u5f15\u5165TinyDSP","text":"<p>Info</p> <p>\u9002\u7528\u4e8e\u9700\u8981\u7cbe\u786e\u63a7\u5236\u5f15\u5165\u6a21\u5757\u7684\u9879\u76ee\uff0c\u6216\u8005\u590d\u6742\u7684C++\u9879\u76ee\u3002</p> <pre><code>#include \"tiny_conv.h\" // \u5f15\u5165\u5377\u79ef\u6a21\u5757\n#include \"tiny_corr.h\" // \u5f15\u5165\u76f8\u5173\u6a21\u5757\n...\n</code></pre> <p>Tip</p> <p>\u5177\u4f53\u7684\u4f7f\u7528\u65b9\u6cd5\u8bf7\u53c2\u8003\u6d4b\u8bd5\u4ee3\u7801\u3002</p>"},{"location":"zh/MATH/math/","title":"\u6570\u5b66\u8fd0\u7b97","text":"<p>Note</p> <p>\u8be5\u7ec4\u4ef6\u7528\u4e8e \u6570\u5b66\u8fd0\u7b97 \uff0c\u662f\u4e00\u4e2a\u8f7b\u91cf\u7ea7\u7684\u5e93\uff0c\u63d0\u4f9b\u57fa\u672c\u7684\u6570\u5b66\u51fd\u6570\uff0c\u4ee5\u4fbf\u4e8e\u677f\u8f7d\u8ba1\u7b97\u548cAI\u6a21\u578b\u63a8\u7406\u3002\u8be5\u5e93\u8bbe\u8ba1\u4e3a \u8f7b\u91cf\u9ad8\u6548 \uff0c\u9002\u5408\u8fb9\u7f18\u8ba1\u7b97\u5e94\u7528\u3002</p> <p>Note</p> <p>\u8be5\u7ec4\u4ef6\u57fa\u4e8eESP32\u5b98\u65b9\u6570\u5b57\u4fe1\u53f7\u5904\u7406\u5e93 ESP-DSP \u8fdb\u884c\u5c01\u88c5\u548c\u6269\u5c55\uff0c\u63d0\u4f9b\u4e86\u66f4\u9ad8\u5c42\u6b21\u7684API\u63a5\u53e3\u3002\u7b80\u5355\u6765\u8bf4\uff0cTinyMath\u5e93\u5bf9\u5e94ESP-DSP\u4e2d\u7684Math, Matrix, DotProduct\u6a21\u5757\uff0cESP-DSP\u4e2d\u7684\u5176\u4f59\u6a21\u5757\u5bf9\u5e94TinyDSP\u5e93\u3002</p>"},{"location":"zh/MATH/math/#_2","title":"\u7ec4\u4ef6\u4f9d\u8d56","text":"<pre><code>set(src_dirs\n    .\n    vec\n    mat\n)\n\nset(include_dirs\n    .\n    include\n    vec\n    mat\n)\n\nset(requires\n    tiny_toolbox\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"zh/MATH/math/#_3","title":"\u67b6\u6784\u4e0e\u529f\u80fd\u76ee\u5f55","text":""},{"location":"zh/MATH/math/#_4","title":"\u4f9d\u8d56\u5173\u7cfb\u793a\u610f\u56fe","text":""},{"location":"zh/MATH/math/#_5","title":"\u4ee3\u7801\u6811","text":"<pre><code>TinyMath\n    \u251c\u2500\u2500 CMakeLists.txt\n    \u251c\u2500\u2500 include\n    |   \u251c\u2500\u2500 tiny_error_type.h // error type header file\n    |   \u251c\u2500\u2500 tiny_constant.h // constant header file\n    |   \u251c\u2500\u2500 tiny_math_config.h // configuration header file\n    |   \u2514\u2500\u2500 tiny_math.h // main header file, include this file where you want to use the library\n    \u251c\u2500\u2500 vec\n    |   \u251c\u2500\u2500 tiny_vec.h // vector header file\n    |   \u251c\u2500\u2500 tiny_vec.c // vector source file\n    |   \u251c\u2500\u2500 tiny_vec_test.c // vector test file\n    |   \u2514\u2500\u2500 tiny_vec_test.h // vector test header file\n    \u251c\u2500\u2500 mat\n    |   \u251c\u2500\u2500 tiny_mat.h // matrix header file - c\n    |   \u251c\u2500\u2500 tiny_mat.c // matrix source file - c\n    |   \u251c\u2500\u2500 tiny_mat_test.c // matrix test file - c \n    |   \u251c\u2500\u2500 tiny_mat_test.h // matrix test header file - c\n    |   \u251c\u2500\u2500 tiny_matrix.hpp // matrix header file - cpp\n    |   \u251c\u2500\u2500 tiny_matrix.cpp // matrix source file - cpp\n    |   \u251c\u2500\u2500 tiny_matrix_test.cpp // matrix test file - cpp\n    |   \u2514\u2500\u2500 tiny_matrix_test.hpp // matrix test header file - cpp\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/","title":"ESP-DSP \u6570\u5b57\u4fe1\u53f7\u5904\u7406\u5e93","text":"<ul> <li> <p> ESP-DSP</p> <p>\u4e00\u4e2a Espressif DSP \u5e93 (esp-dsp)\uff0c\u5b83\u662f\u4e00\u4e2a\u51fd\u6570\u3001\u6a21\u5757\u548c\u7ec4\u4ef6\u7684\u5e93\uff0c\u63d0\u4f9b\u4e86\u4ee5\u9ad8\u6548\u7684\u65b9\u5f0f\u4f7f\u7528 Espressif \u7684 CPU \u4f5c\u4e3a DSP \u7684\u53ef\u80fd\u6027\u3002</p> <p>  \u5728\u7ebf\u6587\u6863 </p> </li> </ul>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_1","title":"\u51fd\u6570\u547d\u540d","text":"<p>\u547d\u540d\u7ea6\u5b9a\u9002\u7528\u4e8e\u6240\u6709\u8986\u76d6\u7684\u9886\u57df\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7 dsps \u524d\u7f00\u533a\u5206\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0c\u800c\u56fe\u50cf\u548c\u89c6\u9891\u5904\u7406\u51fd\u6570\u5177\u6709 dspi \u524d\u7f00\uff0c\u7279\u5b9a\u4e8e\u5c0f\u77e9\u9635\u64cd\u4f5c\u7684\u51fd\u6570\u5728\u5176\u540d\u79f0\u4e2d\u5177\u6709 dspm \u524d\u7f00\u3002\u5e93\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u5177\u6709\u4ee5\u4e0b\u901a\u7528\u683c\u5f0f\uff1a</p> <pre><code>dsp&lt;data-domain&gt;_&lt;name&gt;_&lt;datatype1&gt;&lt;datatype_ext&gt;_&lt;datatype2&gt;&lt;datatype_ext&gt;[_&lt;descriptor&gt;]&lt;_impl&gt;(&lt;parameters&gt;);\n</code></pre> <p>\u5176\u4e2d\uff1a</p> <ul> <li> <p><code>&lt;data-domain&gt;</code> \u662f\u51fd\u6570\u7684\u57df\uff0c\u4f8b\u5982 <code>s</code> \u8868\u793a\u4fe1\u53f7\u5904\u7406\uff0c<code>i</code> \u8868\u793a\u56fe\u50cf\u5904\u7406\uff0c<code>v</code> \u8868\u793a\u89c6\u9891\u5904\u7406\uff0c<code>m</code> \u8868\u793a\u5c0f\u77e9\u9635\u64cd\u4f5c\u3002</p> </li> <li> <p><code>&lt;name&gt;</code> \u662f\u51fd\u6570\u7684\u540d\u79f0\u3002</p> </li> <li> <p><code>&lt;datatype1&gt;</code> \u662f\u7b2c\u4e00\u4e2a\u8f93\u5165\u53c2\u6570\u7684\u7c7b\u578b\u3002</p> </li> <li> <p><code>&lt;datatype_ext&gt;</code> \u662f\u7b2c\u4e00\u4e2a\u8f93\u5165\u53c2\u6570\u7684\u7c7b\u578b\uff0c\u540e\u7f00\u8868\u793a\u6570\u636e\u7684\u7c7b\u578b\uff0c\u4f8b\u5982 <code>f</code> \u8868\u793a\u6d6e\u70b9\u6570\uff0c<code>i</code> \u8868\u793a\u6574\u6570\uff0c<code>c</code> \u8868\u793a\u590d\u6570\u7b49\u3002</p> </li> <li> <p><code>&lt;datatype2&gt;</code> \u662f\u7b2c\u4e8c\u4e2a\u8f93\u5165\u53c2\u6570\u7684\u7c7b\u578b\u3002</p> </li> <li> <p><code>&lt;descriptor&gt;</code> \u662f\u4e00\u4e2a\u53ef\u9009\u63cf\u8ff0\u7b26\uff0c\u63d0\u4f9b\u6709\u5173\u51fd\u6570\u7684\u9644\u52a0\u4fe1\u606f\u3002</p> </li> <li> <p><code>&lt;impl&gt;</code> \u662f\u4e00\u4e2a\u53ef\u9009\u5b9e\u73b0\u63cf\u8ff0\u7b26\uff0c\u63d0\u4f9b\u6709\u5173\u51fd\u6570\u5b9e\u73b0\u7684\u9644\u52a0\u4fe1\u606f\u3002</p> </li> <li> <p><code>&lt;parameters&gt;</code> \u662f\u51fd\u6570\u7684\u53c2\u6570\u3002</p> </li> </ul>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_2","title":"\u6570\u636e\u57df","text":"<p>\u6570\u636e\u57df\u662f\u4e00\u4e2a\u5355\u5b57\u7b26\uff0c\u8868\u793a\u7ed9\u5b9a\u51fd\u6570\u6240\u5c5e\u7684\u529f\u80fd\u5b50\u96c6\u3002\u5e93\u8bbe\u8ba1\u4e3a\u652f\u6301\u4ee5\u4e0b\u6570\u636e\u57df\uff1a</p> <ul> <li> <p>s - \u4fe1\u53f7\uff08\u9884\u671f\u6570\u636e\u7c7b\u578b\u4e3a 1D \u4fe1\u53f7\uff09</p> </li> <li> <p>i - \u56fe\u50cf\u548c\u89c6\u9891\uff08\u9884\u671f\u6570\u636e\u7c7b\u578b\u4e3a 2D \u56fe\u50cf\uff09</p> </li> <li> <p>m - \u77e9\u9635\uff08\u9884\u671f\u6570\u636e\u7c7b\u578b\u4e3a\u77e9\u9635\uff09</p> </li> <li> <p>r - \u903c\u771f\u6e32\u67d3\u529f\u80fd\u548c 3D \u6570\u636e\u5904\u7406\uff08\u9884\u671f\u6570\u636e\u7c7b\u578b\u53d6\u51b3\u4e8e\u652f\u6301\u7684\u6e32\u67d3\u6280\u672f\uff09</p> </li> <li> <p>q - \u56fa\u5b9a\u957f\u5ea6\u4fe1\u53f7</p> </li> </ul> <p>\u4f8b\u5982\uff0c\u4ee5 dspi \u5f00\u5934\u7684\u51fd\u6570\u540d\u79f0\u8868\u793a\u76f8\u5e94\u7684\u51fd\u6570\u7528\u4e8e\u56fe\u50cf\u6216\u89c6\u9891\u5904\u7406\u3002</p>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_3","title":"\u540d\u79f0","text":"<p>\u51fd\u6570\u540d\u79f0\u662f\u51fd\u6570\u5b9e\u9645\u6267\u884c\u7684\u6838\u5fc3\u64cd\u4f5c\u7684\u7f29\u5199\uff0c\u4f8b\u5982 Add\u3001Sqrt\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u4f1a\u540e\u8ddf\u51fd\u6570\u7279\u5b9a\u7684\u4fee\u9970\u7b26\uff1a= [_modifier]</p> <p>\u5982\u679c\u5b58\u5728\u6b64\u4fee\u9970\u7b26\uff0c\u5219\u8868\u793a\u5bf9\u7ed9\u5b9a\u51fd\u6570\u8fdb\u884c\u4e86\u7ec6\u5fae\u7684\u4fee\u6539\u6216\u53d8\u4f53\u3002</p>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_4","title":"\u6570\u636e\u7c7b\u578b","text":"<p>\u8be5\u5e93\u652f\u6301\u4e24\u79cd\u4e3b\u8981\u6570\u636e\u7c7b\u578b\uff1a\u7528\u4e8e\u5b9a\u70b9\u8fd0\u7b97\u7684 int16 \u548c\u7528\u4e8e\u6d6e\u70b9\u8fd0\u7b97\u7684 float\u3002\u6570\u636e\u7c7b\u578b\u63cf\u8ff0\u5982\u4e0b\uff1a</p>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_5","title":"\u6570\u636e\u7c7b\u578b\u540e\u7f00","text":"<ul> <li> <p>s - \u6709\u7b26\u53f7</p> </li> <li> <p>u - \u65e0\u7b26\u53f7</p> </li> <li> <p>f - \u6d6e\u70b9\u6570</p> </li> </ul>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_6","title":"\u6570\u636e\u7c7b\u578b\u6269\u5c55","text":"<ul> <li>c - \u590d\u6570</li> </ul>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_7","title":"\u6570\u636e\u7c7b\u578b\u6bd4\u7279\u5206\u8fa8\u7387","text":"<ul> <li> <p>16</p> </li> <li> <p>32</p> </li> </ul> <p>\u4f8b\u5982\uff1adsps_mac_sc16 \u5b9a\u4e49\u5c06\u4f7f\u7528 16 \u4f4d\u6709\u7b26\u53f7\u590d\u6570\u6570\u636e\u5bf9 1d \u6570\u7ec4\u8fdb\u884c m\u200b\u200bac \u8fd0\u7b97\u3002</p>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_8","title":"\u5b9e\u73b0\u65b9\u5f0f\u7c7b\u578b","text":"<p>\u6bcf\u4e2a\u51fd\u6570\u53ef\u4ee5\u9488\u5bf9\u4e0d\u540c\u7684\u5e73\u53f0\u8fdb\u884c\u4e0d\u540c\u7684\u5b9e\u73b0\uff0c\u5e76\u4e14\u53ef\u4ee5\u4f7f\u7528\u4e0d\u540c\u7684\u6837\u5f0f\u548c\u8d44\u6e90\u3002\u56e0\u6b64\uff0c\u6bcf\u4e2a\u5b9e\u73b0\u7684\u51fd\u6570\u90fd\u4f1a\u6709\u4e00\u4e2a\u6269\u5c55\u540d &lt;_impl&gt;\uff0c\u7528\u4e8e\u5b9a\u4e49\u5176\u5b9e\u73b0\u7c7b\u578b\u3002\u7528\u6237\u65e0\u9700\u6269\u5c55\u540d\u5373\u53ef\u4f7f\u7528\u901a\u7528\u51fd\u6570\u3002</p>"},{"location":"zh/MATH/ESP-DSP/esp-dsp/#_9","title":"\u5b9e\u73b0\u65b9\u5f0f\u7c7b\u578b\u540e\u7f00","text":"<p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6240\u6709\u51fd\u6570\u65e0\u9700\u6269\u5c55\u5373\u53ef\u4f7f\u7528\u3002\u60a8\u53ef\u4ee5\u5728 menuconfig \u4e2d\u9009\u62e9\u201coptimized/ansi\u201d\u9009\u9879\u3002</p> <p>\u5e93\u4e2d\u7684\u6269\u5c55\u5305\u62ec\uff1a</p> <ul> <li> <p>_ansi - \u901a\u7528\u51fd\u6570\uff0c\u5176\u51fd\u6570\u4f53\u4f7f\u7528 ANSI C \u5b9e\u73b0\u3002\u6b64\u5b9e\u73b0\u4e0d\u5305\u542b\u4efb\u4f55\u786c\u4ef6\u4f18\u5316\u3002</p> </li> <li> <p>_ae32 - \u4f7f\u7528 ESP32 \u6c47\u7f16\u5668\u7f16\u5199\uff0c\u5e76\u9488\u5bf9 ESP32 \u8fdb\u884c\u4e86\u4f18\u5316\u3002</p> </li> <li> <p>_aes3 - \u4f7f\u7528 ESP32S3 \u6c47\u7f16\u5668\u7f16\u5199\uff0c\u5e76\u9488\u5bf9 ESP32S3 \u8fdb\u884c\u4e86\u4f18\u5316\u3002</p> </li> <li> <p>_arp4 - \u4f7f\u7528 ESP32P4 \u6c47\u7f16\u5668\u7f16\u5199\uff0c\u5e76\u9488\u5bf9 ESP32P4 \u8fdb\u884c\u4e86\u4f18\u5316\u3002</p> </li> <li> <p>_platform - \u5934\u6587\u4ef6\uff0c\u5176\u4e2d\u5305\u542b\u9488\u5bf9\u4e0d\u540c\u51fd\u6570\u7684\u53ef\u7528 CPU \u6307\u4ee4\u5b9a\u4e49\u3002</p> </li> <li> <p>\u5176\u4ed6 - \u53d6\u51b3\u4e8e\u652f\u6301\u7684 CPU \u6570\u91cf\u3002\u6b64\u5217\u8868\u672a\u6765\u5c06\u4e0d\u65ad\u6269\u5c55\u3002</p> </li> </ul>"},{"location":"zh/MATH/ESP-DSP/examples/","title":"ESP-DSP \u6848\u4f8b","text":""},{"location":"zh/MATH/ESP-DSP/examples/#esp-dsp_1","title":"esp-dsp \u793a\u4f8b\u5217\u8868","text":"<p>\u4fe1\u53f7\u5904\u7406 API \u4f7f\u7528 dsps \u524d\u7f00\u3002\u4ee5\u4e0b\u6a21\u5757\u53ef\u7528\uff1a</p> <ul> <li> <p>\u57fa\u7840\u6570\u5b66 - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528\u57fa\u672c\u5411\u91cf\u6570\u5b66\u8fd0\u7b97</p> </li> <li> <p>\u70b9\u79ef - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528\u70b9\u79ef\u51fd\u6570</p> </li> <li> <p>\u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362 - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528 FFT \u529f\u80fd</p> </li> <li> <p>\u7a97\u53e3 FFT - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528\u7a97\u53e3\u548c FFT \u529f\u80fd</p> </li> <li> <p>\u5b9e\u6570 FFT - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528 FFT \u529f\u80fd\u5904\u7406\u5b9e\u6570\u8f93\u5165\u4fe1\u53f7</p> </li> <li> <p>\u65e0\u9650\u8109\u51b2\u54cd\u5e94 (IIR) - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528 IIR \u6ee4\u6ce2\u5668\u529f\u80fd</p> </li> <li> <p>\u6709\u9650\u8109\u51b2\u54cd\u5e94 (FIR) - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528 FIR \u6ee4\u6ce2\u5668\u529f\u80fd</p> </li> <li> <p>\u5361\u5c14\u66fc\u6ee4\u6ce2\u5668 - \u6269\u5c55\u5361\u5c14\u66fc\u6ee4\u6ce2\u5668 (EKF) \u793a\u4f8b</p> </li> <li> <p>\u77e9\u9635 - \u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528 Mat \u7c7b\u529f\u80fd</p> </li> </ul>"},{"location":"zh/MATH/ESP-DSP/examples/#_1","title":"\u57fa\u7840\u6570\u5b66","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u4e86\u5982\u4f55\u4f7f\u7528 esp-dsp \u5e93\u4e2d\u7684\u57fa\u672c\u6570\u5b66\u51fd\u6570\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316\u5e93</p> </li> <li> <p>\u7528 1024 \u4e2a\u6837\u672c\u521d\u59cb\u5316\u8f93\u5165\u4fe1\u53f7</p> </li> <li> <p>\u4f7f\u7528\u6807\u51c6 C \u5faa\u73af\u5bf9\u8f93\u5165\u4fe1\u53f7\u52a0\u7a97\u3002</p> </li> <li> <p>\u8ba1\u7b97 1024 \u4e2a\u590d\u6570\u6837\u672c\u7684 FFT \u5e76\u663e\u793a\u7ed3\u679c</p> </li> <li> <p>\u5728\u56fe\u8868\u4e0a\u663e\u793a\u7ed3\u679c</p> </li> <li> <p>\u4f7f\u7528\u57fa\u672c\u6570\u5b66\u51fd\u6570 dsps_mul_f32 \u548c dsps_mulc_f32 \u5bf9\u8f93\u5165\u4fe1\u53f7\u52a0\u7a97\u3002</p> </li> <li> <p>\u8ba1\u7b97 1024 \u4e2a\u590d\u6570\u6837\u672c\u7684 FFT</p> </li> <li> <p>\u5728\u56fe\u8868\u4e0a\u663e\u793a\u7ed3\u679c</p> </li> </ul> <p>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 examples/basic_math/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#_2","title":"\u70b9\u79ef","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u4e86\u5982\u4f55\u4f7f\u7528 esp-dsp \u5e93\u4e2d\u7684 dotprod dsps_dotprod_f32 \u51fd\u6570\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316\u8f93\u5165\u6570\u7ec4</p> </li> <li> <p>\u8ba1\u7b97\u4e24\u4e2a\u6570\u7ec4\u7684\u70b9\u79ef</p> </li> <li> <p>\u6bd4\u8f83\u7ed3\u679c\u5e76\u8ba1\u7b97\u6267\u884c\u65f6\u95f4\uff08\u4ee5\u5468\u671f\u4e3a\u5355\u4f4d\uff09\u3002</p> </li> </ul> <p>\u66f4\u591a\u8be6\u60c5\uff0c\u8bf7\u53c2\u9605 examples/dotprod/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#fft","title":"FFT","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u4e86\u5982\u4f55\u4f7f\u7528 ESP-DSP \u5e93\u4e2d\u7684 FFT \u529f\u80fd\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316\u5e93</p> </li> <li> <p>\u7528 1024 \u4e2a\u6837\u672c\u521d\u59cb\u5316\u8f93\u5165\u4fe1\u53f7\uff1a\u7b2c\u4e00\u4e2a 0 dB\uff0c\u7b2c\u4e8c\u4e2a -20 dB</p> </li> <li> <p>\u5c06\u4e24\u4e2a\u4fe1\u53f7\u5408\u5e76\u4e3a\u4e00\u4e2a\u590d\u6570\u8f93\u5165\u4fe1\u53f7\uff0c\u5e76\u5bf9\u8f93\u5165\u4fe1\u53f7\u5bf9\u5e94\u7528\u7a97\u53e3\u3002</p> </li> <li> <p>\u8ba1\u7b97 1024 \u4e2a\u590d\u6570\u6837\u672c\u7684 FFT</p> </li> <li> <p>\u5bf9\u8f93\u51fa\u590d\u6570\u5411\u91cf\u5e94\u7528\u4f4d\u53cd\u8f6c\u64cd\u4f5c</p> </li> <li> <p>\u5c06\u4e00\u4e2a\u590d\u6570 FFT \u8f93\u51fa\u9891\u8c31\u62c6\u5206\u4e3a\u4e24\u4e2a\u5b9e\u6570\u4fe1\u53f7\u9891\u8c31</p> </li> <li> <p>\u5728\u56fe\u8868\u4e0a\u663e\u793a\u7ed3\u679c</p> </li> <li> <p>\u663e\u793a FFT \u7684\u6267\u884c\u65f6\u95f4</p> </li> </ul> <p>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 examples/fft/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#fft_1","title":"FFT \u7a97\u53e3","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u4e86\u5982\u4f55\u4f7f\u7528 esp-dsp \u5e93\u4e2d\u7684\u7a97\u53e3\u548c FFT \u529f\u80fd\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316\u5e93</p> </li> <li> <p>\u7528 1024 \u4e2a\u6837\u672c\u521d\u59cb\u5316\u8f93\u5165\u4fe1\u53f7</p> </li> <li> <p>\u5bf9\u8f93\u5165\u4fe1\u53f7\u5e94\u7528\u7a97\u53e3\u3002</p> </li> <li> <p>\u5bf9 1024 \u4e2a\u590d\u6570\u6837\u672c\u8ba1\u7b97 FFT</p> </li> <li> <p>\u5bf9\u8f93\u51fa\u590d\u6570\u5411\u91cf\u5e94\u7528\u4f4d\u53cd\u8f6c\u64cd\u4f5c</p> </li> <li> <p>\u5c06\u4e00\u4e2a\u590d\u6570 FFT \u8f93\u51fa\u9891\u8c31\u62c6\u5206\u4e3a\u4e24\u4e2a\u5b9e\u6570\u4fe1\u53f7\u9891\u8c31</p> </li> <li> <p>\u5728\u56fe\u8868\u4e0a\u663e\u793a\u7ed3\u679c</p> </li> </ul> <p>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 examples/fft_window/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#fft-4-real","title":"FFT 4 Real","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u4e86\u5982\u4f55\u4f7f\u7528 ESP-DSP \u5e93\u4e2d\u7684 FFT \u529f\u80fd\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316\u5e93</p> </li> <li> <p>\u7528 1024 \u4e2a\u6837\u672c\u521d\u59cb\u5316\u8f93\u5165\u4fe1\u53f7\uff1a\u7b2c\u4e00\u4e2a 0 dB\uff0c\u7b2c\u4e8c\u4e2a -20 dB</p> </li> <li> <p>\u8ba1\u7b97 1024 \u4e2a\u590d\u6570\u6837\u672c\u7684 FFT \u57fa\u6570 2</p> </li> <li> <p>\u8ba1\u7b97 1024 \u4e2a\u590d\u6570\u6837\u672c\u7684 FFT \u57fa\u6570 4</p> </li> <li> <p>\u5bf9\u8f93\u51fa\u590d\u6570\u5411\u91cf\u5e94\u7528\u4f4d\u53cd\u8f6c\u8fd0\u7b97</p> </li> <li> <p>\u7ed8\u56fe\u663e\u793a\u7ed3\u679c</p> </li> <li> <p>\u663e\u793a FFT \u6267\u884c\u65f6\u95f4</p> </li> </ul> <p>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 examples/fft4real/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#iir","title":"IIR","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u4e86\u5982\u4f55\u4f7f\u7528 ESP-DSP \u5e93\u4e2d\u7684 IIR \u6ee4\u6ce2\u5668\u529f\u80fd\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316\u5e93</p> </li> <li> <p>\u521d\u59cb\u5316\u8f93\u5165\u4fe1\u53f7</p> </li> <li> <p>\u663e\u793a Q \u56e0\u5b50\u4e3a 1 \u7684\u4f4e\u901a\u6ee4\u6ce2\u5668 (LPF)</p> </li> <li> <p>\u8ba1\u7b97 IIR \u6ee4\u6ce2\u5668\u7cfb\u6570</p> </li> <li> <p>\u6ee4\u6ce2\u8f93\u5165\u6d4b\u8bd5\u4fe1\u53f7\uff08Delta \u51fd\u6570\uff09</p> </li> <li> <p>\u5728\u56fe\u4e2d\u663e\u793a\u8109\u51b2\u54cd\u5e94</p> </li> <li> <p>\u5728\u56fe\u4e2d\u663e\u793a\u9891\u7387\u54cd\u5e94</p> </li> <li> <p>\u8ba1\u7b97\u6267\u884c\u6027\u80fd</p> </li> <li> <p>\u5bf9\u4e8e Q \u56e0\u5b50\u4e3a 10 \u7684\u4f4e\u901a\u6ee4\u6ce2\u5668\uff0c\u540c\u6837\u5982\u6b64</p> </li> </ul> <p>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 examples/fir/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#fir","title":"FIR","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u4e86\u5982\u4f55\u4f7f\u7528 ESP-DSP \u5e93\u4e2d\u7684 FIR \u6ee4\u6ce2\u5668\u529f\u80fd\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316 FFT \u5e93</p> </li> <li> <p>\u521d\u59cb\u5316\u8f93\u5165\u4fe1\u53f7</p> </li> <li> <p>\u663e\u793a\u8f93\u5165\u4fe1\u53f7</p> </li> <li> <p>\u663e\u793a\u6ee4\u6ce2\u540e\u7684\u4fe1\u53f7</p> </li> </ul> <p>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 examples/fir/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#_3","title":"\u5361\u5c14\u66fc\u6ee4\u6ce2\u5668","text":"<p>\u672c\u793a\u4f8b\u6a21\u62df\u4e86\u5e26\u6709 IMU \u4f20\u611f\u5668\u7684\u7cfb\u7edf\uff0c\u5e76\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528\u5177\u6709 13 \u4e2a\u72b6\u6001\u5411\u91cf\u7684\u6269\u5c55\u5361\u5c14\u66fc\u6ee4\u6ce2\u5668 (EKF) \u6765\u4f30\u8ba1\u9640\u87ba\u4eea\u8bef\u5dee\u5e76\u8ba1\u7b97\u7cfb\u7edf\u59ff\u6001\u3002\u6b64\u5916\uff0c\u672c\u793a\u4f8b\u8fd8\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528 esp-dsp \u5e93\u5bf9\u77e9\u9635\u548c\u5411\u91cf\u8fdb\u884c\u8fd0\u7b97\u3002</p> <p>\u5728\u5b9e\u9645\u7cfb\u7edf\u4e2d\uff0c\u5e94\u5c06\u6a21\u62df\u4f20\u611f\u5668\u503c\u66ff\u6362\u4e3a\u5b9e\u9645\u4f20\u611f\u5668\u503c\u3002\u7136\u540e\uff0c\u5728\u5b9e\u9645\u7cfb\u7edf\u4e2d\uff0c\u5e94\u6267\u884c\u6821\u51c6\u9636\u6bb5\u3002\u6821\u51c6\u9636\u6bb5\u7ed3\u675f\u540e\uff0c\u5e94\u4fdd\u5b58\u72b6\u6001\u5411\u91cf X \u548c\u534f\u65b9\u5dee\u77e9\u9635 P\uff0c\u5e76\u5728\u4e0b\u6b21\u8c03\u7528\u6ee4\u6ce2\u5668\u65f6\u6062\u590d\u3002\u8fd9\u5c06\u8282\u7701\u521d\u59cb\u9636\u6bb5\u7684\u65f6\u95f4\u3002</p> <p>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 examples/kalman/README.md</p>"},{"location":"zh/MATH/ESP-DSP/examples/#_4","title":"\u77e9\u9635","text":"<p>\u672c\u793a\u4f8b\u6f14\u793a\u5982\u4f55\u4f7f\u7528 esp-dsp \u5e93\u4e2d\u7684 Mat \u7c7b\u529f\u80fd\u3002\u793a\u4f8b\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li> <p>\u521d\u59cb\u5316\u77e9\u9635 A \u548c \u77e9\u9635 x</p> </li> <li> <p>\u8ba1\u7b97\u77e9\u9635 b\uff1ab = A*x</p> </li> <li> <p>\u4f7f\u7528\u4e0d\u540c\u65b9\u6cd5\u6c42 x1 \u7684\u6839\uff1aA*x1 = b</p> </li> <li> <p>\u6253\u5370\u7ed3\u679c</p> </li> </ul>"},{"location":"zh/MATH/HEADER-FILE/tiny_constants/","title":"\u5e38\u91cf\u5b9a\u4e49","text":"<p>Info</p> <p>\u8be5\u6587\u4ef6\u5305\u542b\u4e86\u4e00\u4e9b\u5e38\u91cf\u7684\u5b9a\u4e49\u7528\u4e8e\u4e0a\u5c42\u8ba1\u7b97\u548c\u5e94\u7528\u3002\u6587\u6863\u66f4\u65b0\u901f\u5ea6\u8f83\u6162\uff0c\u53ef\u80fd\u4e0e\u5b9e\u9645\u4ee3\u7801\u4e0d\u4e00\u81f4\uff0c\u8bf7\u4ee5\u4ee3\u7801\u4e3a\u51c6\u3002</p> <pre><code>/**\n * @file tiny_constants.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file contains the constants used in the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n */\n\n#ifndef __TINY_CONSTANTS_H__\n#define __TINY_CONSTANTS_H__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n// =======================================\n//  Logical Constants\n// =======================================\n#ifndef TRUE\n#define TRUE 1\n#endif\n\n#ifndef FALSE\n#define FALSE 0\n#endif\n\n#ifndef NULL\n#define NULL ((void *)0)\n#endif\n\n// =======================================\n//  Math Constants (float/double safe)\n// =======================================\n#define TINY_PI 3.14159265358979323846f\n#define TINY_TWO_PI 6.28318530717958647692f\n#define TINY_HALF_PI 1.57079632679489661923f\n#define TINY_E 2.71828182845904523536f\n#define TINY_SQRT2 1.41421356237309504880f\n#define TINY_INV_SQRT2 0.70710678118654752440f\n\n#define TINY_DEG2RAD(x) ((x) * TINY_PI / 180.0f)\n#define TINY_RAD2DEG(x) ((x) * 180.0f / TINY_PI)\n\n// =======================================\n//  Bitmask &amp; Bit Manipulation\n// =======================================\n\n// Bitwise operations\n#define TINY_BIT(n) (1U &lt;&lt; (n)) // e.g. TINY_BIT(3) = 0b00001000\n#define TINY_BIT_SET(x, n) ((x) |= TINY_BIT(n))\n#define TINY_BIT_CLEAR(x, n) ((x) &amp;= ~TINY_BIT(n))\n#define TINY_BIT_TOGGLE(x, n) ((x) ^= TINY_BIT(n))\n#define TINY_BIT_CHECK(x, n) (((x) &gt;&gt; (n)) &amp; 0x1U)\n\n// Common bit masks\n#define TINY_MASK_4BIT 0x0FU\n#define TINY_MASK_8BIT 0xFFU\n#define TINY_MASK_16BIT 0xFFFFU\n#define TINY_MASK_32BIT 0xFFFFFFFFU\n\n// =======================================\n//  Fixed-Point Scaling Factors\n// =======================================\n#define TINY_Q7_SCALE 128          // 2^7\n#define TINY_Q15_SCALE 32768       // 2^15\n#define TINY_Q31_SCALE 2147483648U // 2^31\n\n// =======================================\n//  User-Defined Constants (Optional)\n// =======================================\n#define TINY_MATH_MIN_DENOMINATOR 1e-6f // Minimum denominator for safe division\n#define TINY_MATH_MIN_POSITIVE_INPUT_F32 1e-12f // Minimum positive input for float operations\n\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_CONSTANTS_H__ */\n</code></pre>"},{"location":"zh/MATH/HEADER-FILE/tiny_error_type/","title":"\u9519\u8bef\u7c7b\u578b\u5b9a\u4e49","text":"<p>Info</p> <p>\u8be5\u6587\u4ef6\u5b9a\u4e49\u4e86\u4e00\u4e9b\u8ba1\u7b97\u4e2d\u5e38\u89c1\u7684\u9519\u8bef\u7c7b\u578b\uff0c\u7528\u4e8e\u8f85\u52a9\u5224\u65ad\u9519\u8bef\u539f\u56e0\u3002\u6587\u6863\u66f4\u65b0\u901f\u5ea6\u8f83\u6162\uff0c\u53ef\u80fd\u4e0e\u5b9e\u9645\u4ee3\u7801\u4e0d\u7b26\uff0c\u8bf7\u4ee5\u4ee3\u7801\u4e3a\u51c6\u3002</p> <pre><code>/**\n * @file tiny_error_type.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief The configuration file for the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-15\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_ERROR_TYPE__\n#define __TINY_ERROR_TYPE__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* TYPE DEFINITIONS */\ntypedef int tiny_error_t; // Error type for the tiny_math middleware\n\n/* MACROS */\n/* Definitions for error constants. */\n#define TINY_OK          0       /*!&lt; tiny_err_t value indicating success (no error) */\n#define TINY_FAIL        -1      /*!&lt; Generic tiny_err_t code indicating failure */\n\n#define TINY_ERR_NO_MEM              0x101   /*!&lt; Out of memory */\n#define TINY_ERR_INVALID_ARG         0x102   /*!&lt; Invalid argument */\n#define TINY_ERR_INVALID_STATE       0x103   /*!&lt; Invalid state */\n#define TINY_ERR_INVALID_SIZE        0x104   /*!&lt; Invalid size */\n#define TINY_ERR_NOT_FOUND           0x105   /*!&lt; Requested resource not found */\n#define TINY_ERR_NOT_SUPPORTED       0x106   /*!&lt; Operation or feature not supported */\n#define TINY_ERR_TIMEOUT             0x107   /*!&lt; Operation timed out */\n#define TINY_ERR_INVALID_RESPONSE    0x108   /*!&lt; Received response was invalid */\n#define TINY_ERR_INVALID_CRC         0x109   /*!&lt; CRC or checksum was invalid */\n#define TINY_ERR_INVALID_VERSION     0x10A   /*!&lt; Version was invalid */\n#define TINY_ERR_INVALID_MAC         0x10B   /*!&lt; MAC address was invalid */\n#define TINY_ERR_NOT_FINISHED        0x10C   /*!&lt; Operation has not fully completed */\n#define TINY_ERR_NOT_ALLOWED         0x10D   /*!&lt; Operation is not allowed */\n\n#define TINY_ERR_WIFI_BASE           0x3000  /*!&lt; Starting number of WiFi error codes */\n#define TINY_ERR_MESH_BASE           0x4000  /*!&lt; Starting number of MESH error codes */\n#define TINY_ERR_FLASH_BASE          0x6000  /*!&lt; Starting number of flash error codes */\n#define TINY_ERR_HW_CRYPTO_BASE      0xc000  /*!&lt; Starting number of HW cryptography module error codes */\n#define TINY_ERR_MEMPROT_BASE        0xd000  /*!&lt; Starting number of Memory Protection API error codes */\n\n#define TINY_ERR_MATH_BASE                0x70000\n#define TINY_ERR_MATH_INVALID_LENGTH      (TINY_ERR_MATH_BASE + 1)\n#define TINY_ERR_MATH_INVALID_PARAM       (TINY_ERR_MATH_BASE + 2)\n#define TINY_ERR_MATH_PARAM_OUTOFRANGE    (TINY_ERR_MATH_BASE + 3)\n#define TINY_ERR_MATH_UNINITIALIZED       (TINY_ERR_MATH_BASE + 4)\n#define TINY_ERR_MATH_REINITIALIZED       (TINY_ERR_MATH_BASE + 5)\n#define TINY_ERR_MATH_ARRAY_NOT_ALIGNED   (TINY_ERR_MATH_BASE + 6)\n#define TINY_ERR_MATH_NULL_POINTER        (TINY_ERR_MATH_BASE + 7)\n#define TINY_ERR_MATH_ZERO_DIVISION       (TINY_ERR_MATH_BASE + 8)\n#define TINY_ERR_MATH_NEGATIVE_SQRT        (TINY_ERR_MATH_BASE + 9)\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_ERROR_TYPE__ */\n</code></pre>"},{"location":"zh/MATH/HEADER-FILE/tiny_math/","title":"TinyMath\u5934\u6587\u4ef6","text":"<p>Info</p> <p>\u8fd9\u662fTinyMath\u5e93\u7684\u4e3b\u5934\u6587\u4ef6\u3002\u5b83\u5305\u542b\u6240\u6709\u5fc5\u8981\u7684\u5934\u6587\u4ef6\uff0c\u5e76\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7edf\u4e00\u7684\u63a5\u53e3\u6765\u4f7f\u7528\u5e93\u7684\u529f\u80fd\u3002\u5728\u9879\u76ee\u4e2d\u5b8c\u6210\u8be5\u5e93\u7684\u79fb\u690d\u540e\uff0c\u5728\u9700\u8981\u4f7f\u7528\u76f8\u5173\u51fd\u6570\u7684\u5730\u65b9\u63d2\u5165\u8be5\u5934\u6587\u4ef6\u5373\u53ef\u4f7f\u7528\u5e93\u5185\u7684\u6240\u6709\u51fd\u6570\u3002\u6587\u6863\u66f4\u65b0\u901f\u5ea6\u8f83\u6162\uff0c\u53ef\u80fd\u4e0e\u5b9e\u9645\u4ee3\u7801\u4e0d\u4e00\u81f4\uff0c\u8bf7\u4ee5\u5b9e\u9645\u4ee3\u7801\u4e3a\u51c6\u3002</p> <pre><code>/**\n * @file tiny_math.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the tiny_math middleware.\n * @version 1.0\n * @date 2025-03-26\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_MATH__\n#define __TINY_MATH__\n\n/* DEPENDENCIES */\n\n// this layer\n#include \"tiny_math_config.h\"\n\n/* SUBMODULES */\n\n// vector operations\n#include \"tiny_vec.h\"\n\n// matrix operations\n#include \"tiny_mat.h\"\n\n// advanced matrix operations\n#ifdef __cplusplus\n\n#include \"tiny_matrix.hpp\"\n\n#endif\n\n/* TEST */ // NOTE: test files are platform specific and should not be included in the library\n\n// vector operations\n#include \"tiny_vec_test.h\"\n\n// matrix operations\n#include \"tiny_mat_test.h\"\n\n// advanced matrix operations\n#ifdef __cplusplus\n\n#include \"tiny_matrix_test.hpp\"\n\n#endif\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_MATH__ */\n</code></pre>"},{"location":"zh/MATH/HEADER-FILE/tiny_math_config/","title":"TinyMath \u914d\u7f6e","text":"<p>Info</p> <p>\u8fd9\u4e2a\u5934\u6587\u4ef6\u8d77\u5230\u914d\u7f6e\u6574\u4e2aTinyMath\u6a21\u5757\u7684\u4f5c\u7528\uff0c\u6bcf\u4e2a\u5b50\u6a21\u5757\u90fd\u5305\u542b\u4e86\u6b64\u5934\u6587\u4ef6\u3002\u5b83\u5b9a\u4e49\u4e86TinyMath\u7684\u914d\u7f6e\u9009\u9879\u548c\u5b8f\uff0c\u5141\u8bb8\u7528\u6237\u6839\u636e\u9700\u8981\u8fdb\u884c\u81ea\u5b9a\u4e49\u8bbe\u7f6e\u3002\u901a\u8fc7\u4fee\u6539\u8fd9\u4e2a\u5934\u6587\u4ef6\u4e2d\u7684\u914d\u7f6e\u9009\u9879\uff0c\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u5730\u8c03\u6574TinyMath\u7684\u884c\u4e3a\u548c\u529f\u80fd\uff0c\u4ee5\u6ee1\u8db3\u7279\u5b9a\u7684\u9700\u6c42\u3002\u6587\u6863\u66f4\u65b0\u901f\u5ea6\u8f83\u6162\uff0c\u53ef\u80fd\u4f1a\u4e0e\u5b9e\u9645\u4ee3\u7801\u4e0d\u4e00\u81f4\uff0c\u8bf7\u4ee5\u4ee3\u7801\u4e3a\u51c6\u3002</p> <p>Tip</p> <p>\u8be5\u7ec4\u4ef6\u5185\u5305\u62ec\u9009\u62e9\u5e73\u53f0\u7684\u5b8f\u5b9a\u4e49\uff0c\u7528\u6237\u53ef\u4ee5\u6839\u636e\u9700\u8981\u9009\u62e9\u4e0d\u540c\u7684\u5e73\u53f0\u8fdb\u884c\u7f16\u8bd1\u3002\u5207\u6362\u5230\u5bf9\u5e94\u5e73\u53f0\u7684\u5b8f\u540e\uff0c\u53ef\u4ee5\u5229\u7528\u5e73\u53f0\u52a0\u901f\u7684\u7279\u6027\u6765\u63d0\u5347\u6027\u80fd\u3002\u4f8b\u5982\uff0c\u5bf9\u4e8eESP32\u5e73\u53f0\uff0cTinyMath\u4f1a\u81ea\u52a8\u9009\u62e9ESP32\u7684DSP\u5e93\u8fdb\u884c\u7f16\u8bd1\uff0c\u4ece\u800c\u5b9e\u73b0\u66f4\u9ad8\u6548\u7684\u6570\u5b66\u8fd0\u7b97\u3002</p> <pre><code>/**\n * @file tiny_math_config.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief The configuration file for the tiny_math middleware.\n * @version 1.0\n * @date 2025-04-14\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINY_MATH_CONFIG__\n#define __TINY_MATH_CONFIG__\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* DEPENDENCIES */\n\n// ANSI C\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdint.h&gt;\n\n// lower level\n#include \"tiny_toolbox.h\"\n\n// this level\n#include \"tiny_error_type.h\"\n#include \"tiny_constants.h\"\n\n/* PLATFORM SELECTION */\n\n// available platforms\n#define MCU_PLATFORM_GENERIC     0\n#define MCU_PLATFORM_ESP32       1 // here, we utilize the ESP built-in DSP library, it will automatically select the optimized version\n#define MCU_PLATFORM_STM32       2\n#define MCU_PLATFORM_RISCV       3\n\n// choose one platform\n#define MCU_PLATFORM_SELECTED    MCU_PLATFORM_ESP32\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __TINY_MATH_CONFIG__ */\n</code></pre>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/","title":"\u77e9\u9635\u64cd\u4f5c - TINY_MAT","text":"<p>\u5173\u4e8etiny_mat\u5e93</p> <p>tiny_mat\u662f\u4e00\u4e2aC\u8bed\u8a00\u5b9e\u73b0\u7684\u77e9\u9635\u5e93\uff0c\u63d0\u4f9b\u4e86\u57fa\u672c\u7684\u77e9\u9635\u64cd\u4f5c\u51fd\u6570\u3002\u5b83\u652f\u6301\u6d6e\u70b9\u6570\u77e9\u9635\u7684\u52a0\u6cd5\u3001\u51cf\u6cd5\u548c\u4e58\u6cd5\u7b49\u64cd\u4f5c\u3002\u8be5\u5e93\u9002\u7528\u4e8e\u9700\u8981\u8fdb\u884c\u77e9\u9635\u8ba1\u7b97\u7684\u5d4c\u5165\u5f0f\u7cfb\u7edf\u548c\u5b9e\u65f6\u5e94\u7528\u3002\u8be5\u5e93\u57fa\u4e8eANSIC C\u6807\u51c6\uff0c\u5177\u6709\u826f\u597d\u7684\u53ef\u79fb\u690d\u6027\u548c\u6027\u80fd,\u540c\u65f6\u53c8\u652f\u6301\u5728\u914d\u7f6e\u6587\u4ef6\u4e2d\u8fdb\u884c\u914d\u7f6e\u4ece\u800c\u652f\u6301\u5e73\u53f0\u52a0\u901f\uff08ESP32\uff09\u3002</p> <p>\u5173\u4e8etiny_mat\u5e93\u7684\u4f7f\u7528</p> <p>tiny_mat\u7684\u529f\u80fd\u88abtiny_matrix\u5b8c\u5168\u8986\u76d6\uff0c\u4e5f\u5c31\u662f\u8bf4\u5728tiny_matrix\u4e2d\u7684\u529f\u80fd\u5305\u542b\u4e86tiny_mat\u7684\u6240\u6709\u529f\u80fd\u3002\u5bf9\u4e8e\u7b80\u5355\u7684\u77e9\u9635\u64cd\u4f5c\uff0c\u53ef\u4ee5\u4ec5\u5f15\u5165tiny_mat\u5e93\uff1b\u5bf9\u4e8e\u590d\u6742\u7684\u77e9\u9635\u64cd\u4f5c\uff0c\u5efa\u8bae\u4f7f\u7528tiny_matrix\u5e93\u3002tiny_matrix\u5e93\u662f\u4e00\u4e2aC++\u5b9e\u73b0\u7684\u77e9\u9635\u5e93\uff0c\u63d0\u4f9b\u4e86\u66f4\u4e30\u5bcc\u7684\u529f\u80fd\u548c\u66f4\u597d\u7684\u6027\u80fd\u3002\u5b83\u652f\u6301\u6d6e\u70b9\u6570\u548c\u6574\u6570\u77e9\u9635\u7684\u52a0\u6cd5\u3001\u51cf\u6cd5\u3001\u4e58\u6cd5\u3001\u8f6c\u7f6e\u3001\u6c42\u9006\u7b49\u64cd\u4f5c\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_1","title":"\u76ee\u5f55","text":"<pre><code>TinyMath\n    \u251c\u2500\u2500Vector\n    \u2514\u2500\u2500Matrix\n        \u251c\u2500\u2500 tiny_mat (c) &lt;---\n        \u2514\u2500\u2500 tiny_matrix (c++)\n</code></pre> <pre><code>// print matrix\nvoid print_matrix(const char *name, const float *mat, int rows, int cols);\n// print matrix padded (row-major)\nvoid print_matrix_padded(const char *name, const float *mat, int rows, int cols, int step);\n// addition\ntiny_error_t tiny_mat_add_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\ntiny_error_t tiny_mat_addc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n// subtraction\ntiny_error_t tiny_mat_sub_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\ntiny_error_t tiny_mat_subc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n// multiplication\ntiny_error_t tiny_mat_mult_f32(const float *A, const float *B, float *C, int m, int n, int k);\ntiny_error_t tiny_mat_mult_ex_f32(const float *A, const float *B, float *C, int A_rows, int A_cols, int B_cols, int A_padding, int B_padding, int C_padding);\ntiny_error_t tiny_mat_multc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_2","title":"\u5de5\u5177\u51fd\u6570","text":""},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_3","title":"\u6253\u5370\u77e9\u9635","text":"<pre><code>void print_matrix(const char *name, const float *mat, int rows, int cols);\n</code></pre> <p>\u51fd\u6570: \u4ee5\u884c\u4e3b\u5e8f\u6253\u5370\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>name</code>: \u77e9\u9635\u540d\u79f0\u3002</p> </li> <li> <p><code>mat</code>: \u77e9\u9635\u6570\u636e\u6307\u9488\u3002</p> </li> <li> <p><code>rows</code>: \u77e9\u9635\u884c\u6570\u3002</p> </li> <li> <p><code>cols</code>: \u77e9\u9635\u5217\u6570\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u65e0\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_4","title":"\u6253\u5370\u5e26\u586b\u5145\u7684\u77e9\u9635","text":"<pre><code>void print_matrix_padded(const char *name, const float *mat, int rows, int cols, int step);\n</code></pre> <p>\u51fd\u6570: \u4ee5\u884c\u4e3b\u5e8f\u6253\u5370\u5e26\u586b\u5145\u7684\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>name</code>: \u77e9\u9635\u540d\u79f0\u3002</p> </li> <li> <p><code>mat</code>: \u77e9\u9635\u6570\u636e\u6307\u9488\u3002</p> </li> <li> <p><code>rows</code>: \u77e9\u9635\u884c\u6570\u3002</p> </li> <li> <p><code>cols</code>: \u77e9\u9635\u5217\u6570\u3002</p> </li> <li> <p><code>step</code>: \u6b65\u957f\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u65e0\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_5","title":"\u77e9\u9635\u52a0\u6cd5","text":"<pre><code>tiny_error_t tiny_mat_add_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\n</code></pre> <p>\u51fd\u6570: \u77e9\u9635\u52a0\u6cd5\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>input1</code>: \u8f93\u5165\u77e9\u96351\u3002</p> </li> <li> <p><code>input2</code>: \u8f93\u5165\u77e9\u96352\u3002</p> </li> <li> <p><code>output</code>: \u8f93\u51fa\u77e9\u9635\u3002</p> </li> <li> <p><code>rows</code>: \u77e9\u9635\u884c\u6570\u3002</p> </li> <li> <p><code>cols</code>: \u77e9\u9635\u5217\u6570\u3002</p> </li> <li> <p><code>padd1</code>: \u8f93\u5165\u77e9\u96351\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>padd2</code>: \u8f93\u5165\u77e9\u96352\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>padd_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>step1</code>: \u8f93\u5165\u77e9\u96351\u7684\u6b65\u957f\u3002</p> </li> <li> <p><code>step2</code>: \u8f93\u5165\u77e9\u96352\u7684\u6b65\u957f\u3002</p> </li> <li> <p><code>step_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u9519\u8bef\u7801\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_6","title":"\u77e9\u9635\u52a0\u5e38\u6570","text":"<pre><code>tiny_error_t tiny_mat_addc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre> <p>\u51fd\u6570: \u77e9\u9635\u52a0\u5e38\u6570\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>input</code>: \u8f93\u5165\u77e9\u9635\u3002</p> </li> <li> <p><code>output</code>: \u8f93\u51fa\u77e9\u9635\u3002</p> </li> <li> <p><code>C</code>: \u5e38\u6570\u3002</p> </li> <li> <p><code>rows</code>: \u77e9\u9635\u884c\u6570\u3002</p> </li> <li> <p><code>cols</code>: \u77e9\u9635\u5217\u6570\u3002</p> </li> <li> <p><code>padd_in</code>: \u8f93\u5165\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>padd_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>step_in</code>: \u8f93\u5165\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> <li> <p><code>step_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u9519\u8bef\u7801\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_7","title":"\u77e9\u9635\u51cf\u6cd5","text":"<pre><code>tiny_error_t tiny_mat_sub_f32(const float *input1, const float *input2, float *output, int rows, int cols, int padd1, int padd2, int padd_out, int step1, int step2, int step_out);\n</code></pre> <p>\u51fd\u6570: \u77e9\u9635\u51cf\u6cd5\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>input1</code>: \u8f93\u5165\u77e9\u96351\u3002</p> </li> <li> <p><code>input2</code>: \u8f93\u5165\u77e9\u96352\u3002</p> </li> <li> <p><code>output</code>: \u8f93\u51fa\u77e9\u9635\u3002</p> </li> <li> <p><code>rows</code>: \u77e9\u9635\u884c\u6570\u3002</p> </li> <li> <p><code>cols</code>: \u77e9\u9635\u5217\u6570\u3002</p> </li> <li> <p><code>padd1</code>: \u8f93\u5165\u77e9\u96351\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>padd2</code>: \u8f93\u5165\u77e9\u96352\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>padd_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>step1</code>: \u8f93\u5165\u77e9\u96351\u7684\u6b65\u957f\u3002</p> </li> <li> <p><code>step2</code>: \u8f93\u5165\u77e9\u96352\u7684\u6b65\u957f\u3002</p> </li> <li> <p><code>step_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u9519\u8bef\u7801\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_8","title":"\u77e9\u9635\u51cf\u5e38\u6570","text":"<pre><code>tiny_error_t tiny_mat_subc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre> <p>\u51fd\u6570: \u77e9\u9635\u51cf\u5e38\u6570\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>input</code>: \u8f93\u5165\u77e9\u9635\u3002</p> </li> <li> <p><code>output</code>: \u8f93\u51fa\u77e9\u9635\u3002</p> </li> <li> <p><code>C</code>: \u5e38\u6570\u3002</p> </li> <li> <p><code>rows</code>: \u77e9\u9635\u884c\u6570\u3002</p> </li> <li> <p><code>cols</code>: \u77e9\u9635\u5217\u6570\u3002</p> </li> <li> <p><code>padd_in</code>: \u8f93\u5165\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>padd_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>step_in</code>: \u8f93\u5165\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> <li> <p><code>step_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u9519\u8bef\u7801\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_9","title":"\u77e9\u9635\u4e58\u6cd5","text":"<pre><code>tiny_error_t tiny_mat_mult_f32(const float *A, const float *B, float *C, int m, int n, int k);\n</code></pre> <p>\u51fd\u6570: \u77e9\u9635\u4e58\u6cd5\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>A</code>: \u8f93\u5165\u77e9\u9635A\u3002</p> </li> <li> <p><code>B</code>: \u8f93\u5165\u77e9\u9635B\u3002</p> </li> <li> <p><code>C</code>: \u8f93\u51fa\u77e9\u9635C\u3002</p> </li> <li> <p><code>m</code>: \u77e9\u9635A\u7684\u884c\u6570\u3002</p> </li> <li> <p><code>n</code>: \u77e9\u9635A\u7684\u5217\u6570\u3002</p> </li> <li> <p><code>k</code>: \u77e9\u9635B\u7684\u5217\u6570\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u9519\u8bef\u7801\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_10","title":"\u6269\u5c55\u77e9\u9635\u4e58\u6cd5","text":"<pre><code>tiny_error_t tiny_mat_mult_ex_f32(const float *A, const float *B, float *C, int A_rows, int A_cols, int B_cols, int A_padding, int B_padding, int C_padding);\n</code></pre> <p>\u51fd\u6570: \u6269\u5c55\u77e9\u9635\u4e58\u6cd5\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>A</code>: \u8f93\u5165\u77e9\u9635A\u3002</p> </li> <li> <p><code>B</code>: \u8f93\u5165\u77e9\u9635B\u3002</p> </li> <li> <p><code>C</code>: \u8f93\u51fa\u77e9\u9635C\u3002</p> </li> <li> <p><code>A_rows</code>: \u77e9\u9635A\u7684\u884c\u6570\u3002</p> </li> <li> <p><code>A_cols</code>: \u77e9\u9635A\u7684\u5217\u6570\u3002</p> </li> <li> <p><code>B_cols</code>: \u77e9\u9635B\u7684\u5217\u6570\u3002</p> </li> <li> <p><code>A_padding</code>: \u77e9\u9635A\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>B_padding</code>: \u77e9\u9635B\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>C_padding</code>: \u77e9\u9635C\u7684\u586b\u5145\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u9519\u8bef\u7801\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-api/#_11","title":"\u77e9\u9635\u4e58\u5e38\u6570","text":"<pre><code>tiny_error_t tiny_mat_multc_f32(const float *input, float *output, float C, int rows, int cols, int padd_in, int padd_out, int step_in, int step_out);\n</code></pre> <p>\u51fd\u6570: \u77e9\u9635\u4e58\u5e38\u6570\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>input</code>: \u8f93\u5165\u77e9\u9635\u3002</p> </li> <li> <p><code>output</code>: \u8f93\u51fa\u77e9\u9635\u3002</p> </li> <li> <p><code>C</code>: \u5e38\u6570\u3002</p> </li> <li> <p><code>rows</code>: \u77e9\u9635\u884c\u6570\u3002</p> </li> <li> <p><code>cols</code>: \u77e9\u9635\u5217\u6570\u3002</p> </li> <li> <p><code>padd_in</code>: \u8f93\u5165\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>padd_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u586b\u5145\u3002</p> </li> <li> <p><code>step_in</code>: \u8f93\u5165\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> <li> <p><code>step_out</code>: \u8f93\u51fa\u77e9\u9635\u7684\u6b65\u957f\u3002</p> </li> </ul> <p>\u8fd4\u56de: \u9519\u8bef\u7801\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-mat-code/","title":"\u4ee3\u7801","text":""},{"location":"zh/MATH/MATRIX/tiny-mat-test/","title":"TINY_MAT \u6d4b\u8bd5","text":""},{"location":"zh/MATH/MATRIX/tiny-mat-test/#_1","title":"\u6d4b\u8bd5\u4ee3\u7801","text":""},{"location":"zh/MATH/MATRIX/tiny-mat-test/#_2","title":"\u6d4b\u8bd5\u7ed3\u679c","text":"<pre><code>============ [tiny_mat_test - Full Coverage] ============\n[TEST SETTINGS] ROWS=2, COLS=3, PAD=1, FULL_WIDTH=4\nA (padded) | memory layout =\n  1.000000   2.000000   3.000000   0.000000 \n  4.000000   5.000000   6.000000   0.000000 \n\nB (padded) | memory layout =\n  7.000000   8.000000   9.000000   0.000000 \n 10.000000  11.000000  12.000000   0.000000 \n 13.000000  14.000000  15.000000   0.000000 \n\nA_compact =\n  1.000000   2.000000   3.000000 \n  2.000000   3.000000   4.000000 \n\nB_compact =\n  7.000000   8.000000   9.000000 \n  8.000000   9.000000  10.000000 \n  9.000000  10.000000  11.000000 \n\nconstant = 2.000000\n\n--- tiny_mat_add_f32(rows=2, cols=3, paddings=1) | Time:  18.00 us | Error: 0 ---\nOutput (padded) =\n  8.000000  10.000000  12.000000 \n 14.000000  16.000000  18.000000 \n\n--- tiny_mat_addc_f32(C=2.000000) | Time:  10.00 us | Error: 0 ---\nOutput (padded) =\n  3.000000   4.000000   5.000000 \n  6.000000   7.000000   8.000000 \n\n--- tiny_mat_sub_f32(rows=2, cols=3) | Time:  13.00 us | Error: 0 ---\nOutput (padded) =\n -6.000000  -6.000000  -6.000000 \n -6.000000  -6.000000  -6.000000 \n\n--- tiny_mat_subc_f32(C=2.000000) | Time:   7.00 us | Error: 0 ---\nOutput (padded) =\n -1.000000   0.000000   1.000000 \n  2.000000   3.000000   4.000000 \n\n--- tiny_mat_multc_f32(C=2.000000) | Time:   8.00 us | Error: 0 ---\nOutput (padded) =\n  2.000000   4.000000   6.000000 \n  8.000000  10.000000  12.000000 \n\n--- tiny_mat_mult_f32 (compact) | Time:  10.00 us | Error: 0 ---\nOutput (compact) =\n 66.000000  72.000000  78.000000 \n 72.000000  78.000000 156.000000 \n\n--- tiny_mat_mult_ex_f32(padded) | Time:  13.00 us | Error: 0 ---\nOutput (padded) =\n 66.000000  72.000000  78.000000 \n156.000000 171.000000 186.000000 \n\n============ [test complete] ============\n</code></pre>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/","title":"\u77e9\u9635\u64cd\u4f5c - TINY_MATRIX","text":"<p>TINY_MATRIX\u5e93</p> <ul> <li>\u8be5\u5e93\u662f\u4e00\u4e2a\u8f7b\u91cf\u7ea7\u7684\u77e9\u9635\u8fd0\u7b97\u5e93\uff0c\u57fa\u4e8eC++\u5b9e\u73b0\uff0c\u63d0\u4f9b\u4e86\u57fa\u672c\u7684\u77e9\u9635\u64cd\u4f5c\u548c\u7ebf\u6027\u4ee3\u6570\u529f\u80fd\u3002</li> <li>\u8be5\u5e93\u7684\u8bbe\u8ba1\u76ee\u6807\u662f\u63d0\u4f9b\u7b80\u5355\u6613\u7528\u7684\u77e9\u9635\u64cd\u4f5c\u63a5\u53e3\uff0c\u9002\u5408\u4e8e\u5d4c\u5165\u5f0f\u7cfb\u7edf\u548c\u8d44\u6e90\u53d7\u9650\u7684\u73af\u5883\u3002</li> </ul> <p>\u4f7f\u7528\u573a\u666f</p> <p>\u76f8\u5bf9\u4e8eTINY_MAT\u5e93\u800c\u8a00\uff0cTINY_MATRIX\u5e93\u63d0\u4f9b\u4e86\u66f4\u4e30\u5bcc\u7684\u529f\u80fd\u548c\u66f4\u9ad8\u7684\u7075\u6d3b\u6027\uff0c\u9002\u5408\u4e8e\u9700\u8981\u8fdb\u884c\u590d\u6742\u77e9\u9635\u8fd0\u7b97\u7684\u5e94\u7528\u573a\u666f\u3002\u4f46\u662f\u8bf7\u6ce8\u610f\uff0c\u8be5\u5e93\u57fa\u4e8eC++\u7f16\u5199\uff0c</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_1","title":"\u76ee\u5f55","text":"<pre><code>TinyMath\n    \u251c\u2500\u2500Vector\n    \u2514\u2500\u2500Matrix\n        \u251c\u2500\u2500 tiny_mat (c)\n        \u2514\u2500\u2500 tiny_matrix (c++) &lt;---\n</code></pre> <pre><code>namespace tiny\n{\n    class Mat\n    {\n    public:\n        /* === Matrix Metadata === */\n        int row;         //&lt; number of rows\n        int col;         //&lt; number of columns\n        int pad;         //&lt; number of paddings between 2 rows\n        int stride;      //&lt; stride = (number of elements in a row) + padding\n        int element;     //&lt; number of elements = rows * cols\n        int memory;      //&lt; size of the data buffer = rows * stride\n        float *data;     //&lt; pointer to the data buffer\n        float *temp;     //&lt; pointer to the temporary data buffer\n        bool ext_buff;   //&lt; flag indicates that matrix use external buffer\n        bool sub_matrix; //&lt; flag indicates that matrix is a subset of another matrix\n\n        /* === Rectangular ROI Structure === */\n        /**\n         * @name Region of Interest (ROI) Structure\n         * @brief This is the structure for ROI\n         * \n         */\n        struct ROI\n        {\n            int pos_x;  ///&lt; starting column index\n            int pos_y;  ///&lt; starting row index\n            int width;  ///&lt; width of ROI (columns)\n            int height; ///&lt; height of ROI (rows)\n\n            // ROI constructor\n            ROI(int pos_x = 0, int pos_y = 0, int width = 0, int height = 0);\n\n            // resize ROI\n            void resize_roi(int pos_x, int pos_y, int width, int height);\n\n            // calculate area of ROI\n            int area_roi(void) const;\n        };\n\n        /* === Printing Functions === */\n        // print matrix info\n        void print_info() const;\n\n        // print matrix elements, paddings optional\n        void print_matrix(bool show_padding);\n\n        /* === Constructors &amp; Destructor === */\n        // memory allocation\n        void alloc_mem(); // Allocate internal memory\n\n        // constructor\n        Mat();\n        Mat(int rows, int cols);\n        Mat(int rows, int cols, int stride);\n        Mat(float *data, int rows, int cols);\n        Mat(float *data, int rows, int cols, int stride);\n        Mat(const Mat &amp;src);\n\n        // destructor\n        ~Mat();\n\n        /* === Element Access === */\n        // access matrix elements - non const\n        inline float &amp;operator()(int row, int col) { return data[row * stride + col]; }\n\n        // access matrix elements - const             \n        inline const float &amp;operator()(int row, int col) const { return data[row * stride + col]; }\n\n        /* === Data Manipulation === */\n        // copy other matrix into this matrix as a sub-matrix\n        tiny_error_t copy_paste(const Mat &amp;src, int row_pos, int col_pos);\n\n        // copy header of other matrix to this matrix\n        tiny_error_t copy_head(const Mat &amp;src);\n\n        // get a view (shallow copy) of sub-matrix (ROI) from this matrix\n        Mat view_roi(int start_row, int start_col, int roi_rows, int roi_cols) const;\n\n        // get a view (shallow copy) of sub-matrix (ROI) from this matrix using ROI structure\n        Mat view_roi(const Mat::ROI &amp;roi) const;\n\n        // get a replica (deep copy) of sub-matrix (ROI) \n        Mat copy_roi(int start_row, int start_col, int roi_rows, int roi_cols);\n\n        // get a replica (deep copy) of sub-matrix (ROI) using ROI structure\n        Mat copy_roi(const Mat::ROI &amp;roi);\n\n        // get a block of matrix\n        Mat block(int start_row, int start_col, int block_rows, int block_cols);\n\n        // swap rows\n        void swap_rows(int row1, int row2);\n\n        // clear matrix\n        void clear(void);\n\n        /* === Arithmetic Operators === */\n        Mat &amp;operator=(const Mat &amp;src);    // Copy assignment\n        Mat &amp;operator+=(const Mat &amp;A);     // Add matrix\n        Mat &amp;operator+=(float C);          // Add constant\n        Mat &amp;operator-=(const Mat &amp;A);     // Subtract matrix\n        Mat &amp;operator-=(float C);          // Subtract constant \n        Mat &amp;operator*=(const Mat &amp;A);     // Multiply matrix\n        Mat &amp;operator*=(float C);          // Multiply constant\n        Mat &amp;operator/=(const Mat &amp;B);     // Divide matrix\n        Mat &amp;operator/=(float C);          // Divide constant\n        Mat operator^(int C);              // Exponentiation\n\n        /* === Linear Algebra === */\n        Mat transpose();                   // Transpose matrix\n        Mat cofactor(int row, int col);    // cofactor matrix extraction\n        float determinant();\n        Mat adjoint(); \n        void normalize();\n        float norm() const;\n        Mat inverse_adjoint();\n        static Mat eye(int size);\n        static Mat augment(const Mat &amp;A, const Mat &amp;B);\n        static Mat ones(int rows, int cols);\n        static Mat ones(int size);\n        Mat gaussian_eliminate() const;\n        Mat row_reduce_from_gaussian();\n        Mat inverse_gje(); // Inverse using Gaussian-Jordan elimination\n        float dotprod(const Mat &amp;A, const Mat &amp;B);\n        Mat solve(const Mat &amp;A, const Mat &amp;b);\n        Mat band_solve(Mat A, Mat b, int k);\n        Mat roots(Mat A, Mat y);\n\n    protected:\n\n    private:\n\n    };\n\n    /* === Stream Operators === */\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat &amp;m);\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat::ROI &amp;roi);\n    std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Mat &amp;m);\n\n    /* === Global Arithmetic Operators === */\n    Mat operator+(const Mat &amp;A, const Mat &amp;B);\n    Mat operator+(const Mat &amp;A, float C);\n    Mat operator-(const Mat &amp;A, const Mat &amp;B);\n    Mat operator-(const Mat &amp;A, float C);\n    Mat operator*(const Mat &amp;A, const Mat &amp;B);\n    Mat operator*(const Mat &amp;A, float C);\n    Mat operator*(float C, const Mat &amp;A);\n    Mat operator/(const Mat &amp;A, float C);\n    Mat operator/(const Mat &amp;A, const Mat &amp;B);\n    bool operator==(const Mat &amp;A, const Mat &amp;B);\n\n}\n</code></pre>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_2","title":"\u5143\u6570\u636e","text":"<ul> <li> <p><code>int row</code>: \u884c\u6570</p> </li> <li> <p><code>int col</code>: \u5217\u6570</p> </li> <li> <p><code>int pad</code>: \u884c\u95f4\u586b\u5145\u6570</p> </li> <li> <p><code>int stride</code>: \u884c\u5185\u5143\u7d20\u6570 + \u586b\u5145\u6570</p> </li> <li> <p><code>int element</code>: \u5143\u7d20\u6570</p> </li> <li> <p><code>int memory</code>: \u6570\u636e\u7f13\u51b2\u533a\u5927\u5c0f = \u884c\u6570 * \u6b65\u5e45</p> </li> <li> <p><code>float *data</code>: \u6570\u636e\u7f13\u51b2\u533a\u6307\u9488</p> </li> <li> <p><code>float *temp</code>: \u4e34\u65f6\u6570\u636e\u7f13\u51b2\u533a\u6307\u9488</p> </li> <li> <p><code>bool ext_buff</code>: \u6807\u5fd7\u77e9\u9635\u662f\u5426\u4f7f\u7528\u5916\u90e8\u7f13\u51b2\u533a</p> </li> <li> <p><code>bool sub_matrix</code>: \u6807\u5fd7\u77e9\u9635\u662f\u5426\u4e3a\u53e6\u4e00\u4e2a\u77e9\u9635\u7684\u5b50\u96c6</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#roi","title":"ROI \u7ed3\u6784","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_3","title":"\u5143\u6570\u636e","text":"<ul> <li> <p><code>int pos_x</code>: \u8d77\u59cb\u5217\u7d22\u5f15</p> </li> <li> <p><code>int pos_y</code>: \u8d77\u59cb\u884c\u7d22\u5f15</p> </li> <li> <p><code>int width</code>: ROI \u7684\u5bbd\u5ea6\uff08\u5217\u6570\uff09</p> </li> <li> <p><code>int height</code>: ROI \u7684\u9ad8\u5ea6\uff08\u884c\u6570\uff09</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#roi_1","title":"ROI \u6784\u9020\u51fd\u6570","text":"<pre><code>Mat::ROI::ROI(int pos_x = 0, int pos_y = 0, int width = 0, int height = 0);\n</code></pre> <p>\u63cf\u8ff0: \u6784\u9020\u4e00\u4e2a ROI \u5bf9\u8c61\uff0c\u9ed8\u8ba4\u503c\u4e3a (0, 0, 0, 0)\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>int pos_x</code>: \u8d77\u59cb\u5217\u7d22\u5f15</p> </li> <li> <p><code>int pos_y</code>: \u8d77\u59cb\u884c\u7d22\u5f15</p> </li> <li> <p><code>int width</code>: ROI \u7684\u5bbd\u5ea6\uff08\u5217\u6570\uff09</p> </li> <li> <p><code>int height</code>: ROI \u7684\u9ad8\u5ea6\uff08\u884c\u6570\uff09</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#roi_2","title":"ROI \u91cd\u7f6e\u51fd\u6570","text":"<pre><code>void Mat::ROI::resize_roi(int pos_x, int pos_y, int width, int height);\n</code></pre> <p>\u63cf\u8ff0: \u91cd\u7f6e ROI \u7684\u4f4d\u7f6e\u548c\u5927\u5c0f\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>int pos_x</code>: \u8d77\u59cb\u5217\u7d22\u5f15</p> </li> <li> <p><code>int pos_y</code>: \u8d77\u59cb\u884c\u7d22\u5f15</p> </li> <li> <p><code>int width</code>: ROI \u7684\u5bbd\u5ea6\uff08\u5217\u6570\uff09</p> </li> <li> <p><code>int height</code>: ROI \u7684\u9ad8\u5ea6\uff08\u884c\u6570\uff09</p> </li> </ul> <p>\u8fd4\u56de\u503c: void</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#roi_3","title":"ROI \u9762\u79ef\u51fd\u6570","text":"<pre><code>int Mat::ROI::area_roi(void) const;\n</code></pre> <p>\u63cf\u8ff0: \u8ba1\u7b97 ROI \u7684\u9762\u79ef\u3002</p> <p>\u53c2\u6570: void</p> <p>\u8fd4\u56de\u503c: \u6574\u6570\u7c7b\u578b ROI \u7684\u9762\u79ef</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_4","title":"\u6253\u5370\u51fd\u6570","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_5","title":"\u6253\u5370\u77e9\u9635\u4fe1\u606f","text":"<pre><code>void Mat::print_info() const\n</code></pre> <p>\u63cf\u8ff0: \u6253\u5370\u77e9\u9635\u7684\u57fa\u672c\u4fe1\u606f\uff0c\u5305\u62ec\u884c\u6570\u3001\u5217\u6570\u3001\u5143\u7d20\u6570\u3001\u586b\u5145\u6570\u3001\u6b65\u5e45\u6570\u3001\u5185\u5b58\u5927\u5c0f\u3001\u6570\u636e\u7f13\u51b2\u533a\u6307\u9488\u3001\u4e34\u65f6\u6570\u636e\u7f13\u51b2\u533a\u6307\u9488\u3001\u5916\u90e8\u7f13\u51b2\u533a\u6807\u5fd7\u3001\u5b50\u77e9\u9635\u6807\u5fd7\u3002</p> <p>\u53c2\u6570: void</p> <p>\u8fd4\u56de\u503c: void</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_6","title":"\u6253\u5370\u77e9\u9635\u5143\u7d20","text":"<pre><code>void Mat::print_matrix(bool show_padding);\n</code></pre> <p>\u63cf\u8ff0: \u6253\u5370\u77e9\u9635\u7684\u5143\u7d20\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>bool show_padding</code>: \u662f\u5426\u663e\u793a\u586b\u5145\u533a\u5143\u7d20\uff0c true \u663e\u793a\uff0cfalse \u4e0d\u663e\u793a</li> </ul> <p>\u8fd4\u56de\u503c: void</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_7","title":"\u6784\u9020\u4e0e\u6790\u6784\u51fd\u6570","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_8","title":"\u9ed8\u8ba4\u6784\u9020\u51fd\u6570","text":"<pre><code>Mat::Mat();\n</code></pre> <p>\u63cf\u8ff0: \u9ed8\u8ba4\u6784\u9020\u51fd\u6570\u5c06\u4f7f\u7528\u9ed8\u8ba4\u503c\u521d\u59cb\u5316\u4e00\u4e2a\u77e9\u9635\u5bf9\u8c61\u3002\u8fd9\u4e2a\u51fd\u6570\u4f1a\u521b\u5efa\u4e00\u4e2a\u4e00\u884c\u4e00\u5217\u7684\u77e9\u9635\uff0c\u552f\u4e00\u7684\u5143\u7d20\u662f0\u3002</p> <p>\u53c2\u6570: void</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-matint-rows-int-cols","title":"\u6784\u9020\u51fd\u6570 - Mat(int rows, int cols)","text":"<pre><code>Mat::Mat(int rows, int cols);\n</code></pre> <p>\u63cf\u8ff0: \u6784\u9020\u4e00\u4e2a\u6307\u5b9a\u884c\u6570\u548c\u5217\u6570\u7684\u77e9\u9635\u5bf9\u8c61\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>int rows</code>: \u884c\u6570</p> </li> <li> <p><code>int cols</code>: \u5217\u6570</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-matint-rows-int-cols-int-stride","title":"\u6784\u9020\u51fd\u6570 - Mat(int rows, int cols, int stride)","text":"<pre><code>Mat::Mat(int rows, int cols, int stride);\n</code></pre> <p>\u63cf\u8ff0: \u6784\u9020\u4e00\u4e2a\u6307\u5b9a\u884c\u6570\u3001\u5217\u6570\u548c\u6b65\u5e45\u7684\u77e9\u9635\u5bf9\u8c61\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>int rows</code>: \u884c\u6570</p> </li> <li> <p><code>int cols</code>: \u5217\u6570</p> </li> <li> <p><code>int stride</code>: \u6b65\u5e45</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-matfloat-data-int-rows-int-cols","title":"\u6784\u9020\u51fd\u6570 - Mat(float *data, int rows, int cols)","text":"<pre><code>Mat::Mat(float *data, int rows, int cols);\n</code></pre> <p>\u63cf\u8ff0: \u6784\u9020\u4e00\u4e2a\u6307\u5b9a\u884c\u6570\u548c\u5217\u6570\u7684\u77e9\u9635\u5bf9\u8c61\uff0c\u5e76\u4f7f\u7528\u7ed9\u5b9a\u7684\u6570\u636e\u7f13\u51b2\u533a\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>float *data</code>: \u6570\u636e\u7f13\u51b2\u533a\u6307\u9488</p> </li> <li> <p><code>int rows</code>: \u884c\u6570</p> </li> <li> <p><code>int cols</code>: \u5217\u6570</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-matfloat-data-int-rows-int-cols-int-stride","title":"\u6784\u9020\u51fd\u6570 - Mat(float *data, int rows, int cols, int stride)","text":"<pre><code>Mat::Mat(float *data, int rows, int cols, int stride);\n</code></pre> <p>\u63cf\u8ff0: \u6784\u9020\u4e00\u4e2a\u6307\u5b9a\u884c\u6570\u3001\u5217\u6570\u548c\u6b65\u5e45\u7684\u77e9\u9635\u5bf9\u8c61\uff0c\u5e76\u4f7f\u7528\u7ed9\u5b9a\u7684\u6570\u636e\u7f13\u51b2\u533a\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>float *data</code>: \u6570\u636e\u7f13\u51b2\u533a\u6307\u9488</p> </li> <li> <p><code>int rows</code>: \u884c\u6570</p> </li> <li> <p><code>int cols</code>: \u5217\u6570</p> </li> <li> <p><code>int stride</code>: \u6b65\u5e45</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-matconst-mat-src","title":"\u6784\u9020\u51fd\u6570 - Mat(const Mat &amp;src)","text":"<pre><code>Mat::Mat(const Mat &amp;src);\n</code></pre> <p>\u63cf\u8ff0: \u6784\u9020\u4e00\u4e2a\u77e9\u9635\u5bf9\u8c61\uff0c\u5e76\u4f7f\u7528\u7ed9\u5b9a\u7684\u77e9\u9635\u5bf9\u8c61\u7684\u5934\u90e8\u4fe1\u606f\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>const Mat &amp;src</code>: \u6e90\u77e9\u9635\u5bf9\u8c61</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_9","title":"\u6790\u6784\u51fd\u6570","text":"<pre><code>Mat::~Mat();\n</code></pre> <p>\u63cf\u8ff0: \u6790\u6784\u51fd\u6570\u91ca\u653e\u77e9\u9635\u5bf9\u8c61\u7684\u5185\u5b58\u3002</p> <p>\u53c2\u6570: void</p> <p>Note</p> <p>\u5bf9\u4e8e\u6784\u9020\u51fd\u6570\uff0c\u5176\u540d\u79f0\u5fc5\u987b\u4e0e\u7c7b\u540d\u76f8\u540c\uff0c\u5e76\u4e14\u4e0d\u80fd\u6709\u8fd4\u56de\u7c7b\u578b\u3002\u5982\u4e0a\u6240\u8ff0\uff0c\u5bf9\u4e8e C++\uff0c\u53ea\u8981\u53c2\u6570\u7684\u6392\u5217\u987a\u5e8f\u4e0d\u540c\uff0c\u5c31\u53ef\u4ee5\u901a\u8fc7\u66f4\u6539\u53c2\u6570\u7684\u6570\u91cf\u548c\u987a\u5e8f\u6765\u91cd\u65b0\u52a0\u8f7d\u51fd\u6570\u540d\u79f0\u3002\u5f53\u5bf9\u8c61\u8d85\u51fa\u8303\u56f4\u65f6\uff0c\u6790\u6784\u51fd\u6570\u5c06\u81ea\u52a8\u8c03\u7528\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_10","title":"\u5143\u7d20\u8bbf\u95ee","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_11","title":"\u975e\u5e38\u91cf\u8bbf\u95ee","text":"<pre><code>inline float &amp;operator()(int row, int col);\n</code></pre> <p>\u63cf\u8ff0: \u8bbf\u95ee\u77e9\u9635\u5143\u7d20\uff0c\u8fd4\u56de\u5bf9\u6307\u5b9a\u884c\u548c\u5217\u7684\u5f15\u7528\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>int row</code>: \u884c\u7d22\u5f15</p> </li> <li> <p><code>int col</code>: \u5217\u7d22\u5f15</p> </li> </ul> <p>\u8fd4\u56de\u503c: \u5bf9\u5e94\u4f4d\u7f6e\u7684\u5143\u7d20 float\u7c7b\u578b</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_12","title":"\u5e38\u91cf\u8bbf\u95ee","text":"<pre><code>inline const float &amp;operator()(int row, int col) const;\n</code></pre> <p>\u63cf\u8ff0: \u8bbf\u95ee\u77e9\u9635\u5143\u7d20\uff0c\u8fd4\u56de\u5bf9\u6307\u5b9a\u884c\u548c\u5217\u7684\u5e38\u91cf\u5f15\u7528\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>int row</code>: \u884c\u7d22\u5f15</p> </li> <li> <p><code>int col</code>: \u5217\u7d22\u5f15</p> </li> </ul> <p>\u8fd4\u56de\u503c: \u5bf9\u5e94\u4f4d\u7f6e\u7684\u5143\u7d20 float\u7c7b\u578b</p> <p>\u6ce8\u610f</p> <p>\u8fd9\u4e24\u4e2a\u51fd\u6570\u5b9e\u9645\u4e0a\u662f\u91cd\u65b0\u5b9a\u4e49\u4e86 <code>()</code> \u8fd0\u7b97\u7b26\uff0c\u5b83\u5141\u8bb8\u4f60\u4f7f\u7528 <code>matrix(row, col)</code> \u8bed\u6cd5\u8bbf\u95ee\u77e9\u9635\u7684\u5143\u7d20\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_13","title":"\u6570\u636e\u64cd\u4f5c","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_14","title":"\u590d\u5236\u5176\u4ed6\u77e9\u9635\u5230\u5f53\u524d\u77e9\u9635","text":"<pre><code>tiny_error_t copy_paste(const Mat &amp;src, int row_pos, int col_pos);\n</code></pre> <p>\u63cf\u8ff0: \u5c06\u6e90\u77e9\u9635\u7684\u5143\u7d20\u590d\u5236\u5230\u5f53\u524d\u77e9\u9635\u7684\u6307\u5b9a\u4f4d\u7f6e\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>const Mat &amp;src</code>: \u6e90\u77e9\u9635\u5bf9\u8c61</p> </li> <li> <p><code>int row_pos</code>: \u76ee\u6807\u77e9\u9635\u7684\u8d77\u59cb\u884c\u7d22\u5f15</p> </li> <li> <p><code>int col_pos</code>: \u76ee\u6807\u77e9\u9635\u7684\u8d77\u59cb\u5217\u7d22\u5f15</p> </li> </ul> <p>\u8fd4\u56de\u503c: \u9519\u8bef\u4ee3\u7801</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_15","title":"\u590d\u5236\u77e9\u9635\u5934\u90e8","text":"<pre><code>tiny_error_t copy_head(const Mat &amp;src);\n</code></pre> <p>\u63cf\u8ff0: \u5c06\u6e90\u77e9\u9635\u7684\u5934\u90e8\u4fe1\u606f\u590d\u5236\u5230\u5f53\u524d\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>const Mat &amp;src</code>: \u6e90\u77e9\u9635\u5bf9\u8c61</li> </ul> <p>\u8fd4\u56de\u503c: \u9519\u8bef\u4ee3\u7801</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_16","title":"\u83b7\u53d6\u5b50\u77e9\u9635\u89c6\u56fe","text":"<pre><code>Mat view_roi(int start_row, int start_col, int roi_rows, int roi_cols) const;\n</code></pre> <p>\u63cf\u8ff0: \u83b7\u53d6\u5f53\u524d\u77e9\u9635\u7684\u5b50\u77e9\u9635\u89c6\u56fe\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>int start_row</code>: \u8d77\u59cb\u884c\u7d22\u5f15</p> </li> <li> <p><code>int start_col</code>: \u8d77\u59cb\u5217\u7d22\u5f15</p> </li> <li> <p><code>int roi_rows</code>: \u5b50\u77e9\u9635\u7684\u884c\u6570</p> </li> <li> <p><code>int roi_cols</code>: \u5b50\u77e9\u9635\u7684\u5217\u6570</p> </li> </ul> <p>\u8fd4\u56de\u503c: \u5b50\u77e9\u9635\u5bf9\u8c61</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-roi","title":"\u83b7\u53d6\u5b50\u77e9\u9635\u89c6\u56fe - \u4f7f\u7528 ROI \u7ed3\u6784","text":"<pre><code>Mat view_roi(const Mat::ROI &amp;roi) const;\n</code></pre> <p>\u63cf\u8ff0: \u83b7\u53d6\u5f53\u524d\u77e9\u9635\u7684\u5b50\u77e9\u9635\u89c6\u56fe\uff0c\u4f7f\u7528 ROI \u7ed3\u6784\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>const Mat::ROI &amp;roi</code>: ROI \u7ed3\u6784\u5bf9\u8c61</li> </ul> <p>\u8fd4\u56de\u503c: \u5b50\u77e9\u9635\u5bf9\u8c61</p> <p>\u8b66\u544a</p> <p>\u4e0e ESP-DSP \u4e0d\u540c\uff0cview_roi \u4e0d\u5141\u8bb8\u8bbe\u7f6e\u6b65\u957f\uff0c\u56e0\u4e3a\u5b83\u4f1a\u6839\u636e\u5217\u6570\u548c\u586b\u5145\u6570\u81ea\u52a8\u8ba1\u7b97\u6b65\u957f\u3002\u8be5\u51fd\u6570\u8fd8\u4f1a\u62d2\u7edd\u975e\u6cd5\u8bf7\u6c42\uff0c\u5373\u8d85\u51fa\u8303\u56f4\u7684\u8bf7\u6c42\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_17","title":"\u83b7\u53d6\u5b50\u77e9\u9635\u526f\u672c","text":"<pre><code>Mat copy_roi(int start_row, int start_col, int roi_rows, int roi_cols);\n</code></pre> <p>\u63cf\u8ff0: \u83b7\u53d6\u5f53\u524d\u77e9\u9635\u7684\u5b50\u77e9\u9635\u526f\u672c\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>int start_row</code>: \u8d77\u59cb\u884c\u7d22\u5f15</p> </li> <li> <p><code>int start_col</code>: \u8d77\u59cb\u5217\u7d22\u5f15</p> </li> <li> <p><code>int roi_rows</code>: \u5b50\u77e9\u9635\u7684\u884c\u6570</p> </li> <li> <p><code>int roi_cols</code>: \u5b50\u77e9\u9635\u7684\u5217\u6570</p> </li> </ul> <p>\u8fd4\u56de\u503c: \u5b50\u77e9\u9635\u5bf9\u8c61</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-roi_1","title":"\u83b7\u53d6\u5b50\u77e9\u9635\u526f\u672c - \u4f7f\u7528 ROI \u7ed3\u6784","text":"<pre><code>Mat copy_roi(const Mat::ROI &amp;roi);\n</code></pre> <p>\u63cf\u8ff0: \u83b7\u53d6\u5f53\u524d\u77e9\u9635\u7684\u5b50\u77e9\u9635\u526f\u672c\uff0c\u4f7f\u7528 ROI \u7ed3\u6784\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>const Mat::ROI &amp;roi</code>: ROI \u7ed3\u6784\u5bf9\u8c61</li> </ul> <p>\u8fd4\u56de\u503c: \u5b50\u77e9\u9635\u5bf9\u8c61</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_18","title":"\u83b7\u53d6\u77e9\u9635\u5757","text":"<pre><code>Mat block(int start_row, int start_col, int block_rows, int block_cols);\n</code></pre> <p>\u63cf\u8ff0: \u83b7\u53d6\u5f53\u524d\u77e9\u9635\u7684\u5757\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>int start_row</code>: \u8d77\u59cb\u884c\u7d22\u5f15</p> </li> <li> <p><code>int start_col</code>: \u8d77\u59cb\u5217\u7d22\u5f15</p> </li> <li> <p><code>int block_rows</code>: \u5757\u7684\u884c\u6570</p> </li> <li> <p><code>int block_cols</code>: \u5757\u7684\u5217\u6570</p> </li> </ul> <p>\u8fd4\u56de\u503c: \u5757\u5bf9\u8c61</p> <p>!!! tip \u201cview_roi | copy_roi | block \u4e4b\u95f4\u7684\u533a\u522b\u201d</p> <ul> <li> <p><code>view_roi</code>\uff1a\u4ece\u8be5\u77e9\u9635\u6d45\u62f7\u8d1d\u5b50\u77e9\u9635 (ROI)\u3002</p> </li> <li> <p><code>copy_roi</code>\uff1a\u4ece\u8be5\u77e9\u9635\u6df1\u62f7\u8d1d\u5b50\u77e9\u9635 (ROI)\u3002\u521a\u6027\u62f7\u8d1d\uff0c\u901f\u5ea6\u66f4\u5feb\u3002</p> </li> <li> <p><code>block</code>\uff1a\u4ece\u8be5\u77e9\u9635\u6df1\u62f7\u8d1d\u5757\u3002\u67d4\u6027\u62f7\u8d1d\uff0c\u901f\u5ea6\u66f4\u6162\u3002</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_19","title":"\u4ea4\u6362\u884c","text":"<pre><code>void swap_rows(int row1, int row2);\n</code></pre> <p>\u63cf\u8ff0: \u4ea4\u6362\u5f53\u524d\u77e9\u9635\u7684\u4e24\u884c\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>int row1</code>: \u7b2c\u4e00\u884c\u7d22\u5f15</p> </li> <li> <p><code>int row2</code>: \u7b2c\u4e8c\u884c\u7d22\u5f15</p> </li> </ul> <p>\u8fd4\u56de\u503c: void</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_20","title":"\u6e05\u9664\u77e9\u9635","text":"<pre><code>void clear(void);\n</code></pre> <p>\u63cf\u8ff0: \u6e05\u9664\u5f53\u524d\u77e9\u9635\u7684\u5143\u7d20\u3002</p> <p>\u53c2\u6570: void</p> <p>\u8fd4\u56de\u503c: void</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_21","title":"\u7b97\u672f\u8fd0\u7b97\u7b26","text":"<p>\u6ce8\u610f</p> <p>\u672c\u8282\u5b9a\u4e49\u4e86\u4f5c\u7528\u4e8e\u5f53\u524d\u77e9\u9635\u672c\u8eab\u7684\u7b97\u672f\u8fd0\u7b97\u7b26\u3002\u8fd9\u4e9b\u8fd0\u7b97\u7b26\u5df2\u88ab\u91cd\u8f7d\u4ee5\u6267\u884c\u77e9\u9635\u8fd0\u7b97\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_22","title":"\u8d4b\u503c\u8fd0\u7b97\u7b26","text":"<pre><code>Mat &amp;operator=(const Mat &amp;src);\n</code></pre> <p>\u63cf\u8ff0: \u8d4b\u503c\u8fd0\u7b97\u7b26\uff0c\u5c06\u6e90\u77e9\u9635\u7684\u5143\u7d20\u590d\u5236\u5230\u5f53\u524d\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>const Mat &amp;src</code>: \u6e90\u77e9\u9635\u5bf9\u8c61</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_23","title":"\u52a0\u6cd5\u8fd0\u7b97\u7b26","text":"<pre><code>Mat &amp;operator+=(const Mat &amp;A);\n</code></pre> <p>\u63cf\u8ff0: \u52a0\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u6e90\u77e9\u9635\u7684\u5143\u7d20\u52a0\u5230\u5f53\u524d\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>const Mat &amp;A</code>: \u6e90\u77e9\u9635\u5bf9\u8c61</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-","title":"\u52a0\u6cd5\u8fd0\u7b97\u7b26 - \u5e38\u91cf","text":"<pre><code>Mat &amp;operator+=(float C);\n</code></pre> <p>\u63cf\u8ff0: \u52a0\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u5e38\u91cf\u52a0\u5230\u5f53\u524d\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>float C</code>: \u5e38\u91cf</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_24","title":"\u51cf\u6cd5\u8fd0\u7b97\u7b26","text":"<pre><code>Mat &amp;operator-=(const Mat &amp;A);\n</code></pre> <p>\u63cf\u8ff0: \u51cf\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u6e90\u77e9\u9635\u7684\u5143\u7d20\u4ece\u5f53\u524d\u77e9\u9635\u4e2d\u51cf\u53bb\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>const Mat &amp;A</code>: \u6e90\u77e9\u9635\u5bf9\u8c61</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-_1","title":"\u51cf\u6cd5\u8fd0\u7b97\u7b26 - \u5e38\u91cf","text":"<pre><code>Mat &amp;operator-=(float C);\n</code></pre> <p>\u63cf\u8ff0: \u51cf\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u5e38\u91cf\u4ece\u5f53\u524d\u77e9\u9635\u4e2d\u51cf\u53bb\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>float C</code>: \u5e38\u91cf</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_25","title":"\u4e58\u6cd5\u8fd0\u7b97\u7b26","text":"<pre><code>Mat &amp;operator*=(const Mat &amp;A);\n</code></pre> <p>\u63cf\u8ff0: \u4e58\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u6e90\u77e9\u9635\u7684\u5143\u7d20\u4e58\u5230\u5f53\u524d\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>const Mat &amp;A</code>: \u6e90\u77e9\u9635\u5bf9\u8c61</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-_2","title":"\u4e58\u6cd5\u8fd0\u7b97\u7b26 - \u5e38\u91cf","text":"<pre><code>Mat &amp;operator*=(float C);\n</code></pre> <p>\u63cf\u8ff0: \u4e58\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u5e38\u91cf\u4e58\u5230\u5f53\u524d\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>float C</code>: \u5e38\u91cf</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_26","title":"\u9664\u6cd5\u8fd0\u7b97\u7b26","text":"<pre><code>Mat &amp;operator/=(const Mat &amp;B);\n</code></pre> <p>\u63cf\u8ff0: \u9664\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u5f53\u524d\u77e9\u9635\u9664\u4ee5\u6e90\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>const Mat &amp;B</code>: \u6e90\u77e9\u9635\u5bf9\u8c61</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-_3","title":"\u9664\u6cd5\u8fd0\u7b97\u7b26 - \u5e38\u91cf","text":"<pre><code>Mat &amp;operator/=(float C);\n</code></pre> <p>\u63cf\u8ff0: \u9664\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u5f53\u524d\u77e9\u9635\u9664\u4ee5\u5e38\u91cf\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>float C</code>: \u5e38\u91cf</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_27","title":"\u5e42\u8fd0\u7b97\u7b26","text":"<pre><code>Mat operator^(int C);\n</code></pre> <p>\u63cf\u8ff0: \u5e42\u8fd0\u7b97\u7b26\uff0c\u5c06\u5f53\u524d\u77e9\u9635\u7684\u5143\u7d20\u8fdb\u884c\u5e42\u8fd0\u7b97\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>int C</code>: \u5e42\u6307\u6570</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_28","title":"\u7ebf\u6027\u4ee3\u6570","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_29","title":"\u8f6c\u7f6e\u77e9\u9635","text":"<pre><code>Mat::transpose();\n</code></pre> <p>\u63cf\u8ff0: \u8f6c\u7f6e\u5f53\u524d\u77e9\u9635\u3002</p> <p>\u53c2\u6570: void</p> <p>\u8fd4\u56de\u503c: \u8f6c\u7f6e\u540e\u7684\u77e9\u9635\u5bf9\u8c61</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_30","title":"\u4f59\u5b50\u5f0f\u77e9\u9635","text":"<pre><code>Mat::cofactor(int row, int col);\n</code></pre> <p>\u63cf\u8ff0: \u63d0\u53d6\u5f53\u524d\u77e9\u9635\u7684\u4f59\u5b50\u5f0f\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>int row</code>: \u884c\u7d22\u5f15</p> </li> <li> <p><code>int col</code>: \u5217\u7d22\u5f15</p> </li> </ul> <p>\u8fd4\u56de\u503c: \u4f59\u5b50\u5f0f\u77e9\u9635\u5bf9\u8c61</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_31","title":"\u884c\u5217\u5f0f","text":"<pre><code>float Mat::determinant();\n</code></pre> <p>\u63cf\u8ff0: \u8ba1\u7b97\u5f53\u524d\u77e9\u9635\u7684\u884c\u5217\u5f0f\u3002</p> <p>\u53c2\u6570: void</p> <p>\u8fd4\u56de\u503c: \u884c\u5217\u5f0f\u7684\u503c</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_32","title":"\u4f34\u968f\u77e9\u9635","text":"<pre><code>Mat::adjoint();\n</code></pre> <p>\u63cf\u8ff0: \u8ba1\u7b97\u5f53\u524d\u77e9\u9635\u7684\u4f34\u968f\u77e9\u9635\u3002</p> <p>\u53c2\u6570: void</p> <p>\u8fd4\u56de\u503c: \u4f34\u968f\u77e9\u9635\u5bf9\u8c61</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_33","title":"\u5f52\u4e00\u5316","text":"<pre><code>void Mat::normalize();\n</code></pre> <p>\u63cf\u8ff0: \u5f52\u4e00\u5316\u5f53\u524d\u77e9\u9635\u7684\u5143\u7d20\u3002</p> <p>\u53c2\u6570: void</p> <p>\u8fd4\u56de\u503c: void</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_34","title":"\u8303\u6570","text":"<pre><code>float Mat::norm() const;\n</code></pre> <p>\u63cf\u8ff0: \u8ba1\u7b97\u5f53\u524d\u77e9\u9635\u7684\u8303\u6570\u3002</p> <p>\u53c2\u6570: void</p> <p>\u8fd4\u56de\u503c: \u8303\u6570\u7684\u503c</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-_4","title":"\u77e9\u9635\u6c42\u9006 -- \u57fa\u4e8e\u4f34\u968f\u77e9\u9635","text":"<pre><code>Mat::inverse_adjoint();\n</code></pre> <p>\u63cf\u8ff0: \u8ba1\u7b97\u5f53\u524d\u77e9\u9635\u7684\u9006\u77e9\u9635\uff0c\u57fa\u4e8e\u4f34\u968f\u77e9\u9635\u6cd5\u3002</p> <p>\u53c2\u6570: void</p> <p>\u8fd4\u56de\u503c: \u9006\u77e9\u9635\u5bf9\u8c61</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_35","title":"\u5355\u4f4d\u77e9\u9635","text":"<pre><code>Mat::eye(int size);\n</code></pre> <p>\u63cf\u8ff0: \u521b\u5efa\u4e00\u4e2a\u5355\u4f4d\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>int size</code>: \u77e9\u9635\u7684\u5927\u5c0f</li> </ul> <p>\u8fd4\u56de\u503c: \u5355\u4f4d\u77e9\u9635\u5bf9\u8c61</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_36","title":"\u589e\u5e7f\u77e9\u9635","text":"<pre><code>Mat::augment(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>\u63cf\u8ff0: \u521b\u5efa\u4e00\u4e2a\u589e\u5e7f\u77e9\u9635\uff0c\u5c06\u4e24\u4e2a\u77e9\u9635\u8fde\u63a5\u5728\u4e00\u8d77\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>const Mat &amp;A</code>: \u7b2c\u4e00\u4e2a\u77e9\u9635\u5bf9\u8c61</p> </li> <li> <p><code>const Mat &amp;B</code>: \u7b2c\u4e8c\u4e2a\u77e9\u9635\u5bf9\u8c61</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_37","title":"\u5355\u4f4d\u77e9\u9635","text":"<pre><code>Mat::ones(int rows, int cols);\n</code></pre> <p>\u63cf\u8ff0: \u521b\u5efa\u4e00\u4e2a\u5168\u4e3a1\u7684\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>int rows</code>: \u884c\u6570</p> </li> <li> <p><code>int cols</code>: \u5217\u6570</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#1","title":"\u51681\u7684\u77e9\u9635","text":"<pre><code>Mat::ones(int size);\n</code></pre> <p>\u63cf\u8ff0: \u521b\u5efa\u4e00\u4e2a\u5168\u4e3a1\u7684\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>int size</code>: \u77e9\u9635\u7684\u5927\u5c0f</li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_38","title":"\u9ad8\u65af\u6d88\u5143\u6cd5","text":"<pre><code>Mat::gaussian_eliminate() const;\n</code></pre> <p>\u63cf\u8ff0: \u4f7f\u7528\u9ad8\u65af\u6d88\u5143\u6cd5\u5bf9\u5f53\u524d\u77e9\u9635\u8fdb\u884c\u53d8\u6362\u3002</p> <p>\u53c2\u6570: void</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_39","title":"\u9ad8\u65af\u6d88\u5143\u6cd5\u4e0b\u884c\u6700\u7b80\u5f62\u5f0f","text":"<pre><code>Mat::row_reduce_from_gaussian();\n</code></pre> <p>\u63cf\u8ff0: \u4f7f\u7528\u9ad8\u65af\u6d88\u5143\u6cd5\u5c06\u5f53\u524d\u77e9\u9635\u8f6c\u6362\u4e3a\u4e0b\u884c\u6700\u7b80\u5f62\u5f0f\u3002</p> <p>\u53c2\u6570: void</p> <p>\u8fd4\u56de\u503c: \u4e0b\u884c\u6700\u7b80\u5f62\u5f0f\u7684\u77e9\u9635\u5bf9\u8c61</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-_5","title":"\u9ad8\u65af-\u7ea6\u65e6\u6d88\u5143\u6cd5\u6c42\u9006","text":"<pre><code>Mat::inverse_gje();\n</code></pre> <p>\u63cf\u8ff0: \u4f7f\u7528\u9ad8\u65af-\u7ea6\u65e6\u6d88\u5143\u6cd5\u8ba1\u7b97\u5f53\u524d\u77e9\u9635\u7684\u9006\u77e9\u9635\u3002</p> <p>\u53c2\u6570: void</p> <p>\u8fd4\u56de\u503c: \u9006\u77e9\u9635\u5bf9\u8c61</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_40","title":"\u70b9\u79ef","text":"<pre><code>float Mat::dotprod(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>\u63cf\u8ff0: \u8ba1\u7b97\u4e24\u4e2a\u77e9\u9635\u7684\u70b9\u79ef\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>const Mat &amp;A</code>: \u7b2c\u4e00\u4e2a\u77e9\u9635\u5bf9\u8c61</p> </li> <li> <p><code>const Mat &amp;B</code>: \u7b2c\u4e8c\u4e2a\u77e9\u9635\u5bf9\u8c61</p> </li> </ul> <p>\u8fd4\u56de\u503c: \u70b9\u79ef\u7684\u503c</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_41","title":"\u89e3\u7ebf\u6027\u65b9\u7a0b\u7ec4","text":"<pre><code>Mat::solve(const Mat &amp;A, const Mat &amp;b);\n</code></pre> <p>\u63cf\u8ff0: \u89e3\u7ebf\u6027\u65b9\u7a0b\u7ec4 Ax = b\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>const Mat &amp;A</code>: \u7cfb\u6570\u77e9\u9635</p> </li> <li> <p><code>const Mat &amp;b</code>: \u5e38\u6570\u77e9\u9635</p> </li> </ul> <p>\u8fd4\u56de\u503c: \u89e3\u77e9\u9635 x</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_42","title":"\u5e26\u72b6\u77e9\u9635\u6c42\u89e3","text":"<pre><code>Mat::band_solve(Mat A, Mat b, int k);\n</code></pre> <p>\u63cf\u8ff0: \u89e3\u5e26\u72b6\u77e9\u9635\u65b9\u7a0b Ax = b\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>Mat A</code>: \u5e26\u72b6\u77e9\u9635</p> </li> <li> <p><code>Mat b</code>: \u5e38\u6570\u77e9\u9635</p> </li> <li> <p><code>int k</code>: \u5e26\u5bbd</p> </li> </ul> <p>\u8fd4\u56de\u503c: \u89e3\u77e9\u9635 x</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_43","title":"\u7ebf\u6027\u7cfb\u7edf\u6c42\u6839","text":"<pre><code>Mat::roots(Mat A, Mat y);\n</code></pre> <p>\u63cf\u8ff0: \u6c42\u89e3\u7ebf\u6027\u7cfb\u7edf\u7684\u6839\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>Mat A</code>: \u7cfb\u6570\u77e9\u9635</p> </li> <li> <p><code>Mat y</code>: \u5e38\u6570\u77e9\u9635</p> </li> </ul> <p>\u8fd4\u56de\u503c: \u6839\u77e9\u9635 x</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_44","title":"\u7ebf\u6027\u4ee3\u6570","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_45","title":"\u6d41\u64cd\u4f5c\u7b26","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_46","title":"\u77e9\u9635\u8f93\u51fa\u5230\u6d41","text":"<pre><code>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat &amp;m);\n</code></pre> <p>\u63cf\u8ff0: \u5c06\u77e9\u9635\u8f93\u51fa\u5230\u6d41\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>std::ostream &amp;os</code>: \u8f93\u51fa\u6d41\u5bf9\u8c61</p> </li> <li> <p><code>const Mat &amp;m</code>: \u77e9\u9635\u5bf9\u8c61</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_47","title":"\u5b50\u77e9\u9635\u8f93\u51fa\u5230\u6d41","text":"<pre><code>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Mat::ROI &amp;roi);\n</code></pre> <p>\u63cf\u8ff0: \u5c06\u5b50\u77e9\u9635\u8f93\u51fa\u5230\u6d41\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>std::ostream &amp;os</code>: \u8f93\u51fa\u6d41\u5bf9\u8c61</p> </li> <li> <p><code>const Mat::ROI &amp;roi</code>: \u5b50\u77e9\u9635\u5bf9\u8c61</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_48","title":"\u77e9\u9635\u8f93\u5165\u6d41","text":"<pre><code>std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Mat &amp;m);\n</code></pre> <p>\u63cf\u8ff0: \u4ece\u6d41\u4e2d\u8bfb\u53d6\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>std::istream &amp;is</code>: \u8f93\u5165\u6d41\u5bf9\u8c61</p> </li> <li> <p><code>Mat &amp;m</code>: \u77e9\u9635\u5bf9\u8c61</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_49","title":"\u5168\u5c40\u7b97\u6570\u8fd0\u7b97\u7b26","text":"<p>\u63d0\u793a</p> <p>\u672c\u8282\u4e2d\u7684\u8fd0\u7b97\u7b26\u8fd4\u56de\u4e00\u4e2a\u65b0\u7684\u77e9\u9635\u5bf9\u8c61\uff0c\u4f5c\u4e3a\u8fd0\u7b97\u7ed3\u679c\u3002\u539f\u59cb\u77e9\u9635\u4fdd\u6301\u4e0d\u53d8\u3002\u4e0e\u4e0a\u4e00\u8282\u4e0d\u540c\uff0c\u8fd9\u4e9b\u8fd0\u7b97\u7b26\u65e8\u5728\u5bf9\u5f53\u524d\u77e9\u9635\u672c\u8eab\u6267\u884c\u8fd0\u7b97\u3002</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_50","title":"\u52a0\u6cd5\u8fd0\u7b97\u7b26","text":"<pre><code>Mat operator+(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>\u63cf\u8ff0: \u52a0\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u4e24\u4e2a\u77e9\u9635\u76f8\u52a0\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>const Mat &amp;A</code>: \u7b2c\u4e00\u4e2a\u77e9\u9635\u5bf9\u8c61</p> </li> <li> <p><code>const Mat &amp;B</code>: \u7b2c\u4e8c\u4e2a\u77e9\u9635\u5bf9\u8c61</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-_6","title":"\u52a0\u6cd5\u8fd0\u7b97\u7b26 - \u5e38\u91cf","text":"<pre><code>Mat operator+(const Mat &amp;A, float C);\n</code></pre> <p>\u63cf\u8ff0: \u52a0\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u77e9\u9635\u4e0e\u5e38\u91cf\u76f8\u52a0\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>const Mat &amp;A</code>: \u77e9\u9635\u5bf9\u8c61</p> </li> <li> <p><code>float C</code>: \u5e38\u91cf</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_51","title":"\u51cf\u6cd5\u8fd0\u7b97\u7b26","text":"<pre><code>Mat operator-(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>\u63cf\u8ff0: \u51cf\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u7b2c\u4e00\u4e2a\u77e9\u9635\u51cf\u53bb\u7b2c\u4e8c\u4e2a\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>const Mat &amp;A</code>: \u7b2c\u4e00\u4e2a\u77e9\u9635\u5bf9\u8c61</p> </li> <li> <p><code>const Mat &amp;B</code>: \u7b2c\u4e8c\u4e2a\u77e9\u9635\u5bf9\u8c61</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-_7","title":"\u51cf\u6cd5\u8fd0\u7b97\u7b26 - \u5e38\u91cf","text":"<pre><code>Mat operator-(const Mat &amp;A, float C);\n</code></pre> <p>\u63cf\u8ff0: \u51cf\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u77e9\u9635\u51cf\u53bb\u5e38\u91cf\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>const Mat &amp;A</code>: \u77e9\u9635\u5bf9\u8c61</p> </li> <li> <p><code>float C</code>: \u5e38\u91cf   </p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_52","title":"\u4e58\u6cd5\u8fd0\u7b97\u7b26","text":"<pre><code>Mat operator*(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>\u63cf\u8ff0: \u4e58\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u4e24\u4e2a\u77e9\u9635\u76f8\u4e58\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>const Mat &amp;A</code>: \u7b2c\u4e00\u4e2a\u77e9\u9635\u5bf9\u8c61</p> </li> <li> <p><code>const Mat &amp;B</code>: \u7b2c\u4e8c\u4e2a\u77e9\u9635\u5bf9\u8c61</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-_8","title":"\u4e58\u6cd5\u8fd0\u7b97\u7b26 - \u5e38\u91cf","text":"<pre><code>Mat operator*(const Mat &amp;A, float C);\n</code></pre> <p>\u63cf\u8ff0: \u4e58\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u77e9\u9635\u4e0e\u5e38\u91cf\u76f8\u4e58\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>const Mat &amp;A</code>: \u77e9\u9635\u5bf9\u8c61</p> </li> <li> <p><code>float C</code>: \u5e38\u91cf</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-_9","title":"\u4e58\u6cd5\u8fd0\u7b97\u7b26 - \u5e38\u91cf - \u53cd\u5411","text":"<pre><code>Mat operator*(float C, const Mat &amp;A);\n</code></pre> <p>\u63cf\u8ff0: \u4e58\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u5e38\u91cf\u4e0e\u77e9\u9635\u76f8\u4e58\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>float C</code>: \u5e38\u91cf</p> </li> <li> <p><code>const Mat &amp;A</code>: \u77e9\u9635\u5bf9\u8c61</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_53","title":"\u9664\u6cd5\u8fd0\u7b97\u7b26","text":"<pre><code>Mat operator/(const Mat &amp;A, float C);\n</code></pre> <p>\u63cf\u8ff0: \u9664\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u77e9\u9635\u9664\u4ee5\u5e38\u91cf\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>const Mat &amp;A</code>: \u77e9\u9635\u5bf9\u8c61</p> </li> <li> <p><code>float C</code>: \u5e38\u91cf</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#-_10","title":"\u9664\u6cd5\u8fd0\u7b97\u7b26 - \u77e9\u9635","text":"<pre><code>Mat operator/(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>\u63cf\u8ff0: \u9664\u6cd5\u8fd0\u7b97\u7b26\uff0c\u5c06\u7b2c\u4e00\u4e2a\u77e9\u9635\u9664\u4ee5\u7b2c\u4e8c\u4e2a\u77e9\u9635\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>const Mat &amp;A</code>: \u7b2c\u4e00\u4e2a\u77e9\u9635\u5bf9\u8c61</p> </li> <li> <p><code>const Mat &amp;B</code>: \u7b2c\u4e8c\u4e2a\u77e9\u9635\u5bf9\u8c61</p> </li> </ul>"},{"location":"zh/MATH/MATRIX/tiny-matrix-api/#_54","title":"\u7b49\u4e8e\u8fd0\u7b97\u7b26","text":"<pre><code>bool operator==(const Mat &amp;A, const Mat &amp;B);\n</code></pre> <p>\u63cf\u8ff0: \u7b49\u4e8e\u8fd0\u7b97\u7b26\uff0c\u68c0\u67e5\u4e24\u4e2a\u77e9\u9635\u662f\u5426\u76f8\u7b49\u3002</p> <p>\u53c2\u6570:</p> <ul> <li> <p><code>const Mat &amp;A</code>: \u7b2c\u4e00\u4e2a\u77e9\u9635\u5bf9\u8c61</p> </li> <li> <p><code>const Mat &amp;B</code>: \u7b2c\u4e8c\u4e2a\u77e9\u9635\u5bf9\u8c61</p> </li> </ul> <p>\u8fd4\u56de\u503c: \u5e03\u5c14\u503c\uff0c\u8868\u793a\u4e24\u4e2a\u77e9\u9635\u662f\u5426\u76f8\u7b49</p>"},{"location":"zh/MATH/MATRIX/tiny-matrix-code/","title":"\u4ee3\u7801","text":""},{"location":"zh/MATH/MATRIX/tiny-matrix-test/","title":"\u6d4b\u8bd5","text":"<p>Tip</p> <p>\u4ee5\u4e0b\u7684\u6d4b\u8bd5\u7528\u4ee3\u7801\u548c\u6848\u4f8b\u4e5f\u4f5c\u4e3a\u4f7f\u7528\u6559\u5b66\u6848\u4f8b\u3002</p>"},{"location":"zh/MATH/USAGE/usage/","title":"\u4f7f\u7528\u8bf4\u660e","text":"<p>\u4f7f\u7528\u8bf4\u660e</p> <p>\u8be5\u6587\u6863\u662f\u5bf9 <code>tiny_math</code> \u6a21\u5757\u7684\u4f7f\u7528\u8bf4\u660e\u3002</p>"},{"location":"zh/MATH/USAGE/usage/#tinymath","title":"\u6574\u4f53\u5f15\u5165TinyMath","text":"<p>Info</p> <p>\u9002\u7528\u4e8eC\u9879\u76ee\uff0c\u6216\u8005\u7ed3\u6784\u8f83\u4e3a\u7b80\u5355\u7684C++\u9879\u76ee\u3002</p> <pre><code>#include \"tiny_math.h\"\n</code></pre>"},{"location":"zh/MATH/USAGE/usage/#tinymath_1","title":"\u5206\u6a21\u5757\u5f15\u5165TinyMath","text":"<p>Info</p> <p>\u9002\u7528\u4e8e\u9700\u8981\u7cbe\u786e\u63a7\u5236\u5f15\u5165\u6a21\u5757\u7684\u9879\u76ee\uff0c\u6216\u8005\u590d\u6742\u7684C++\u9879\u76ee\u3002</p> <pre><code>#include \"tiny_vec.h\" // \u5f15\u5165\u5411\u91cf\u6a21\u5757\n#include \"tiny_mat.h\" // \u5f15\u5165\u77e9\u9635\u6a21\u5757\n</code></pre> <pre><code>#include \"tiny_matrix.hpp\" // \u5f15\u5165\u9ad8\u7ea7\u77e9\u9635\u6a21\u5757\n</code></pre> <p>\u6ce8\u610f</p> <ul> <li> <p><code>tiny_vec.h</code> \u548c <code>tiny_mat.h</code> \u662f C \u8bed\u8a00\u7248\u672c\u7684\u5934\u6587\u4ef6\uff0c\u9002\u7528\u4e8e C \u8bed\u8a00\u7f16\u7a0b\u3002</p> </li> <li> <p><code>tiny_matrix.hpp</code> \u662f C++ \u8bed\u8a00\u7248\u672c\u7684\u5934\u6587\u4ef6\uff0c\u9002\u7528\u4e8e C++ \u8bed\u8a00\u7f16\u7a0b\u3002</p> </li> </ul> <p>\u7b80\u5355\u6765\u8bf4\uff0cC\u8bed\u8a00\u9879\u76ee\u53ea\u80fd\u7528 <code>tiny_vec.h</code> \u548c <code>tiny_mat.h</code>\uff0c\u800c C++ \u9879\u76ee\u53ef\u4ee5\u4f7f\u7528 <code>tiny_vec.h</code>\u3001<code>tiny_mat.h</code> \u548c <code>tiny_matrix.hpp</code>\u3002</p> <p>Tip</p> <p>\u5177\u4f53\u7684\u4f7f\u7528\u65b9\u6cd5\u8bf7\u53c2\u8003\u6d4b\u8bd5\u4ee3\u7801\u3002</p>"},{"location":"zh/MATH/VECTOR/api/","title":"\u5411\u91cf\u64cd\u4f5c","text":""},{"location":"zh/MATH/VECTOR/api/#_2","title":"\u76ee\u5f55","text":"<pre><code>// Addition\ntiny_error_t tiny_vec_add_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_addc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n// Subtraction\ntiny_error_t tiny_vec_sub_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_subc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n// Multiplication\ntiny_error_t tiny_vec_mul_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\ntiny_error_t tiny_vec_mulc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n// Division\ntiny_error_t tiny_vec_div_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out, bool allow_divide_by_zero);\ntiny_error_t tiny_vec_divc_f32(const float *input, float *output, int len, float C, int step_in, int step_out, bool allow_divide_by_zero);\n// Square root\ntiny_error_t tiny_vec_sqrt_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_sqrtf_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_inv_sqrt_f32(const float *input, float *output, int len);\ntiny_error_t tiny_vec_inv_sqrtf_f32(const float *input, float *output, int len);\n// Dot product\ntiny_error_t tiny_vec_dotprod_f32(const float *src1, const float *src2, float *dest, int len);\ntiny_error_t tiny_vec_dotprode_f32(const float *src1, const float *src2, float *dest, int len, int step1, int step2);\n</code></pre>"},{"location":"zh/MATH/VECTOR/api/#_3","title":"\u52a0\u6cd5","text":""},{"location":"zh/MATH/VECTOR/api/#_4","title":"\u4e24\u4e2a\u5411\u91cf\u7684\u52a0\u6cd5","text":"<p><pre><code>tiny_error_t tiny_vec_add_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\n</code></pre> \u529f\u80fd\uff1a \u8ba1\u7b97\u4e24\u4e2a\u5411\u91cf\u7684\u9010\u5143\u7d20\u52a0\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input1</code>\uff1a\u6307\u5411\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>input2</code>\uff1a\u6307\u5411\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>step1</code>\uff1a\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step2</code>\uff1a\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_5","title":"\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u52a0\u6cd5","text":"<p><pre><code>tiny_error_t tiny_vec_addc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n</code></pre> \u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u9010\u5143\u7d20\u52a0\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>C</code>\uff1a\u5e38\u6570\u503c\u3002</li> <li><code>step_in</code>\uff1a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_6","title":"\u51cf\u6cd5","text":""},{"location":"zh/MATH/VECTOR/api/#_7","title":"\u4e24\u4e2a\u5411\u91cf\u7684\u51cf\u6cd5","text":"<pre><code>tiny_error_t tiny_vec_sub_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u4e24\u4e2a\u5411\u91cf\u7684\u9010\u5143\u7d20\u51cf\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input1</code>\uff1a\u6307\u5411\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>input2</code>\uff1a\u6307\u5411\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>step1</code>\uff1a\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step2</code>\uff1a\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_8","title":"\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u51cf\u6cd5","text":"<pre><code>tiny_error_t tiny_vec_subc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u9010\u5143\u7d20\u51cf\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>C</code>\uff1a\u5e38\u6570\u503c\u3002</li> <li><code>step_in</code>\uff1a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_9","title":"\u4e58\u6cd5","text":""},{"location":"zh/MATH/VECTOR/api/#_10","title":"\u4e24\u4e2a\u5411\u91cf\u7684\u4e58\u6cd5","text":"<pre><code>tiny_error_t tiny_vec_mul_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u4e24\u4e2a\u5411\u91cf\u7684\u9010\u5143\u7d20\u4e58\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input1</code>\uff1a\u6307\u5411\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>input2</code>\uff1a\u6307\u5411\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>step1</code>\uff1a\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step2</code>\uff1a\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_11","title":"\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u4e58\u6cd5","text":"<pre><code>tiny_error_t tiny_vec_mulc_f32(const float *input, float *output, int len, float C, int step_in, int step_out);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u9010\u5143\u7d20\u4e58\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>C</code>\uff1a\u5e38\u6570\u503c\u3002</li> <li><code>step_in</code>\uff1a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_12","title":"\u9664\u6cd5","text":""},{"location":"zh/MATH/VECTOR/api/#_13","title":"\u4e24\u4e2a\u5411\u91cf\u7684\u9664\u6cd5","text":"<pre><code>tiny_error_t tiny_vec_div_f32(const float *input1, const float *input2, float *output, int len, int step1, int step2, int step_out, bool allow_divide_by_zero);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u4e24\u4e2a\u5411\u91cf\u7684\u9010\u5143\u7d20\u9664\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input1</code>\uff1a\u6307\u5411\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>input2</code>\uff1a\u6307\u5411\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>step1</code>\uff1a\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step2</code>\uff1a\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>allow_divide_by_zero</code>\uff1a\u5e03\u5c14\u503c\uff0c\u6307\u793a\u662f\u5426\u5141\u8bb8\u9664\u4ee5\u96f6\u7684\u64cd\u4f5c\u3002</li> </ul>"},{"location":"zh/MATH/VECTOR/api/#_14","title":"\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u9664\u6cd5","text":"<pre><code>tiny_error_t tiny_vec_divc_f32(const float *input, float *output, int len, float C, int step_in, int step_out, bool allow_divide_by_zero);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u4e0e\u5e38\u6570\u7684\u9010\u5143\u7d20\u9664\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>C</code>\uff1a\u5e38\u6570\u503c\u3002</li> <li><code>step_in</code>\uff1a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step_out</code>\uff1a\u8f93\u51fa\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>allow_divide_by_zero</code>\uff1a\u5e03\u5c14\u503c\uff0c\u6307\u793a\u662f\u5426\u5141\u8bb8\u9664\u4ee5\u96f6\u7684\u64cd\u4f5c\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_15","title":"\u5e73\u65b9\u6839","text":""},{"location":"zh/MATH/VECTOR/api/#_16","title":"\u5411\u91cf\u7684\u5e73\u65b9\u6839","text":"<pre><code>tiny_error_t tiny_vec_sqrt_f32(const float *input, float *output, int len);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u7684\u9010\u5143\u7d20\u5e73\u65b9\u6839\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_17","title":"\u5411\u91cf\u7684\u5e73\u65b9\u6839\uff08\u5feb\u901f\uff09","text":"<pre><code>tiny_error_t tiny_vec_sqrtf_f32(const float *input, float *output, int len);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u7684\u9010\u5143\u7d20\u5e73\u65b9\u6839\uff08\u5feb\u901f\u7248\u672c\uff09\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_18","title":"\u5411\u91cf\u7684\u5e73\u65b9\u6839\u5012\u6570","text":"<pre><code>tiny_error_t tiny_vec_inv_sqrt_f32(const float *input, float *output, int len);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u7684\u9010\u5143\u7d20\u5e73\u65b9\u6839\u5012\u6570\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_19","title":"\u5411\u91cf\u7684\u5e73\u65b9\u6839\u5012\u6570\uff08\u5feb\u901f\uff09","text":"<pre><code>tiny_error_t tiny_vec_inv_sqrtf_f32(const float *input, float *output, int len);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u5411\u91cf\u7684\u9010\u5143\u7d20\u5e73\u65b9\u6839\u5012\u6570\uff08\u5feb\u901f\u7248\u672c\uff09\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>input</code>\uff1a\u6307\u5411\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>output</code>\uff1a\u6307\u5411\u8f93\u51fa\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_20","title":"\u70b9\u79ef","text":""},{"location":"zh/MATH/VECTOR/api/#_21","title":"\u5411\u91cf\u7684\u70b9\u79ef","text":"<pre><code>tiny_error_t tiny_vec_dotprod_f32(const float *src1, const float *src2, float *dest, int len);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u4e24\u4e2a\u5411\u91cf\u7684\u70b9\u79ef\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>src1</code>\uff1a\u6307\u5411\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>src2</code>\uff1a\u6307\u5411\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>dest</code>\uff1a\u6307\u5411\u8f93\u51fa\u7ed3\u679c\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/api/#_22","title":"\u5411\u91cf\u7684\u70b9\u79ef\uff08\u5e26\u6b65\u957f\uff09","text":"<pre><code>tiny_error_t tiny_vec_dotprode_f32(const float *src1, const float *src2, float *dest, int len, int step1, int step2);\n</code></pre> <p>\u529f\u80fd\uff1a \u8ba1\u7b97\u4e24\u4e2a\u5411\u91cf\u7684\u70b9\u79ef\uff08\u5e26\u6b65\u957f\uff09\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>src1</code>\uff1a\u6307\u5411\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>src2</code>\uff1a\u6307\u5411\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6307\u9488\u3002</li> <li><code>dest</code>\uff1a\u6307\u5411\u8f93\u51fa\u7ed3\u679c\u7684\u6307\u9488\u3002</li> <li><code>len</code>\uff1a\u5411\u91cf\u7684\u957f\u5ea6\u3002</li> <li><code>step1</code>\uff1a\u7b2c\u4e00\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> <li><code>step2</code>\uff1a\u7b2c\u4e8c\u4e2a\u8f93\u5165\u5411\u91cf\u7684\u6b65\u957f\u3002</li> </ul> <p>\u8fd4\u56de\u503c\uff1a \u8fd4\u56de <code>tiny_error_t</code> \u7c7b\u578b\u7684\u9519\u8bef\u7801\uff0c\u8868\u793a\u64cd\u4f5c\u662f\u5426\u6210\u529f\u3002</p>"},{"location":"zh/MATH/VECTOR/code/","title":"\u4ee3\u7801","text":""},{"location":"zh/MATH/VECTOR/test/","title":"\u5411\u91cf\u64cd\u4f5c\u6d4b\u8bd5","text":"<p>\u5411\u91cf\u64cd\u4f5c\u6d4b\u8bd5</p> <p>\u8be5\u6d4b\u8bd5\u7528\u4e8e\u6d4b\u8bd5\u5411\u91cf\u76f8\u5173\u51fd\u6570\u7684\u6027\u80fd\u3002</p>"},{"location":"zh/MATH/VECTOR/test/#_2","title":"\u6d4b\u8bd5\u4ee3\u7801","text":""},{"location":"zh/MATH/VECTOR/test/#_3","title":"\u6d4b\u8bd5\u7ed3\u679c","text":""},{"location":"zh/MEASUREMENT/code/","title":"\u4ee3\u7801","text":"<p>\u6ce8\u610f</p> <p>\u4ee5\u4e0b\u4ee3\u7801\u5e94\u4ee5\u53d1\u5e03\u4ee3\u7801\u4e2d\u7684\u4ee3\u7801\u4e3a\u51c6\uff0c\u53ef\u80fd\u4f1a\u6709\u66f4\u65b0\u3002</p>"},{"location":"zh/MEASUREMENT/log/","title":"\u5f00\u53d1\u65e5\u5fd7","text":"<p>2025-04-03</p> <ul> <li>\u91c7\u6837\u914d\u7f6e\u7ed3\u6784\u4f53</li> <li>\u91c7\u6837\u6570\u636e\u7ed3\u6784\u4f53</li> <li>\u5b9e\u65f6\u91c7\u6837\u51fd\u6570/\u5e38\u89c4\u91c7\u6837\u51fd\u6570</li> <li>\u91c7\u6837\u9891\u7387\u9891\u7387\u4e0a\u9650\u6d4b\u8bd5\uff1a\u5b9e\u65f6\uff0825Hz-\u672c\u5730\u8f93\u51fa+MQTT;200Hz-\u4ec5MQTT\uff09\uff1b\u5e38\u89c4 \uff08500Hz\uff09</li> <li>\u670d\u52a1\u7aef\u53ef\u89c6\u5316\u7a0b\u5e8f</li> <li>\u670d\u52a1\u7aef\u6570\u636e\u5b58\u50a8</li> </ul>"},{"location":"zh/MEASUREMENT/measurement/","title":"\u6d4b\u91cf","text":"<p>\u5173\u4e8e\u6d4b\u91cf</p> <p>\u9ad8\u8d28\u91cf\u6d4b\u91cf/\u91c7\u6837\u662f\u6570\u636e\u5206\u6790\u7684\u57fa\u7840\uff0cTinySHM\u5728\u8bbe\u8ba1\u65f6\u5145\u5206\u8003\u8651\u4e86\u8fd9\u4e00\u70b9\u3002\u6211\u4eec\u5728TinySHM\u4e2d\u5b9e\u73b0\u4e86\u591a\u79cd\u6d4b\u91cf/\u91c7\u6837\u65b9\u6cd5\uff0c\u7528\u6237\u53ef\u4ee5\u6839\u636e\u81ea\u5df1\u7684\u9700\u6c42\u8fdb\u884c\u9009\u62e9\u3002</p> <p>Warning</p> <p>\u76ee\u524d\u5f00\u53d1\u4ee5ESP32\u4e3a\u57fa\u7840\uff0c\u5411STM32\u7b49\u5e73\u53f0\u7684\u8fc1\u79fb\u9700\u8981\u5bf9\u9002\u914d\u5c42\u8fdb\u884c\u4e00\u5b9a\u7684\u4fee\u6539\u3002</p>"},{"location":"zh/MEASUREMENT/notes/","title":"\u8bf4\u660e","text":""},{"location":"zh/MEASUREMENT/notes/#_2","title":"\u4f9d\u8d56","text":"<p>SYSTEM</p> <pre><code>#include \"esp_system.h\" // ESP32 System\n#include \"esp_log.h\"    // ESP32 Logging\n</code></pre> <p>RTOS</p> <pre><code>#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/event_groups.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/timers.h\"\n#include \"freertos/semphr.h\"\n</code></pre> <p>BSP</p> <pre><code>#include \"driver/gptimer.h\"\n#include \"led.h\"\n#include \"lcd.h\"\n#include \"tim.h\"\n#include \"esp_rtc.h\"\n#include \"spi_sdcard.h\"\n#include \"wifi_wpa2_enterprise.h\"\n#include \"mqtt.h\"\n#include \"mpu6050.h\"\n</code></pre> <p>TinyAuton/TinySHM</p> <pre><code>#include \"TinyAdapter.h\"\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_3","title":"\u91c7\u6837\u914d\u7f6e\u7ed3\u6784\u4f53","text":"<p>\u5b9a\u4e49</p> <pre><code>struct SenseConfig\n{\n    int sample_rate;\n    int sample_duration;\n    bool temperature_sense; // whether to sense temperature\n    bool printout;          // not recommened for high sample rate as it will slow down the process\n    bool mqtt_pub;          // not recommened for high sample rate as it will slow down the process\n};\n</code></pre> <p>\u4f7f\u7528 - \u5b9e\u65f6</p> <pre><code>// for streamline configuration\nstruct SenseConfig streamline_config = {\n    .sample_rate = 1,          // Sample rate in Hz. For local printout + mqtt, at most 25Hz; for only mqtt, at most 200Hz.\n    .temperature_sense = true, // Whether to sense temperature\n    .printout = true,          // Only available for sampling rate &lt;= 100Hz\n    .mqtt_pub = true           // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre> <p>\u4f7f\u7528 - \u5e38\u89c4\u91c7\u6837</p> <pre><code>// for sensing configuration\nstruct SenseConfig sense_config = {\n    .sample_rate = 500,   // Sample rate in Hz, only can be (1, 2, 5, 10, 20, 25, 50, 100, 200, 500) for FreeRTOS based sensing. Note can not be 1000Hz (no time to feed the watchdog).\n    .sample_duration = 1, // Sample duration in seconds\n    .printout = true      // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_4","title":"\u91c7\u6837\u6570\u636e\u7ed3\u6784\u4f53","text":"<pre><code>struct DataStruct\n{\n    int sample_rate;\n    int sample_duration;\n    float sensor_temperature;\n    TinyTimeMark_t start_time_stamp;\n    TinyTimeMark_t *time_stamp;\n    float *acc_data;\n    float *temperature;\n};\n</code></pre> <p>\u4f7f\u7528</p> <pre><code>// for data structure\nstruct DataStruct data_struct = {\n    .sample_rate = 0,     // Sample rate in Hz\n    .sample_duration = 0, // Sample duration in seconds\n    .sensor_temperature = 0.0,\n    .start_time_stamp = 0,\n    .acc_data = NULL}; \n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_5","title":"\u91c7\u6837\u539f\u7406","text":"<p>\u76ee\u524d\u91c7\u6837**\u57fa\u4e8eFreeRTOS\u5faa\u73af**\u800c\u975e\u57fa\u4e8e**\u5b9a\u65f6\u5668\u4e2d\u65ad**\uff0c\u5b9e\u73b0\u7b80\u5355\uff0c\u672a\u6765\u6216\u8bb8\u4f1a\u6dfb\u52a0\u5b9a\u65f6\u5668\u4e2d\u65ad\u91c7\u6837\u7684\u65b9\u5f0f\u3002</p>"},{"location":"zh/MEASUREMENT/notes/#_6","title":"\u91c7\u6837\u6a21\u5f0f\u4e0e\u91c7\u6837\u4efb\u52a1","text":"<p>\u76ee\u524d\u5171\u6709\u4e24\u79cd\u91c7\u6837\u6a21\u5f0f\uff1a - \u5b9e\u65f6\u91c7\u6837 - \u5e38\u89c4\u91c7\u6837</p>"},{"location":"zh/MEASUREMENT/notes/#_7","title":"\u5b9e\u65f6\u91c7\u6837","text":"<p>\u91c7\u6837\u4efb\u52a1\u5b9a\u4e49</p> <pre><code>/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters)\n{\n\n    // streamline variables\n    float acc_x, acc_y, acc_z, temperature;\n    TinyTimeMark_t time_stamp;\n\n    // MQTT publish buffer\n    char streamline_buff[256];\n\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n\n    if (config-&gt;sample_rate &gt; 100 &amp;&amp; config-&gt;printout)\n    {\n        ESP_LOGW(TAG, \"Printout is disabled for sample rate &gt; 100Hz.\");\n        config-&gt;printout = false;\n    }\n\n    while (1)\n    {\n        // get the time stamp\n        time_stamp = tiny_get_running_time();\n\n        // get accelerometer data\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        acc_x = acce.acce_x;\n        acc_y = acce.acce_y;\n        acc_z = acce.acce_z;\n\n        // get temperature\n        mpu6050_get_temp(mpu6050, &amp;temp);\n        temperature = temp.temp;\n\n        // sprintf\n        if (config-&gt;printout || config-&gt;mqtt_pub)\n        {\n            snprintf(streamline_buff, sizeof(streamline_buff), \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Sensor Temperature: %4.2f \u00b0C\", time_stamp, acc_x, acc_y, acc_z, temperature);\n        }\n\n        // print out the data - comment out for higher sample rate\n        if (config-&gt;printout)\n        {\n            ESP_LOGI(TAG, \"%s\", streamline_buff);\n        }\n\n        // MQTT publish\n        if (config-&gt;mqtt_pub)\n        {\n            esp_mqtt_client_publish(s_mqtt_client, MQTT_PUBLIC_TOPIC, streamline_buff, strlen(streamline_buff), 0, 0); // for streamline, data quality is not expected to be high, so QoS = 0; data retaintion is also not required, so 0.\n        }\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n    ESP_LOGI(TAG, \"Streamline terminated. Task will delete itself.\");\n    vTaskDelete(NULL);\n}\n</code></pre> <p>\u91c7\u6837\u4efb\u52a1\u4f7f\u7528: \u5728\u5e94\u7528\u7a0b\u5e8f\u90e8\u5206\u521b\u5efa\u4efb\u52a1\u5373\u53ef</p> <pre><code>xTaskCreate(acc_streamline_task, \"Accel_Streamline_Task\", 4096, &amp;streamline_config, 5, NULL);\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_8","title":"\u5e38\u89c4\u91c7\u6837","text":"<p>\u91c7\u6837\u4efb\u52a1\u5b9a\u4e49</p> <pre><code>/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters)\n{\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n    int total_samples = config-&gt;sample_rate * config-&gt;sample_duration;\n\n    // Fill global data_struct\n    data_struct.sample_rate = config-&gt;sample_rate;\n    data_struct.sample_duration = config-&gt;sample_duration;\n    mpu6050_get_temp(mpu6050, &amp;temp);\n    data_struct.sensor_temperature = temp.temp;\n    data_struct.start_time_stamp = tiny_get_running_time();\n\n    // Allocate memory\n    data_struct.acc_data = malloc(sizeof(float) * 3 * total_samples);\n    data_struct.temperature = malloc(sizeof(float) * total_samples);\n    data_struct.time_stamp = malloc(sizeof(TinyTimeMark_t) * total_samples);\n\n    if (data_struct.acc_data == NULL || data_struct.temperature == NULL || data_struct.time_stamp == NULL)\n    {\n        ESP_LOGE(TAG, \"Failed to allocate memory for sensing data.\");\n        if (data_struct.acc_data)\n            free(data_struct.acc_data);\n        if (data_struct.temperature)\n            free(data_struct.temperature);\n        if (data_struct.time_stamp)\n            free(data_struct.time_stamp);\n        vTaskDelete(NULL);\n    }\n\n    ESP_LOGI(TAG, \"Sampling started: %d Hz for %d seconds (%d samples)\",\n             config-&gt;sample_rate, config-&gt;sample_duration, total_samples);\n\n    for (int i = 0; i &lt; total_samples; i++)\n    {\n        TinyTimeMark_t now = tiny_get_running_time();\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        mpu6050_get_temp(mpu6050, &amp;temp);\n\n        // Store data\n        data_struct.time_stamp[i] = now;\n        data_struct.acc_data[i * 3 + 0] = acce.acce_x;\n        data_struct.acc_data[i * 3 + 1] = acce.acce_y;\n        data_struct.acc_data[i * 3 + 2] = acce.acce_z;\n        data_struct.temperature[i] = temp.temp;\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n\n    ESP_LOGI(TAG, \"Sampling complete.\");\n\n    // Print metadata\n    ESP_LOGI(TAG, \"-----------------------------\");\n    ESP_LOGI(TAG, \"Sensor Temperature : %.2f \u00b0C\", data_struct.sensor_temperature);\n    ESP_LOGI(TAG, \"Start Time Stamp   : %ld\", (long)data_struct.start_time_stamp);\n    ESP_LOGI(TAG, \"Sample Rate        : %d Hz\", data_struct.sample_rate);\n    ESP_LOGI(TAG, \"Sample Duration    : %d sec\", data_struct.sample_duration);\n    ESP_LOGI(TAG, \"Total Samples      : %d\", total_samples);\n    ESP_LOGI(TAG, \"Data Size          : %.2f KB\",\n             (sizeof(float) * 4 + sizeof(TinyTimeMark_t)) * total_samples / 1024.0f);\n    ESP_LOGI(TAG, \"-----------------------------\");\n\n    // Print collected data if enabled\n    if (config-&gt;printout)\n    {\n        for (int i = 0; i &lt; total_samples; i++)\n        {\n            ESP_LOGI(TAG, \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Temperature: %.2f \u00b0C\",\n                     (long)data_struct.time_stamp[i],\n                     data_struct.acc_data[i * 3 + 0],\n                     data_struct.acc_data[i * 3 + 1],\n                     data_struct.acc_data[i * 3 + 2],\n                     data_struct.temperature[i]);\n\n            // Release CPU for a short time to avoid blocking\n            if ((i % 10) == 0)\n            {\n                vTaskDelay(pdMS_TO_TICKS(10));\n            }\n        }\n    }\n\n    // Free allocated memory\n    if (data_struct.acc_data)\n    {\n        free(data_struct.acc_data);\n        data_struct.acc_data = NULL;\n    }\n    if (data_struct.temperature)\n    {\n        free(data_struct.temperature);\n        data_struct.temperature = NULL;\n    }\n    if (data_struct.time_stamp)\n    {\n        free(data_struct.time_stamp);\n        data_struct.time_stamp = NULL;\n    }\n\n    vTaskDelete(NULL);\n}\n</code></pre> <p>\u91c7\u6837\u4efb\u52a1\u4f7f\u7528: \u5728\u5e94\u7528\u7a0b\u5e8f\u90e8\u5206\u521b\u5efa\u4efb\u52a1\u5373\u53ef</p> <pre><code>xTaskCreate(acc_sense_task, \"Accel_Sense_Task\", 8192, &amp;sense_config, 5, NULL);\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_9","title":"\u5f85\u5f00\u53d1","text":"<ul> <li>\u6807\u51c6\u65f6\u95f4\u6233</li> <li>\u6821\u51c6</li> <li>\u5b9a\u65f6\u5668+\u4e2d\u65ad</li> <li>DMA</li> <li>ADC+\u6a21\u62df</li> <li>\u6570\u636e\u540e\u5904\u7406</li> <li>\u6279\u91cf\u6570\u636eMQTT\u4e0a\u4f20</li> <li>\u5b9e\u65f6\u5904\u7406\u529f\u80fd\u5f00\u53d1</li> </ul>"},{"location":"zh/RELEASES/releases/","title":"\u53d1\u5e03","text":""},{"location":"zh/RELEASES/releases/#dnesp32s3m-stable","title":"DNESP32S3M-STABLE","text":"<p>\u7a33\u5b9a\u7248</p>"},{"location":"zh/RELEASES/releases/#dnesp32s3m-latest","title":"DNESP32S3M-LATEST","text":"<p>\u6700\u65b0\u529f\u80fd\u7248</p>"},{"location":"zh/TOOLBOX/toolbox/","title":"\u5de5\u5177\u7bb1","text":"<p>tiny_toolbox</p> <p>\u5de5\u5177\u7bb1tiny_toolbox\u5b9a\u4f4d\u662f\u7528\u4e8e \u5e73\u53f0\u9002\u914d\u4e0e\u4f18\u5316 \u5e76\u63d0\u4f9b \u5404\u79cd\u5b9e\u7528\u5de5\u5177 \u7684\u5e93\uff0c\u670d\u52a1\u4e8e\u8fb9\u7f18\u8ba1\u7b97\u4e0e\u5e94\u7528\u5f00\u53d1\u3002\u6ce8\u610f\uff0c\u4e4b\u6240\u4ee5\u5c06\u9002\u914d\u548c\u5de5\u5177\u653e\u5728\u4e00\u4e2a\u5e93\u91cc\u9762\uff0c\u662f\u56e0\u4e3a\u5f88\u591a\u5de5\u5177\u5e95\u5c42\u5229\u7528\u7684\u662f\u5e73\u53f0\u63d0\u4f9b\u7684\u529f\u80fd\uff0c\u6240\u4ee5\u5c06\u5e73\u53f0\u9002\u914d\u548c\u5404\u7c7b\u5de5\u5177\u653e\u5728\u540c\u4e00\u4e2a\u5e93\u91cc\u9762\uff0c\u4fbf\u4e8e\u4f7f\u7528\u548c\u7ef4\u62a4\u3002</p> <p>Warning</p> <p>\u76ee\u524d\u5f00\u53d1\u4ee5ESP32\u4e3a\u57fa\u7840\uff0c\u5411STM32\u7b49\u5e73\u53f0\u7684\u8fc1\u79fb\u9700\u8981\u5bf9\u9002\u914d\u5c42\u8fdb\u884c\u4e00\u5b9a\u7684\u4fee\u6539\u3002</p>"},{"location":"zh/TOOLBOX/toolbox/#_2","title":"\u7ec4\u4ef6\u4f9d\u8d56","text":"<pre><code>set(src_dirs\n    .\n    time\n)\n\nset(include_dirs\n    .\n    time\n)\n\nset(requires\n    esp_timer\n    esp_rtc\n    espressif__esp-dsp\n    espressif__esp_jpeg\n    espressif__esp-dl\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"zh/TOOLBOX/toolbox/#_3","title":"\u67b6\u6784\u4e0e\u529f\u80fd\u76ee\u5f55","text":"<pre><code>    tiny_toolbox\n    \u251c\u2500\u2500 CMakeLists.txt\n    \u251c\u2500\u2500 tiny_toolbox.h // serves as a directory, integrating all submodules\n    \u251c\u2500\u2500 time\n    \u2502   \u251c\u2500\u2500 tiny_time.h // submodule for time management - header file\n    \u2502   \u251c\u2500\u2500 tiny_time.c // submodule for time management - source file\n    \u2502   \u2514\u2500\u2500 ...\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"zh/TOOLBOX/toolbox/#_4","title":"\u65f6\u95f4","text":"<ul> <li>\u83b7\u53d6\u8fd0\u884c\u65f6\u95f4\uff1a <code>tiny_get_running_time()</code></li> <li>SNTP\u5bf9\u65f6\uff1a <code>sync_time_with_timezone(\"CST-8\")</code></li> <li>\u83b7\u53d6\u4e16\u754c\u65f6\u95f4\uff1a <code>tiny_get_current_time(1)</code></li> </ul> <p>\u5f85\u5f00\u53d1:</p> <ul> <li>\u65e0\u7ebf\u4f20\u611f\u5668\u7f51\u7edc\u672c\u5730\u5bf9\u65f6-\u5fae\u79d2\u7ea7\u522b</li> </ul>"},{"location":"zh/TOOLBOX/toolbox/#_5","title":"\u4ee3\u7801","text":"<p>Tip</p> <p>tiny_toolbox.h \u53ea\u662f\u4f5c\u4e3a\u4e00\u4e2a\u76ee\u5f55\uff0c\u96c6\u6210\u4e86\u6240\u6709\u7684\u5b50\u6a21\u5757\uff0c\u5177\u4f53\u7684\u529f\u80fd\u5728\u5404\u4e2a\u5b50\u6a21\u5757\u4e2d\u5b9e\u73b0\u3002tiny_toolbox.c \u53ea\u662f\u5f62\u5f0f\u4e0a\u7684\u6e90\u6587\u4ef6\uff0c\u6ca1\u6709\u5177\u4f53\u7684\u529f\u80fd\u3002</p>"},{"location":"zh/TOOLBOX/TIME/log/","title":"LOG","text":"<p>2025-04-10</p> <ul> <li>\u83b7\u53d6\u8fd0\u884c\u65f6\u95f4\uff1a <code>tiny_get_running_time()</code></li> <li>SNTP\u5bf9\u65f6\uff1a <code>sync_time_with_timezone(\"CST-8\")</code></li> <li>\u83b7\u53d6\u4e16\u754c\u65f6\u95f4\uff1a <code>tiny_get_current_time(1)</code></li> </ul> <p>\u5f85\u5f00\u53d1:</p> <ul> <li>\u65e0\u7ebf\u4f20\u611f\u5668\u7f51\u7edc\u672c\u5730\u5bf9\u65f6-\u5fae\u79d2\u7ea7\u522b</li> </ul>"},{"location":"zh/TOOLBOX/TIME/notes/","title":"\u65f6\u95f4","text":"<p>\u65f6\u95f4</p> <p>\u65f6\u95f4\u76f8\u5173\u7684\u529f\u80fd\u5bf9\u4e8eMCU\u6765\u8bf4\u975e\u5e38\u91cd\u8981\uff0c\u672c\u8282\u63d0\u4f9b\u4e00\u7cfb\u5217\u65f6\u95f4\u76f8\u5173\u7684\u5b9a\u4e49\u548c\u51fd\u6570\uff0c\u4f9b\u5f00\u53d1\u8005\u4f7f\u7528\u3002</p> <p>MCU\u4e2d\u7684\u65f6\u95f4\u53ef\u4ee5\u5206\u4ee5\u4e0b\u51e0\u79cd\u7c7b\u578b\uff1a</p> <ul> <li> <p>\u8fd0\u884c\u65f6\u95f4\uff1a \u6307\u7684\u662fMCU\u4ece\u4e0a\u7535\u5230\u73b0\u5728\u7684\u65f6\u95f4\u3002</p> </li> <li> <p>\u4e16\u754c\u65f6\u95f4\uff1a \u6307\u7684\u662fMCU\u6240\u5728\u7684\u65f6\u533a\u7684\u65f6\u95f4\u3002\u4e16\u754c\u65f6\u95f4\u53ef\u4ee5\u901a\u8fc7\u6807\u51c6\u7684\u5e74\u6708\u65e5\u65f6\u5206\u79d2\u6765\u8868\u793a\uff0c\u4e5f\u53ef\u4ee5\u8868\u793a\u4e3aUNIX\u65f6\u95f4\u6233\u3002</p> </li> </ul>"},{"location":"zh/TOOLBOX/TIME/notes/#_2","title":"\u8fd0\u884c\u65f6\u95f4","text":"<p>ESP\u6709\u81ea\u5df1\u7684\u83b7\u53d6\u8fd0\u884c\u65f6\u95f4\u7684\u51fd\u6570<code>esp_timer_get_time</code>\uff0c\u4f9d\u8d56\u4e8e<code>esp_timer</code>\u5e93\u3002\u8be5\u51fd\u6570\u8fd4\u56de\u4ece\u4e0a\u7535\u5230\u73b0\u5728\u7684\u65f6\u95f4\uff0c\u5355\u4f4d\u4e3a\u5fae\u79d2\u3002</p> <p>\u4e3a\u4e86\u65b9\u4fbf\u4f7f\u7528\uff0cTinyToolbox\u91cd\u65b0\u5b9a\u4e49\u4e86\u6570\u636e\u7c7b\u578b<code>TinyTimeMark_t</code>\uff0c\u5e76\u63d0\u4f9b\u4e86\u4e00\u4e2a\u51fd\u6570<code>tiny_get_running_time</code>\u6765\u83b7\u53d6\u8fd0\u884c\u65f6\u95f4\u3002\u8be5\u51fd\u6570\u8fd4\u56de\u7684\u65f6\u95f4\u5355\u4f4d\u4e3aTickType_t\uff0cTickType_t\u662fFreeRTOS\u4e2d\u5b9a\u4e49\u7684\u65f6\u95f4\u5355\u4f4d\u3002</p> <pre><code>typedef TickType_t TinyTimeMark_t;\n</code></pre> <pre><code>/**\n * @brief Get the running time in microseconds\n * @return TinyTimeMark_t\n */\nTinyTimeMark_t tiny_get_running_time(void)\n{\n    return esp_timer_get_time();\n}\n</code></pre> <p>\u4f7f\u7528\u53c2\u8003\uff1a</p> <pre><code>void app_main(void)\n{\n    // Get running time\n    TinyTimeMark_t running_time = tiny_get_running_time();\n    ESP_LOGI(TAG_TIME, \"Running Time: %lld us\", running_time);\n}\n</code></pre>"},{"location":"zh/TOOLBOX/TIME/notes/#_3","title":"\u4e16\u754c\u65f6\u95f4","text":"<p>Warning</p> <p>\u6ce8\u610f\uff0c\u83b7\u53d6\u4e16\u754c\u65f6\u95f4\u9700\u8981\u5efa\u7acb\u5728\u5df2\u7ecf\u8054\u7f51\u7684\u57fa\u7840\u4e0a\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u83b7\u53d6\u4e16\u754c\u65f6\u95f4\u7684\u51fd\u6570\u9700\u8981\u5728\u8054\u7f51\u6210\u529f\u540e\u8c03\u7528\u3002</p>"},{"location":"zh/TOOLBOX/TIME/notes/#ntp","title":"NTP\u5bf9\u65f6","text":"<p>NTP\u5bf9\u65f6</p> <p>NTP\uff08Network Time Protocol\uff09\u662f\u7f51\u7edc\u65f6\u95f4\u534f\u8bae\u7684\u7f29\u5199\uff0c\u662f\u4e00\u79cd\u7528\u4e8e\u5728\u8ba1\u7b97\u673a\u7f51\u7edc\u4e2d\u540c\u6b65\u65f6\u95f4\u7684\u534f\u8bae\u3002\u5b83\u53ef\u4ee5\u901a\u8fc7\u4e92\u8054\u7f51\u6216\u5c40\u57df\u7f51\u83b7\u53d6\u51c6\u786e\u7684\u65f6\u95f4\u4fe1\u606f\u3002 NTP\u534f\u8bae\u4f7f\u7528UDP\u534f\u8bae\u8fdb\u884c\u901a\u4fe1\uff0c\u9ed8\u8ba4\u4f7f\u7528123\u7aef\u53e3\u3002NTP\u670d\u52a1\u5668\u4f1a\u5b9a\u671f\u5411\u5ba2\u6237\u7aef\u53d1\u9001\u65f6\u95f4\u4fe1\u606f\uff0c\u5ba2\u6237\u7aef\u6839\u636e\u8fd9\u4e9b\u4fe1\u606f\u6765\u6821\u6b63\u81ea\u5df1\u7684\u7cfb\u7edf\u65f6\u95f4\u3002</p> <pre><code>   Client                      Server\n     |-------------------&gt;      |     T1\uff1a\u8bf7\u6c42\u53d1\u51fa\n     |                          |\n     |         &lt;--------------- |     T2/T3\uff1a\u670d\u52a1\u5668\u6536\u5230 &amp; \u56de\u590d\n     |                          |\n     |-------------------&gt;      |     T4\uff1a\u5ba2\u6237\u7aef\u6536\u5230\u54cd\u5e94\n</code></pre> <p>NTP\u5bf9\u65f6\u539f\u7406</p> <p>NTP\u5bf9\u65f6\u662f\u57fa\u4e8e\u56db\u4e2a\u65f6\u95f4\u6233\uff1a1. \u5ba2\u6237\u7aef\u53d1\u9001\u8bf7\u6c42\u65f6\u7684\u65f6\u95f4\u6233T1 2. \u670d\u52a1\u5668\u63a5\u6536\u5230\u8bf7\u6c42\u65f6\u7684\u65f6\u95f4\u6233T2 3. \u670d\u52a1\u5668\u53d1\u9001\u54cd\u5e94\u65f6\u7684\u65f6\u95f4\u6233T3 4. \u5ba2\u6237\u7aef\u63a5\u6536\u5230\u54cd\u5e94\u65f6\u7684\u65f6\u95f4\u6233T4\u3002\u6839\u636e\u8fd9\u56db\u4e2a\u65f6\u95f4\u6233\uff0c\u53ef\u4ee5\u8ba1\u7b97 \u7f51\u7edc\u5ef6\u8fdf Delay = (T4 - T1) - (T3 - T2)\uff0c\u4ee5\u53ca \u65f6\u95f4\u504f\u79fb Offset = ((T2 - T1) + (T3 - T4)) / 2\u3002</p> <p>ESP32 SNTP\u5bf9\u65f6</p> <p>ESP32\u4e2d\u4f7f\u7528\u7684\u662fSNTP\uff0c\u4e5f\u5c31\u662fSimple Network Time Protocol\u3002SNTP\u662fNTP\u7684\u7b80\u5316\u7248\uff0c\u9002\u7528\u4e8e\u5bf9\u65f6\u95f4\u7cbe\u5ea6\u8981\u6c42\u4e0d\u9ad8\u7684\u573a\u666f\u3002ESP32\u4e2d\u5bf9\u65f6\u4f9d\u8d56\u4e8e<code>esp_sntp</code>\u5e93\u3002SNTP\u7684\u5de5\u4f5c\u539f\u7406\u4e0eNTP\u7c7b\u4f3c\uff0c\u4f46SNTP\u7684\u5b9e\u73b0\u76f8\u5bf9\u7b80\u5355\uff0c\u9002\u5408\u5d4c\u5165\u5f0f\u8bbe\u5907\u4f7f\u7528\u3002\u5176\u7cbe\u5ea6\u901a\u5e38\u5728ms\u7ea7\u522b\uff0c\u9002\u7528\u4e8e\u5927\u591a\u6570\u5e94\u7528\u573a\u666f\u3002</p> <p>\u9996\u5148\u5b9a\u4e49\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff0c\u7528\u4e8e\u63a5\u6536\u5bf9\u65f6\u901a\u77e5\uff1a</p> <p><pre><code>/* WORLD CURRENT TIME - SNTP */\n/**\n * @brief Callback function for time synchronization notification\n * @param tv Pointer to the timeval structure containing the synchronized time\n * @return None\n */\nvoid time_sync_notification_cb(struct timeval *tv)\n{\n    ESP_LOGI(TAG_SNTP, \"Time synchronized!\");\n}\n</code></pre> \u63a5\u4e0b\u6765\u662fSNTP\u7684\u521d\u59cb\u5316\u51fd\u6570\uff0c\u4e5f\u662f\u5bf9\u65f6\u7684\u6838\u5fc3\u51fd\u6570\uff0c\u901a\u5e38\u5728\u7cfb\u7edf\u521d\u59cb\u5316\u65f6\uff0c\u5b8c\u6210\u8054\u7f51\u540e\u8c03\u7528\u3002\u6ce8\u610f\u5176\u4e2d\u7684\u5bf9\u65f6\u670d\u52a1\u5668\u5730\u5740\u53ef\u4ee5\u6839\u636e\u9700\u8981\u8fdb\u884c\u4fee\u6539\u3002\u5bf9\u65f6\u5b8c\u6210\u540e\uff0cESP32\u4f1a\u5728\u5e95\u5c42\u5bf9\u672c\u673a\u65f6\u95f4\u8fdb\u884c\u8bbe\u7f6e\u3002</p> <pre><code>/**\n * @brief Initialize SNTP\n * @return None\n */\nvoid initialize_sntp(void)\n{\n    ESP_LOGI(TAG_SNTP, \"Initializing SNTP\");\n    sntp_setoperatingmode(SNTP_OPMODE_POLL);\n    sntp_setservername(0, \"pool.ntp.org\"); // NTP server // pool.ntp.org // ntp.aliyun.com\n    sntp_set_time_sync_notification_cb(time_sync_notification_cb);\n    sntp_init();\n}\n</code></pre> <p>\u518d\u63a5\u4e0b\u6765\u662f\u5bf9\u4ee5\u4e0a\u51fd\u6570\u7684\u8fdb\u4e00\u6b65\u5c01\u88c5\uff0c\u5305\u542b\u4e86\u65f6\u533a\u8bbe\u7f6e\u3002\u6ce8\u610f\u4ee5\u4e0b\u51fd\u6570\u4e2d\u5305\u62ec\u4e86\u5bf9RTC\u7684\u8bbe\u7f6e<code>rtc_set_time</code>\uff0c\u4f9d\u8d56\u4e8edriver\u5c42\u7684RTC\u9a71\u52a8\u3002\u6b64\u5904\u4f7f\u7528\u7684\u662f\u6211\u81ea\u5b9a\u4e49\u7684rtc\u9a71\u52a8\uff0c\u82e5\u6ca1\u6709\u76f8\u5173\u529f\u80fd\u53ef\u4ee5\u76f4\u63a5\u6ce8\u91ca\u6389\u3002</p> <pre><code>/**\n * @brief Obtain the current time with timezone\n * @param timezone_str Timezone string (e.g., \"CST-8\")\n * @note The timezone string should be in the format \"TZ=GMT+/-HH:MM\"\n * @note To use this function, in application, after internet connection, insert \"sync_time_with_timezone(\"CST-8\");\" will do\n * @return None\n */\nvoid sync_time_with_timezone(const char *timezone_str)\n{\n    // Set system timezone\n    setenv(\"TZ\", timezone_str, 1);\n    tzset();\n\n    // Initialize SNTP and start time sync\n    initialize_sntp();\n\n    // Wait for system time to be set\n    time_t now = 0;\n    struct tm timeinfo = { 0 };\n    int retry = 0;\n    const int retry_count = 15;\n\n    while (timeinfo.tm_year &lt; (2020 - 1900) &amp;&amp; ++retry &lt; retry_count) {\n        ESP_LOGI(TAG_SNTP, \"Waiting for system time to be set... (%d/%d)\", retry, retry_count);\n        vTaskDelay(2000 / portTICK_PERIOD_MS);\n        time(&amp;now);\n        localtime_r(&amp;now, &amp;timeinfo);\n    }\n\n    if (timeinfo.tm_year &gt;= (2020 - 1900)) {\n        rtc_set_time(timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday,\n                    timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec); // defined in esp_rtc.c\n        ESP_LOGI(TAG_SNTP, \"System time is set.\");\n    } else {\n        ESP_LOGW(TAG_SNTP, \"Failed to sync time.\");\n        return;\n    }\n\n    // Log current local time\n    ESP_LOGI(TAG_SNTP, \"Current time: %s\", asctime(&amp;timeinfo));\n\n    // vTaskDelay(10000 / portTICK_PERIOD_MS); // Wait for 10 second\n    // rtc_get_time(); // uncomment to check the RTC time\n    // ESP_LOGI(TAG_SNTP, \"Current RTC time: %04d-%02d-%02d %02d:%02d:%02d\",\n    //          calendar.year, calendar.month, calendar.date,\n    //          calendar.hour, calendar.min, calendar.sec); // uncomment to check the RTC time\n\n}\n</code></pre>"},{"location":"zh/TOOLBOX/TIME/notes/#_4","title":"\u4e16\u754c\u65f6\u95f4\u83b7\u53d6","text":"<p>\u4e3a\u4e86\u65b9\u4fbf\u4e16\u754c\u65f6\u95f4\u7684\u83b7\u53d6\uff0c\u6211\u4eec\u9996\u5148\u5b9a\u4e49\u4e86\u4e00\u4e2a\u6570\u636e\u7ed3\u6784<code>DateTime_t</code>\uff0c\u7528\u4e8e\u5b58\u50a8\u5e74\u6708\u65e5\u65f6\u5206\u79d2\u7b49\u4fe1\u606f\u3002\u7136\u540e\u5b9a\u4e49\u4e86\u4e00\u4e2a\u51fd\u6570<code>tiny_get_current_time</code>\uff0c\u7528\u4e8e\u83b7\u53d6\u5f53\u524d\u7684\u4e16\u754c\u65f6\u95f4\u3002\u8be5\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a<code>DateTime_t</code>\u7ed3\u6784\u4f53\uff0c\u5305\u542b\u4e86\u5f53\u524d\u7684\u5e74\u6708\u65e5\u65f6\u5206\u79d2\u7b49\u4fe1\u606f\u3002\u5728\u4f7f\u7528\u65f6\uff0c\u4f20\u5165\u4e00\u4e2a\u5e03\u5c14\u503c<code>print_flag</code>\uff0c\u7528\u4e8e\u63a7\u5236\u662f\u5426\u6253\u5370\u5f53\u524d\u65f6\u95f4\u3002</p> <pre><code>/**\n * @brief Structure to hold date and time\n */\ntypedef struct TinyDateTime_t\n{\n    int year;\n    int month;\n    int day;\n    int hour;\n    int minute;\n    int second;\n    long microsecond;\n} TinyDateTime_t; \n</code></pre> <p><pre><code>/* WORLD CURRENT TIME - GET TIME */\n/**\n * @name tiny_get_current_time\n * @brief Get the current time as a TinyDateTime_t struct\n * @param print_flag Flag to indicate whether to print the time\n * @return TinyDateTime_t structure containing the current date and time\n */\nTinyDateTime_t tiny_get_current_time(bool print_flag)\n{\n    struct timeval tv;\n    gettimeofday(&amp;tv, NULL);  // Get current time (seconds + microseconds)\n\n    time_t now = tv.tv_sec;\n    struct tm timeinfo;\n    localtime_r(&amp;now, &amp;timeinfo);  // Convert to local time\n\n    TinyDateTime_t result;\n    result.year   = timeinfo.tm_year + 1900;\n    result.month  = timeinfo.tm_mon + 1;\n    result.day    = timeinfo.tm_mday;\n    result.hour   = timeinfo.tm_hour;\n    result.minute = timeinfo.tm_min;\n    result.second = timeinfo.tm_sec;\n    result.microsecond = tv.tv_usec;\n\n    if (print_flag)\n    {\n        ESP_LOGI(TAG_TIME, \"Current Time: %04d-%02d-%02d %02d:%02d:%02d.%06ld\",\n                 result.year, result.month, result.day,\n                 result.hour, result.minute, result.second, tv.tv_usec);\n    }\n\n    return result;\n}\n</code></pre> \u4f7f\u7528\u53c2\u8003\uff1a</p> <pre><code>void app_main(void)\n{\n    // Initialize SNTP and sync time\n    sync_time_with_timezone(\"CST-8\");\n\n    // Get current time\n    TinyDateTime_t current_time = tiny_get_current_time(true);\n\n    // Print current time\n    ESP_LOGI(TAG_TIME, \"Current Time: %04d-%02d-%02d %02d:%02d:%02d.%06ld\",\n             current_time.year, current_time.month, current_time.day,\n             current_time.hour, current_time.minute, current_time.second, current_time.microsecond);\n}\n</code></pre> <p>\u4f7f\u7528\u6548\u679c\uff1a</p> <p></p> <p>Danger</p> <p>SNTP\u7684\u5bf9\u65f6\u7cbe\u5ea6\u5728 ms \u6c34\u5e73\u3002</p>"}]}