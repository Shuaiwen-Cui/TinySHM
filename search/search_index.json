{"config":{"lang":["en","zh"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TinySHM: Distributed Intelligence Enabling Framework for Structural Health Monitoring","text":""},{"location":"#about-this-project","title":"ABOUT THIS PROJECT","text":"<p>This project aims to develop an empowering framework that equips MCU-level IoT devices with distributed computing and intelligence capabilities to facilitate structural health monitoring applications. If you think this project is interesting, please give it a star and stay tuned.</p> <p>TinySHM</p> <p>\"TinySHM\" is a combination of \"Tiny\" and \"SHM\". \"Tiny\" means the codes are designed to run on MCU devices, while \"SHM\" stands for \"Structural Health Monitoring\".</p>"},{"location":"#target-hardware","title":"TARGET HARDWARE","text":"<ul> <li>MCU devices (ESP32 as the main target)</li> </ul>"},{"location":"#scope","title":"SCOPE","text":"<ul> <li>Basic Math Operations</li> <li>Digital Signal Processing</li> <li>TinyML / Edge AI</li> <li>Measurement</li> <li>System Identification</li> <li>Damage Monitoring, Localization, and Assessment</li> </ul>"},{"location":"ABOUT/about/","title":"TinySHM: Distributed Intelligence Enabling Framework for Structural Health Monitoring","text":""},{"location":"ABOUT/about/#project-overview","title":"PROJECT OVERVIEW","text":"<p>This project aims to develop an empowering framework that equips MCU-level IoT devices with distributed computing and intelligence capabilities to facilitate structural health monitoring applications. If you think this project is interesting, please give it a star and stay tuned.</p> <p>TinySHM</p> <p>\"TinySHM\" is a combination of \"Tiny\" and \"SHM\". \"Tiny\" means the codes are designed to run on MCU devices, while \"SHM\" stands for \"Structural Health Monitoring\".</p>"},{"location":"ABOUT/about/#target-hardware","title":"TARGET HARDWARE","text":"<ul> <li>MCU devices (currently targeting ESP32 as the main platform)</li> </ul>"},{"location":"ABOUT/about/#scope","title":"SCOPE","text":"<ul> <li>Basic Math Operations</li> <li>Digital Signal Processing</li> <li>TinyML / Edge AI</li> <li>Measurement</li> <li>System Identification</li> <li>Damage Monitoring, Localization, and Assessment</li> </ul>"},{"location":"ABOUT/about/#host-devkits","title":"HOST DEVKITS","text":"<p>Tip</p> <p>The following hardwares are for demonstration purposes only. This project is not limited to these and can be ported to other types of hardwares.</p> <ul> <li>DNESP32S3M from Alientek (ESP32-S3)</li> </ul> <p></p> <p></p> <ul> <li> <p> NexNode</p> <p>  Repo </p> <p>  Online Doc </p> </li> </ul>"},{"location":"ABOUT/about/#project-architecture","title":"PROJECT ARCHITECTURE","text":"<pre><code>+------------------------------+\n| APPLICATION                  |\n|   - measurement              | &lt;-- measurement / sensing\n|   - system_identification    | &lt;-- system identification\n|   - damage_detection         | &lt;-- damage detection, localization, and assessment\n+------------------------------+\n| MIDDLEWARE                   |\n|   - TinyToolbox              | &lt;-- Platform-specific Low-level Optimization + Various Utilities\n|   - TinyMath                 | &lt;-- Common Math Functions\n|   - TinyDSP                  | &lt;-- DSP Functions\n|   - TinyAI                   | &lt;-- AI Functions\n+------------------------------+\n| DRIVERS                      |\n+------------------------------+\n| HARDWARE                     |\n+------------------------------+\n</code></pre>"},{"location":"AI/ai/","title":"ARTIFICIAL INTELLIGENCE","text":""},{"location":"DSP/dsp/","title":"DIGITAL SIGNAL PROCESSING","text":""},{"location":"MATH/math/","title":"MATH OPERATIONS","text":""},{"location":"MEASUREMENT/code/","title":"CODE","text":"<p>Warning</p> <p>The following code should be based on the code in the release code, which may have been updated.</p>"},{"location":"MEASUREMENT/code/#cmakeliststxt","title":"CMakeLists.txt","text":"<pre><code>set(src_dirs\n    .\n)\n\nset(include_dirs\n    include\n)\n\nset(requires\n    driver\n    tim\n    esp_rtc\n    spi_sdcard\n    mpu6050\n    exit\n    lcd\n    led\n    wifi\n    esp32_mqtt\n    TinyAdapter\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"MEASUREMENT/code/#measurementh","title":"measurement.h","text":"<pre><code>/**\n * @file measurement.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the measurement module.\n * @version 1.0\n * @date 2025-04-01\n * @copyright Copyright (c) 2025\n * @note Currently, the sesning is realized by FreeRTOS, and therefore the upper limit sampling rate is 1kHz.\n * @todo Sampling by timer + interrupt\n * @todo Sampling by DMA\n */\n\n#ifndef __MEASUREMENT_H__\n#define __MEASUREMENT_H__\n\n/* DEPENDENCIES */\n// SYSTEM\n#include \"esp_system.h\" // ESP32 System\n#include \"esp_log.h\"    // ESP32 Logging\n\n// RTOS\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/event_groups.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/timers.h\"\n#include \"freertos/semphr.h\"\n\n// BSP\n#include \"driver/gptimer.h\"\n#include \"led.h\"\n#include \"lcd.h\"\n#include \"tim.h\"\n#include \"esp_rtc.h\"\n#include \"spi_sdcard.h\"\n#include \"wifi_wpa2_enterprise.h\"\n#include \"mqtt.h\"\n#include \"mpu6050.h\"\n\n// TinyAuton/TinySHM\n#include \"TinyAdapter.h\"\n\n/* VARIABLES */\nextern struct SenseConfig streamline_config; // Streamline configuration\nextern struct SenseConfig sense_config; // Sense configuration\n\n/* FUNCTIONS */\n/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters);\n\n/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters);\n\n#endif /* __MEASUREMENT_H__ */\n</code></pre>"},{"location":"MEASUREMENT/code/#measurementc","title":"measurement.c","text":"<pre><code>/**\n * @file measurement.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the source file for the measurement module.\n * @version 1.0\n * @date 2025-04-01\n * @copyright Copyright (c) 2025\n * @note Currently, the sesning is realized by FreeRTOS, and therefore the upper limit sampling rate is 1kHz.\n * @todo Sampling by timer + interrupt\n * @todo Sampling by DMA\n */\n\n/* DEPENDENCIES */\n#include \"measurement.h\"\n\n/* VARIABLES */\nstatic const char *TAG = \"TinySHM-Measurement\"; // Tag for logging\n\n// static uint8_t mpu6050_deviceid;    // MPU6050 Device ID\nstatic mpu6050_acce_value_t acce; // MPU6050 Accelerometer Value\n// static mpu6050_gyro_value_t gyro;   // MPU6050 Gyroscope Value\nstatic mpu6050_temp_value_t temp; // MPU6050 Temperature Value\n// static complimentary_angle_t angle; // Complimentary Angle\n\n/* DEFINITION */\nstruct SenseConfig\n{\n    int sample_rate;\n    int sample_duration;\n    bool temperature_sense; // whether to sense temperature\n    bool printout;          // not recommened for high sample rate as it will slow down the process\n    bool mqtt_pub;          // not recommened for high sample rate as it will slow down the process\n};\n\nstruct DataStruct\n{\n    int sample_rate;\n    int sample_duration;\n    float sensor_temperature;\n    TinyTimeMark_t start_time_stamp;\n    TinyTimeMark_t *time_stamp;\n    float *acc_data;\n    float *temperature;\n};\n\n/* VARIABLES */\n// for streamline configuration\nstruct SenseConfig streamline_config = {\n    .sample_rate = 1,          // Sample rate in Hz. For local printout + mqtt, at most 25Hz; for only mqtt, at most 200Hz.\n    .temperature_sense = true, // Whether to sense temperature\n    .printout = true,          // Only available for sampling rate &lt;= 100Hz\n    .mqtt_pub = true           // Only available for sampling rate &lt;= 100Hz\n};\n\n// for sensing configuration\nstruct SenseConfig sense_config = {\n    .sample_rate = 500,   // Sample rate in Hz, only can be (1, 2, 5, 10, 20, 25, 50, 100, 200, 500) for FreeRTOS based sensing. Note can not be 1000Hz (no time to feed the watchdog).\n    .sample_duration = 1, // Sample duration in seconds\n    .printout = true      // Only available for sampling rate &lt;= 100Hz\n};\n\n// for data structure\nstruct DataStruct data_struct = {\n    .sample_rate = 0,     // Sample rate in Hz\n    .sample_duration = 0, // Sample duration in seconds\n    .sensor_temperature = 0.0,\n    .start_time_stamp = 0,\n    .acc_data = NULL};\n\n/* FUNCTION PROTOTYPES */\n/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters)\n{\n\n    // streamline variables\n    float acc_x, acc_y, acc_z, temperature;\n    TinyTimeMark_t time_stamp;\n\n    // MQTT publish buffer\n    char streamline_buff[256];\n\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n\n    if (config-&gt;sample_rate &gt; 100 &amp;&amp; config-&gt;printout)\n    {\n        ESP_LOGW(TAG, \"Printout is disabled for sample rate &gt; 100Hz.\");\n        config-&gt;printout = false;\n    }\n\n    while (1)\n    {\n        // get the time stamp\n        time_stamp = tiny_get_running_time();\n\n        // get accelerometer data\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        acc_x = acce.acce_x;\n        acc_y = acce.acce_y;\n        acc_z = acce.acce_z;\n\n        // get temperature\n        mpu6050_get_temp(mpu6050, &amp;temp);\n        temperature = temp.temp;\n\n        // sprintf\n        if (config-&gt;printout || config-&gt;mqtt_pub)\n        {\n            snprintf(streamline_buff, sizeof(streamline_buff), \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Sensor Temperature: %4.2f \u00b0C\", time_stamp, acc_x, acc_y, acc_z, temperature);\n        }\n\n        // print out the data - comment out for higher sample rate\n        if (config-&gt;printout)\n        {\n            ESP_LOGI(TAG, \"%s\", streamline_buff);\n        }\n\n        // MQTT publish\n        if (config-&gt;mqtt_pub)\n        {\n            esp_mqtt_client_publish(s_mqtt_client, MQTT_PUBLIC_TOPIC, streamline_buff, strlen(streamline_buff), 0, 0); // for streamline, data quality is not expected to be high, so QoS = 0; data retaintion is also not required, so 0.\n        }\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n    ESP_LOGI(TAG, \"Streamline terminated. Task will delete itself.\");\n    vTaskDelete(NULL);\n}\n\n/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters)\n{\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n    int total_samples = config-&gt;sample_rate * config-&gt;sample_duration;\n\n    // Fill global data_struct\n    data_struct.sample_rate = config-&gt;sample_rate;\n    data_struct.sample_duration = config-&gt;sample_duration;\n    mpu6050_get_temp(mpu6050, &amp;temp);\n    data_struct.sensor_temperature = temp.temp;\n    data_struct.start_time_stamp = tiny_get_running_time();\n\n    // Allocate memory\n    data_struct.acc_data = malloc(sizeof(float) * 3 * total_samples);\n    data_struct.temperature = malloc(sizeof(float) * total_samples);\n    data_struct.time_stamp = malloc(sizeof(TinyTimeMark_t) * total_samples);\n\n    if (data_struct.acc_data == NULL || data_struct.temperature == NULL || data_struct.time_stamp == NULL)\n    {\n        ESP_LOGE(TAG, \"Failed to allocate memory for sensing data.\");\n        if (data_struct.acc_data)\n            free(data_struct.acc_data);\n        if (data_struct.temperature)\n            free(data_struct.temperature);\n        if (data_struct.time_stamp)\n            free(data_struct.time_stamp);\n        vTaskDelete(NULL);\n    }\n\n    ESP_LOGI(TAG, \"Sampling started: %d Hz for %d seconds (%d samples)\",\n             config-&gt;sample_rate, config-&gt;sample_duration, total_samples);\n\n    for (int i = 0; i &lt; total_samples; i++)\n    {\n        TinyTimeMark_t now = tiny_get_running_time();\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        mpu6050_get_temp(mpu6050, &amp;temp);\n\n        // Store data\n        data_struct.time_stamp[i] = now;\n        data_struct.acc_data[i * 3 + 0] = acce.acce_x;\n        data_struct.acc_data[i * 3 + 1] = acce.acce_y;\n        data_struct.acc_data[i * 3 + 2] = acce.acce_z;\n        data_struct.temperature[i] = temp.temp;\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n\n    ESP_LOGI(TAG, \"Sampling complete.\");\n\n    // Print metadata\n    ESP_LOGI(TAG, \"-----------------------------\");\n    ESP_LOGI(TAG, \"Sensor Temperature : %.2f \u00b0C\", data_struct.sensor_temperature);\n    ESP_LOGI(TAG, \"Start Time Stamp   : %ld\", (long)data_struct.start_time_stamp);\n    ESP_LOGI(TAG, \"Sample Rate        : %d Hz\", data_struct.sample_rate);\n    ESP_LOGI(TAG, \"Sample Duration    : %d sec\", data_struct.sample_duration);\n    ESP_LOGI(TAG, \"Total Samples      : %d\", total_samples);\n    ESP_LOGI(TAG, \"Data Size          : %.2f KB\",\n             (sizeof(float) * 4 + sizeof(TinyTimeMark_t)) * total_samples / 1024.0f);\n    ESP_LOGI(TAG, \"-----------------------------\");\n\n    // Print collected data if enabled\n    if (config-&gt;printout)\n    {\n        for (int i = 0; i &lt; total_samples; i++)\n        {\n            ESP_LOGI(TAG, \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Temperature: %.2f \u00b0C\",\n                     (long)data_struct.time_stamp[i],\n                     data_struct.acc_data[i * 3 + 0],\n                     data_struct.acc_data[i * 3 + 1],\n                     data_struct.acc_data[i * 3 + 2],\n                     data_struct.temperature[i]);\n\n            // Release CPU for a short time to avoid blocking\n            if ((i % 10) == 0)\n            {\n                vTaskDelay(pdMS_TO_TICKS(10));\n            }\n        }\n    }\n\n    // Free allocated memory\n    if (data_struct.acc_data)\n    {\n        free(data_struct.acc_data);\n        data_struct.acc_data = NULL;\n    }\n    if (data_struct.temperature)\n    {\n        free(data_struct.temperature);\n        data_struct.temperature = NULL;\n    }\n    if (data_struct.time_stamp)\n    {\n        free(data_struct.time_stamp);\n        data_struct.time_stamp = NULL;\n    }\n\n    vTaskDelete(NULL);\n}\n</code></pre>"},{"location":"MEASUREMENT/log/","title":"DEV LOG","text":"<p>2025-04-03</p> <ul> <li>Sampling configuration structure</li> <li>Sampling data structure</li> <li>Real-time sampling function / regular sampling function</li> <li>Sampling frequency upper limit test: real-time (25Hz-local output + MQTT; 200Hz-only MQTT); regular (500Hz)</li> <li>Server-side visualization program</li> <li>Server-side data storage</li> </ul>"},{"location":"MEASUREMENT/measurement/","title":"MEASUREMENT","text":"<p>Measurement</p> <p>High quality measurement/sampling is the basis of data analysis, and TinySHM fully considers this in its design. We have implemented a variety of measurement/sampling methods in TinySHM, and users can choose according to their needs.</p> <p>Warning</p> <p>Currently, development is based on ESP32, and migration to platforms like STM32 will require some modifications to the adaptation layer.</p>"},{"location":"MEASUREMENT/notes/","title":"NOTES","text":""},{"location":"MEASUREMENT/notes/#dependencies","title":"DEPENDENCIES","text":"<p>SYSTEM</p> <pre><code>#include \"esp_system.h\" // ESP32 System\n#include \"esp_log.h\"    // ESP32 Logging\n</code></pre> <p>RTOS</p> <pre><code>#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/event_groups.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/timers.h\"\n#include \"freertos/semphr.h\"\n</code></pre> <p>BSP</p> <pre><code>#include \"driver/gptimer.h\"\n#include \"led.h\"\n#include \"lcd.h\"\n#include \"tim.h\"\n#include \"esp_rtc.h\"\n#include \"spi_sdcard.h\"\n#include \"wifi_wpa2_enterprise.h\"\n#include \"mqtt.h\"\n#include \"mpu6050.h\"\n</code></pre> <p>TinyAuton/TinySHM</p> <pre><code>#include \"TinyAdapter.h\"\n</code></pre>"},{"location":"MEASUREMENT/notes/#sampling-configuration-struct","title":"SAMPLING CONFIGURATION STRUCT","text":"<p>Definition</p> <pre><code>struct SenseConfig\n{\n    int sample_rate;\n    int sample_duration;\n    bool temperature_sense; // whether to sense temperature\n    bool printout;          // not recommened for high sample rate as it will slow down the process\n    bool mqtt_pub;          // not recommened for high sample rate as it will slow down the process\n};\n</code></pre> <p>Usage - Streamline</p> <pre><code>// for streamline configuration\nstruct SenseConfig streamline_config = {\n    .sample_rate = 1,          // Sample rate in Hz. For local printout + mqtt, at most 25Hz; for only mqtt, at most 200Hz.\n    .temperature_sense = true, // Whether to sense temperature\n    .printout = true,          // Only available for sampling rate &lt;= 100Hz\n    .mqtt_pub = true           // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre> <p>Usage - Normal</p> <pre><code>// for sensing configuration\nstruct SenseConfig sense_config = {\n    .sample_rate = 500,   // Sample rate in Hz, only can be (1, 2, 5, 10, 20, 25, 50, 100, 200, 500) for FreeRTOS based sensing. Note can not be 1000Hz (no time to feed the watchdog).\n    .sample_duration = 1, // Sample duration in seconds\n    .printout = true      // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre>"},{"location":"MEASUREMENT/notes/#sampling-data-struct","title":"SAMPLING DATA STRUCT","text":"<pre><code>struct DataStruct\n{\n    int sample_rate;\n    int sample_duration;\n    float sensor_temperature;\n    TinyTimeMark_t start_time_stamp;\n    TinyTimeMark_t *time_stamp;\n    float *acc_data;\n    float *temperature;\n};\n</code></pre> <p>usage</p> <pre><code>// for data structure\nstruct DataStruct data_struct = {\n    .sample_rate = 0,     // Sample rate in Hz\n    .sample_duration = 0, // Sample duration in seconds\n    .sensor_temperature = 0.0,\n    .start_time_stamp = 0,\n    .acc_data = NULL}; \n</code></pre>"},{"location":"MEASUREMENT/notes/#sampling-principle","title":"SAMPLING PRINCIPLE","text":"<ul> <li>FreeRTOS based sampling</li> <li>Timer &amp; Interrupt based sampling (to be developed)</li> </ul>"},{"location":"MEASUREMENT/notes/#sampling-modes-and-tasks","title":"SAMPLING MODES AND TASKS","text":"<p>Currently, there are two sampling modes: - Streamline mode - Normal mode</p>"},{"location":"MEASUREMENT/notes/#streamline-sampling","title":"Streamline Sampling","text":"<p>Definition</p> <pre><code>/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters)\n{\n\n    // streamline variables\n    float acc_x, acc_y, acc_z, temperature;\n    TinyTimeMark_t time_stamp;\n\n    // MQTT publish buffer\n    char streamline_buff[256];\n\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n\n    if (config-&gt;sample_rate &gt; 100 &amp;&amp; config-&gt;printout)\n    {\n        ESP_LOGW(TAG, \"Printout is disabled for sample rate &gt; 100Hz.\");\n        config-&gt;printout = false;\n    }\n\n    while (1)\n    {\n        // get the time stamp\n        time_stamp = tiny_get_running_time();\n\n        // get accelerometer data\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        acc_x = acce.acce_x;\n        acc_y = acce.acce_y;\n        acc_z = acce.acce_z;\n\n        // get temperature\n        mpu6050_get_temp(mpu6050, &amp;temp);\n        temperature = temp.temp;\n\n        // sprintf\n        if (config-&gt;printout || config-&gt;mqtt_pub)\n        {\n            snprintf(streamline_buff, sizeof(streamline_buff), \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Sensor Temperature: %4.2f \u00b0C\", time_stamp, acc_x, acc_y, acc_z, temperature);\n        }\n\n        // print out the data - comment out for higher sample rate\n        if (config-&gt;printout)\n        {\n            ESP_LOGI(TAG, \"%s\", streamline_buff);\n        }\n\n        // MQTT publish\n        if (config-&gt;mqtt_pub)\n        {\n            esp_mqtt_client_publish(s_mqtt_client, MQTT_PUBLIC_TOPIC, streamline_buff, strlen(streamline_buff), 0, 0); // for streamline, data quality is not expected to be high, so QoS = 0; data retaintion is also not required, so 0.\n        }\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n    ESP_LOGI(TAG, \"Streamline terminated. Task will delete itself.\");\n    vTaskDelete(NULL);\n}\n</code></pre> <p>Usage</p> <pre><code>xTaskCreate(acc_streamline_task, \"Accel_Streamline_Task\", 4096, &amp;streamline_config, 5, NULL);\n</code></pre>"},{"location":"MEASUREMENT/notes/#normal-sampling","title":"Normal Sampling","text":"<p>Definition</p> <pre><code>/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters)\n{\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n    int total_samples = config-&gt;sample_rate * config-&gt;sample_duration;\n\n    // Fill global data_struct\n    data_struct.sample_rate = config-&gt;sample_rate;\n    data_struct.sample_duration = config-&gt;sample_duration;\n    mpu6050_get_temp(mpu6050, &amp;temp);\n    data_struct.sensor_temperature = temp.temp;\n    data_struct.start_time_stamp = tiny_get_running_time();\n\n    // Allocate memory\n    data_struct.acc_data = malloc(sizeof(float) * 3 * total_samples);\n    data_struct.temperature = malloc(sizeof(float) * total_samples);\n    data_struct.time_stamp = malloc(sizeof(TinyTimeMark_t) * total_samples);\n\n    if (data_struct.acc_data == NULL || data_struct.temperature == NULL || data_struct.time_stamp == NULL)\n    {\n        ESP_LOGE(TAG, \"Failed to allocate memory for sensing data.\");\n        if (data_struct.acc_data)\n            free(data_struct.acc_data);\n        if (data_struct.temperature)\n            free(data_struct.temperature);\n        if (data_struct.time_stamp)\n            free(data_struct.time_stamp);\n        vTaskDelete(NULL);\n    }\n\n    ESP_LOGI(TAG, \"Sampling started: %d Hz for %d seconds (%d samples)\",\n             config-&gt;sample_rate, config-&gt;sample_duration, total_samples);\n\n    for (int i = 0; i &lt; total_samples; i++)\n    {\n        TinyTimeMark_t now = tiny_get_running_time();\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        mpu6050_get_temp(mpu6050, &amp;temp);\n\n        // Store data\n        data_struct.time_stamp[i] = now;\n        data_struct.acc_data[i * 3 + 0] = acce.acce_x;\n        data_struct.acc_data[i * 3 + 1] = acce.acce_y;\n        data_struct.acc_data[i * 3 + 2] = acce.acce_z;\n        data_struct.temperature[i] = temp.temp;\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n\n    ESP_LOGI(TAG, \"Sampling complete.\");\n\n    // Print metadata\n    ESP_LOGI(TAG, \"-----------------------------\");\n    ESP_LOGI(TAG, \"Sensor Temperature : %.2f \u00b0C\", data_struct.sensor_temperature);\n    ESP_LOGI(TAG, \"Start Time Stamp   : %ld\", (long)data_struct.start_time_stamp);\n    ESP_LOGI(TAG, \"Sample Rate        : %d Hz\", data_struct.sample_rate);\n    ESP_LOGI(TAG, \"Sample Duration    : %d sec\", data_struct.sample_duration);\n    ESP_LOGI(TAG, \"Total Samples      : %d\", total_samples);\n    ESP_LOGI(TAG, \"Data Size          : %.2f KB\",\n             (sizeof(float) * 4 + sizeof(TinyTimeMark_t)) * total_samples / 1024.0f);\n    ESP_LOGI(TAG, \"-----------------------------\");\n\n    // Print collected data if enabled\n    if (config-&gt;printout)\n    {\n        for (int i = 0; i &lt; total_samples; i++)\n        {\n            ESP_LOGI(TAG, \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Temperature: %.2f \u00b0C\",\n                     (long)data_struct.time_stamp[i],\n                     data_struct.acc_data[i * 3 + 0],\n                     data_struct.acc_data[i * 3 + 1],\n                     data_struct.acc_data[i * 3 + 2],\n                     data_struct.temperature[i]);\n\n            // Release CPU for a short time to avoid blocking\n            if ((i % 10) == 0)\n            {\n                vTaskDelay(pdMS_TO_TICKS(10));\n            }\n        }\n    }\n\n    // Free allocated memory\n    if (data_struct.acc_data)\n    {\n        free(data_struct.acc_data);\n        data_struct.acc_data = NULL;\n    }\n    if (data_struct.temperature)\n    {\n        free(data_struct.temperature);\n        data_struct.temperature = NULL;\n    }\n    if (data_struct.time_stamp)\n    {\n        free(data_struct.time_stamp);\n        data_struct.time_stamp = NULL;\n    }\n\n    vTaskDelete(NULL);\n}\n</code></pre> <p>Usage</p> <pre><code>xTaskCreate(acc_sense_task, \"Accel_Sense_Task\", 8192, &amp;sense_config, 5, NULL);\n</code></pre>"},{"location":"MEASUREMENT/notes/#to-be-developed","title":"TO BE DEVELOPED","text":"<ul> <li>Standard time stamp</li> <li>Calibration</li> <li>Timer &amp; Interrupt based sampling</li> <li>DMA</li> <li>ADC + Analog Sensor</li> <li>Data post-processing</li> <li>Batch data MQTT upload</li> <li>Real-time processing function development</li> </ul>"},{"location":"RELEASES/releases/","title":"RELEASES","text":""},{"location":"RELEASES/releases/#dnesp32s3m-stable","title":"DNESP32S3M-STABLE","text":"<p>Stable version</p>"},{"location":"RELEASES/releases/#dnesp32s3m-latest","title":"DNESP32S3M-LATEST","text":"<p>Latest feature version</p>"},{"location":"TOOLBOX/code/","title":"CODE","text":"<p>Warning</p> <p>The following code should be based on the code in the release code, which may have been updated.</p>"},{"location":"TOOLBOX/code/#cmakeliststxt","title":"CMakeLists.txt","text":"<pre><code>set(src_dirs\n    .\n)\n\nset(include_dirs\n    include\n)\n\nset(requires\n    esp_timer\n    espressif__esp-dsp\n    espressif__esp_jpeg\n    espressif__esp-dl\n)\n\nidf_component_register(SRC_DIRS ${src_dirs} INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})\n</code></pre>"},{"location":"TOOLBOX/code/#tinytoolboxh","title":"TinyToolbox.h","text":"<pre><code>/**\n * @file TinyToolbox.h\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the header file for the TinyToolbox middleware.\n * @version 1.0\n * @date 2025-03-26\n * @copyright Copyright (c) 2025\n *\n */\n\n#ifndef __TINYTOOLBOX__\n#define __TINYTOOLBOX__\n\n/* CONFIGURATIONS */\n\n/* DEPENDENCIES */\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n#include \"esp_timer.h\"\n#include \"esp_heap_caps.h\"\n#include \"esp_dsp.h\"\n// #include \"esp_dl.h\"\n\n/* DEFINITIONS */\ntypedef TickType_t TinyTimeMark_t;\n\n/* FUNCTIONS */\nTinyTimeMark_t tiny_get_running_time(void);\n\n#endif /* __TINYTOOLBOX__ */\n</code></pre>"},{"location":"TOOLBOX/code/#tinytoolboxc","title":"TinyToolbox.c","text":"<pre><code>/**\n * @file TinyToolbox.c\n * @author SHUAIWEN CUI (SHUAIWEN001@e.ntu.edu.sg)\n * @brief This file is the source file for the TinyToolbox middleware.\n * @version 1.0\n * @date 2025-03-26\n *\n * @copyright Copyright (c) 2025\n *\n */\n\n/* DEPENDENCIES */\n#include \"TinyToolbox.h\"\n\n/* DEFINITIONS */\n\n/* FUNCTIONS */\nTinyTimeMark_t tiny_get_running_time(void)\n{\n    return esp_timer_get_time();\n}\n</code></pre>"},{"location":"TOOLBOX/log/","title":"DEV LOG","text":"<p>2025-04-08</p> <ul> <li>Running time query function tiny_get_running_time()</li> </ul>"},{"location":"TOOLBOX/notes/","title":"NOTES","text":""},{"location":"TOOLBOX/notes/#dependencies","title":"DEPENDENCIES","text":"<p>FreeRTOS</p> <pre><code>#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n</code></pre> <p>log</p> <pre><code>#include \"esp_log.h\"\n</code></pre> <p>timer</p> <pre><code>#include \"esp_timer.h\"\n</code></pre>"},{"location":"TOOLBOX/notes/#running-time-query","title":"RUNNING TIME QUERY","text":"<p>We first define a new data type based on ESP32 built-in data type</p> <pre><code>typedef TickType_t TinyTimeMark_t;\n</code></pre> <p>Then we define a function in the adaptation layer to get the current system running time since startup, in microseconds</p> <pre><code>TinyTimeMark_t tiny_get_running_time(void)\n{\n    return esp_timer_get_time();\n}\n</code></pre>"},{"location":"TOOLBOX/toolbox/","title":"TOOLBOX","text":"<p>TinyToolbox</p> <p>TinyToolbox is a library designed for platform adaptation and optimization, providing various practical tools to serve edge computing and application development. Note that the adaptation and tools are included in the same library because many tools utilize the functions provided by the platform at a lower level. Therefore, placing platform adaptation and various tools together facilitates usage and maintenance.</p> <p>Warning</p> <p>Currently, development is based on ESP32, and migration to platforms like STM32 requires some modifications to the adaptation layer.</p>"},{"location":"TOOLBOX/toolbox/#feature-overview","title":"FEATURE OVERVIEW","text":""},{"location":"TOOLBOX/toolbox/#time","title":"TIME","text":"<ul> <li>Get Running Time: <code>tiny_get_running_time()</code></li> <li>SNTP Time Synchronization: <code>sync_time_with_timezone(\"CST-8\")</code></li> <li>Get World Time: <code>tiny_get_current_time(1)</code></li> </ul> <p>TODO:</p> <ul> <li>Local Time Synchronization for Wireless Sensor Networks - Microsecond Level</li> </ul>"},{"location":"TOOLBOX/TIME/time/","title":"TIME","text":"<p>Time</p> <p>Time related functions are of vital importance for MCU devices. This section provides a series of time related definitions and functions for developers to use.</p> <p>In MCU, time can be divided into the following types:</p> <ul> <li> <p>Running Time: The time from the power-on of the MCU to now.</p> </li> <li> <p>World Time: The time of the time zone where the MCU is located. World time can be represented by standard year, month, day, hour, minute, and second, or it can be represented as a UNIX timestamp.</p> </li> </ul>"},{"location":"TOOLBOX/TIME/time/#running-time","title":"RUNNING TIME","text":"<p>ESP has its own function to get the running time, <code>esp_timer_get_time</code>, which depends on the <code>esp_timer</code> library. This function returns the time from power-on to now, in microseconds.</p> <p>To facilitate usage, TinyToolbox redefines the data type <code>TinyTimeMark_t</code> and provides a function <code>tiny_get_running_time</code> to get the running time. The time returned by this function is in the unit of TickType_t, which is the time unit defined in FreeRTOS.</p> <pre><code>typedef TickType_t TinyTimeMark_t;\n</code></pre> <pre><code>/**\n * @brief Get the running time in microseconds\n * @return TinyTimeMark_t\n */\nTinyTimeMark_t tiny_get_running_time(void)\n{\n    return esp_timer_get_time();\n}\n</code></pre> <p>Usage reference:</p> <pre><code>void app_main(void)\n{\n    // Get running time\n    TinyTimeMark_t running_time = tiny_get_running_time();\n    ESP_LOGI(TAG_TIME, \"Running Time: %lld us\", running_time);\n}\n</code></pre>"},{"location":"TOOLBOX/TIME/time/#world-time","title":"WORLD TIME","text":"<p>Warning</p> <p>Note that obtaining world time requires a successful network connection. In other words, the function to obtain world time needs to be called after the network connection is successfully established.</p>"},{"location":"TOOLBOX/TIME/time/#ntp-time-synchronization","title":"NTP TIME SYNCHRONIZATION","text":"<p>NTP Time Synchronization</p> <p>NTP (Network Time Protocol) is a protocol used to synchronize time in computer networks. It can obtain accurate time information through the Internet or local area network. NTP protocol uses UDP for communication, with the default port being 123. NTP servers periodically send time information to clients, and clients adjust their system time based on this information.</p> <pre><code>    Client                      Server\n      |-------------------&gt;      |     T1\uff1aRequest sent\n      |                         |\n      |        &lt;--------------- |     T2/T3\uff1aServer received &amp; replied\n      |                         |\n      |-------------------&gt;      |     T4\uff1aClient received response\n</code></pre> <p>NTP Time Synchronization Principle</p> <p>NTP time synchronization is based on four timestamps: 1. Timestamp T1 when the client sends the request 2. Timestamp T2 when the server receives the request 3. Timestamp T3 when the server sends the response 4. Timestamp T4 when the client receives the response. Based on these four timestamps, we can calculate Network Delay Delay = (T4 - T1) - (T3 - T2), and Time Offset Offset = ((T2 - T1) + (T3 - T4)) / 2.</p> <p>ESP32 SNTP Time Synchronization</p> <p>In ESP32, SNTP (Simple Network Time Protocol) is used. SNTP is a simplified version of NTP, suitable for scenarios where time accuracy is not critical. The time synchronization in ESP32 relies on the <code>esp_sntp</code> library. The working principle of SNTP is similar to that of NTP, but the implementation of SNTP is relatively simple, making it suitable for embedded devices. Its accuracy is usually at the millisecond level, which is sufficient for most application scenarios.</p> <p>First, define a callback function to receive time synchronization notifications:</p> <p><pre><code>/* WORLD CURRENT TIME - SNTP */\n/**\n * @brief Callback function for time synchronization notification\n * @param tv Pointer to the timeval structure containing the synchronized time\n * @return None\n */\nvoid time_sync_notification_cb(struct timeval *tv)\n{\n    ESP_LOGI(TAG_SNTP, \"Time synchronized!\");\n}\n</code></pre> Next is the SNTP initialization function, which is also the core function of time synchronization. It is usually called when the system is initialized and the network is connected. Note that the time synchronization server address can be modified as needed. After the time synchronization is completed, ESP32 will set the local time at the bottom layer.</p> <pre><code>/**\n * @brief Initialize SNTP\n * @return None\n */\nvoid initialize_sntp(void)\n{\n    ESP_LOGI(TAG_SNTP, \"Initializing SNTP\");\n    sntp_setoperatingmode(SNTP_OPMODE_POLL);\n    sntp_setservername(0, \"pool.ntp.org\"); // NTP server // pool.ntp.org // ntp.aliyun.com\n    sntp_set_time_sync_notification_cb(time_sync_notification_cb);\n    sntp_init();\n}\n</code></pre> <p>Next is a further encapsulation of the above functions, including time zone settings. Note that the following function includes the RTC setting <code>rtc_set_time</code>, which depends on the RTC driver at the driver layer. Here I use my custom rtc driver, if there is no related function, you can comment it out directly.</p> <pre><code>/**\n * @brief Obtain the current time with timezone\n * @param timezone_str Timezone string (e.g., \"CST-8\")\n * @note The timezone string should be in the format \"TZ=GMT+/-HH:MM\"\n * @note To use this function, in application, after internet connection, insert \"sync_time_with_timezone(\"CST-8\");\" will do\n * @return None\n */\nvoid sync_time_with_timezone(const char *timezone_str)\n{\n    // Set system timezone\n    setenv(\"TZ\", timezone_str, 1);\n    tzset();\n\n    // Initialize SNTP and start time sync\n    initialize_sntp();\n\n    // Wait for system time to be set\n    time_t now = 0;\n    struct tm timeinfo = { 0 };\n    int retry = 0;\n    const int retry_count = 15;\n\n    while (timeinfo.tm_year &lt; (2020 - 1900) &amp;&amp; ++retry &lt; retry_count) {\n        ESP_LOGI(TAG_SNTP, \"Waiting for system time to be set... (%d/%d)\", retry, retry_count);\n        vTaskDelay(2000 / portTICK_PERIOD_MS);\n        time(&amp;now);\n        localtime_r(&amp;now, &amp;timeinfo);\n    }\n\n    if (timeinfo.tm_year &gt;= (2020 - 1900)) {\n        rtc_set_time(timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday,\n                    timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec); // defined in esp_rtc.c\n        ESP_LOGI(TAG_SNTP, \"System time is set.\");\n    } else {\n        ESP_LOGW(TAG_SNTP, \"Failed to sync time.\");\n        return;\n    }\n\n    // Log current local time\n    ESP_LOGI(TAG_SNTP, \"Current time: %s\", asctime(&amp;timeinfo));\n\n    // vTaskDelay(10000 / portTICK_PERIOD_MS); // Wait for 10 second\n    // rtc_get_time(); // uncomment to check the RTC time\n    // ESP_LOGI(TAG_SNTP, \"Current RTC time: %04d-%02d-%02d %02d:%02d:%02d\",\n    //          calendar.year, calendar.month, calendar.date,\n    //          calendar.hour, calendar.min, calendar.sec); // uncomment to check the RTC time\n\n}\n</code></pre>"},{"location":"TOOLBOX/TIME/time/#world-time-getting","title":"WORLD TIME GETTING","text":"<p>In order to facilitate the acquisition of world time, we first define a data structure <code>DateTime_t</code> to store information such as year, month, day, hour, minute, and second. Then we define a function <code>tiny_get_current_time</code> to obtain the current world time. This function returns a <code>DateTime_t</code> structure, which contains the current year, month, day, hour, minute, and second information. When using it, pass in a Boolean value <code>print_flag</code> to control whether to print the current time.</p> <pre><code>/**\n * @brief Structure to hold date and time\n */\ntypedef struct TinyDateTime_t\n{\n    int year;\n    int month;\n    int day;\n    int hour;\n    int minute;\n    int second;\n    long microsecond;\n} TinyDateTime_t; \n</code></pre> <pre><code>/* WORLD CURRENT TIME - GET TIME */\n/**\n * @name tiny_get_current_time\n * @brief Get the current time as a TinyDateTime_t struct\n * @param print_flag Flag to indicate whether to print the time\n * @return TinyDateTime_t structure containing the current date and time\n */\nTinyDateTime_t tiny_get_current_time(bool print_flag)\n{\n    struct timeval tv;\n    gettimeofday(&amp;tv, NULL);  // Get current time (seconds + microseconds)\n\n    time_t now = tv.tv_sec;\n    struct tm timeinfo;\n    localtime_r(&amp;now, &amp;timeinfo);  // Convert to local time\n\n    TinyDateTime_t result;\n    result.year   = timeinfo.tm_year + 1900;\n    result.month  = timeinfo.tm_mon + 1;\n    result.day    = timeinfo.tm_mday;\n    result.hour   = timeinfo.tm_hour;\n    result.minute = timeinfo.tm_min;\n    result.second = timeinfo.tm_sec;\n    result.microsecond = tv.tv_usec;\n\n    if (print_flag)\n    {\n        ESP_LOGI(TAG_TIME, \"Current Time: %04d-%02d-%02d %02d:%02d:%02d.%06ld\",\n                 result.year, result.month, result.day,\n                 result.hour, result.minute, result.second, tv.tv_usec);\n    }\n\n    return result;\n}\n</code></pre> <p>Usage</p> <pre><code>void app_main(void)\n{\n    // Initialize SNTP and sync time\n    sync_time_with_timezone(\"CST-8\");\n\n    // Get current time\n    TinyDateTime_t current_time = tiny_get_current_time(true);\n\n    // Print current time\n    ESP_LOGI(TAG_TIME, \"Current Time: %04d-%02d-%02d %02d:%02d:%02d.%06ld\",\n             current_time.year, current_time.month, current_time.day,\n             current_time.hour, current_time.minute, current_time.second, current_time.microsecond);\n}\n</code></pre>"},{"location":"blog/","title":"Blog","text":""},{"location":"zh/","title":"TinySHM\uff1a\u7528\u4e8e\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u7684\u5206\u5e03\u5f0f\u667a\u80fd\u6846\u67b6","text":""},{"location":"zh/#_1","title":"\u5173\u4e8e\u672c\u9879\u76ee","text":"<p>\u8be5\u9879\u76ee\u65e8\u5728\u5f00\u53d1\u4e00\u4e2a\u8d4b\u80fd\u6846\u67b6\uff0c\u4f7fMCU\u7ea7\u522b\u7684\u7269\u8054\u7f51\u8bbe\u5907\u5177\u5907\u5206\u5e03\u5f0f\u8ba1\u7b97\u548c\u667a\u80fd\u80fd\u529b\uff0c\u4ece\u800c\u63d0\u5347\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u5e94\u7528\u7684\u6548\u679c\u3002\u5982\u679c\u4f60\u5bf9\u8fd9\u4e2a\u9879\u76ee\u611f\u5174\u8da3\uff0c\u8bf7\u7ed9\u4e2a\u661f\u5e76\u4fdd\u6301\u5173\u6ce8\u3002</p> <p>TinySHM</p> <p>\"TinySHM\" \u662f \"Tiny\" \u548c \"SHM\" \u7684\u7ec4\u5408\u3002\"Tiny\" \u610f\u5473\u7740\u4ee3\u7801\u88ab\u8bbe\u8ba1\u4e3a\u8fd0\u884c\u5728 MCU \u8bbe\u5907\u4e0a\uff0c\u800c \"SHM\" \u662f \"Structural Health Monitoring\" \u7684\u7f29\u5199\u3002</p>"},{"location":"zh/#_2","title":"\u76ee\u6807\u786c\u4ef6","text":"<ul> <li>MCU \u8bbe\u5907\uff08\u4ee5 ESP32 \u4e3a\u4e3b\u8981\u76ee\u6807\uff09</li> </ul>"},{"location":"zh/#_3","title":"\u8303\u56f4","text":"<ul> <li>\u57fa\u672c\u6570\u5b66\u8fd0\u7b97</li> <li>\u6570\u5b57\u4fe1\u53f7\u5904\u7406</li> <li>TinyML / \u8fb9\u7f18\u4eba\u5de5\u667a\u80fd</li> <li>\u6d4b\u91cf</li> <li>\u7cfb\u7edf\u8bc6\u522b</li> <li>\u635f\u4f24\u76d1\u6d4b\u3001\u5b9a\u4f4d\u3001\u8bc4\u4f30</li> </ul>"},{"location":"zh/#_4","title":"TinySHM\uff1a\u7528\u4e8e\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u7684\u5206\u5e03\u5f0f\u667a\u80fd\u6846\u67b6","text":""},{"location":"zh/ABOUT/about/","title":"TinySHM\uff1a\u7528\u4e8e\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u7684\u5206\u5e03\u5f0f\u667a\u80fd\u6846\u67b6","text":""},{"location":"zh/ABOUT/about/#_1","title":"\u9879\u76ee\u6982\u8ff0","text":"<p>\u8be5\u9879\u76ee\u65e8\u5728\u5f00\u53d1\u4e00\u4e2a\u8d4b\u80fd\u6846\u67b6\uff0c\u4f7fMCU\u7ea7\u522b\u7684\u7269\u8054\u7f51\u8bbe\u5907\u5177\u5907\u5206\u5e03\u5f0f\u8ba1\u7b97\u548c\u667a\u80fd\u80fd\u529b\uff0c\u4ece\u800c\u63d0\u5347\u7ed3\u6784\u5065\u5eb7\u76d1\u6d4b\u5e94\u7528\u7684\u6548\u679c\u3002\u5982\u679c\u4f60\u5bf9\u8fd9\u4e2a\u9879\u76ee\u611f\u5174\u8da3\uff0c\u8bf7\u7ed9\u4e2a\u661f\u5e76\u4fdd\u6301\u5173\u6ce8\u3002</p> <p>TinySHM</p> <p>\"TinySHM\" \u662f \"Tiny\" \u548c \"SHM\" \u7684\u7ec4\u5408\u3002\"Tiny\" \u610f\u5473\u7740\u4ee3\u7801\u88ab\u8bbe\u8ba1\u4e3a\u8fd0\u884c\u5728 MCU \u8bbe\u5907\u4e0a\uff0c\u800c \"SHM\" \u662f \"Structural Health Monitoring\" \u7684\u7f29\u5199\u3002</p>"},{"location":"zh/ABOUT/about/#_2","title":"\u76ee\u6807\u786c\u4ef6","text":"<ul> <li>MCU \u8bbe\u5907\uff08\u76ee\u524d\u4ee5 ESP32 \u4e3a\u4e3b\u8981\u76ee\u6807\uff09</li> </ul>"},{"location":"zh/ABOUT/about/#_3","title":"\u8986\u76d6\u8303\u56f4","text":"<ul> <li>\u57fa\u672c\u6570\u5b66\u8fd0\u7b97</li> <li>\u6570\u5b57\u4fe1\u53f7\u5904\u7406</li> <li>TinyML / \u8fb9\u7f18\u4eba\u5de5\u667a\u80fd</li> <li>\u6d4b\u91cf</li> <li>\u7cfb\u7edf\u8bc6\u522b</li> <li>\u635f\u4f24\u76d1\u6d4b\u3001\u5b9a\u4f4d\u3001\u8bc4\u4f30</li> </ul>"},{"location":"zh/ABOUT/about/#_4","title":"\u5f00\u53d1\u8f7d\u4f53","text":"<p>Tip</p> <p>\u4ee5\u4e0b\u786c\u4ef6\u4ec5\u505a\u5c55\u793a\u7528\u9014\uff0c\u672c\u9879\u76ee\u5e76\u4e0d\u5c40\u9650\u4e8e\u6b64\uff0c\u53ef\u4ee5\u79fb\u690d\u5230\u5176\u4ed6\u7c7b\u578b\u7684\u786c\u4ef6\u4e0a\u3002</p> <ul> <li>Alientek \u7684 DNESP32S3M\uff08ESP32-S3\uff09</li> </ul> <p></p> <p></p> <ul> <li> <p> NexNode</p> <p>  \u4ee3\u7801 </p> <p>  \u6587\u6863 </p> </li> </ul>"},{"location":"zh/ABOUT/about/#_5","title":"\u9879\u76ee\u67b6\u6784","text":"<pre><code>+------------------------------+\n| \u5e94\u7528\u5c42                        |\n|   - measurement              | &lt;-- \u6d4b\u91cf\n|   - system_identification    | &lt;-- \u7cfb\u7edf\u8bc6\u522b\n|   - damage_detection         | &lt;-- \u635f\u4f24\u68c0\u6d4b,\u5b9a\u4f4d\u548c\u8bc4\u4f30\n+------------------------------+\n| \u4e2d\u95f4\u4ef6                        |\n|   - TinyToolbox              | &lt;-- \u5e73\u53f0\u5e95\u5c42\u4f18\u5316 + \u5404\u79cd\u5de5\u5177\n|   - TinyMath                 | &lt;-- \u5e38\u7528\u6570\u5b66\u51fd\u6570\n|   - TinyDSP                  | &lt;-- DSP \u51fd\u6570\n|   - TinyAI                   | &lt;-- AI \u51fd\u6570\n+------------------------------+\n| \u9a71\u52a8\u5c42                        |\n+------------------------------+\n| \u786c\u4ef6\u5c42                        |\n+------------------------------+\n</code></pre>"},{"location":"zh/AI/ai/","title":"\u4eba\u5de5\u667a\u80fd","text":""},{"location":"zh/DSP/dsp/","title":"\u6570\u5b57\u4fe1\u53f7\u5904\u7406","text":""},{"location":"zh/MATH/math/","title":"\u6570\u5b66\u8fd0\u7b97","text":""},{"location":"zh/MEASUREMENT/code/","title":"\u4ee3\u7801","text":"<p>\u6ce8\u610f</p> <p>\u4ee5\u4e0b\u4ee3\u7801\u5e94\u4ee5\u53d1\u5e03\u4ee3\u7801\u4e2d\u7684\u4ee3\u7801\u4e3a\u51c6\uff0c\u53ef\u80fd\u4f1a\u6709\u66f4\u65b0\u3002</p>"},{"location":"zh/MEASUREMENT/log/","title":"\u5f00\u53d1\u65e5\u5fd7","text":"<p>2025-04-03</p> <ul> <li>\u91c7\u6837\u914d\u7f6e\u7ed3\u6784\u4f53</li> <li>\u91c7\u6837\u6570\u636e\u7ed3\u6784\u4f53</li> <li>\u5b9e\u65f6\u91c7\u6837\u51fd\u6570/\u5e38\u89c4\u91c7\u6837\u51fd\u6570</li> <li>\u91c7\u6837\u9891\u7387\u9891\u7387\u4e0a\u9650\u6d4b\u8bd5\uff1a\u5b9e\u65f6\uff0825Hz-\u672c\u5730\u8f93\u51fa+MQTT;200Hz-\u4ec5MQTT\uff09\uff1b\u5e38\u89c4 \uff08500Hz\uff09</li> <li>\u670d\u52a1\u7aef\u53ef\u89c6\u5316\u7a0b\u5e8f</li> <li>\u670d\u52a1\u7aef\u6570\u636e\u5b58\u50a8</li> </ul>"},{"location":"zh/MEASUREMENT/measurement/","title":"\u6d4b\u91cf","text":"<p>\u5173\u4e8e\u6d4b\u91cf</p> <p>\u9ad8\u8d28\u91cf\u6d4b\u91cf/\u91c7\u6837\u662f\u6570\u636e\u5206\u6790\u7684\u57fa\u7840\uff0cTinySHM\u5728\u8bbe\u8ba1\u65f6\u5145\u5206\u8003\u8651\u4e86\u8fd9\u4e00\u70b9\u3002\u6211\u4eec\u5728TinySHM\u4e2d\u5b9e\u73b0\u4e86\u591a\u79cd\u6d4b\u91cf/\u91c7\u6837\u65b9\u6cd5\uff0c\u7528\u6237\u53ef\u4ee5\u6839\u636e\u81ea\u5df1\u7684\u9700\u6c42\u8fdb\u884c\u9009\u62e9\u3002</p> <p>Warning</p> <p>\u76ee\u524d\u5f00\u53d1\u4ee5ESP32\u4e3a\u57fa\u7840\uff0c\u5411STM32\u7b49\u5e73\u53f0\u7684\u8fc1\u79fb\u9700\u8981\u5bf9\u9002\u914d\u5c42\u8fdb\u884c\u4e00\u5b9a\u7684\u4fee\u6539\u3002</p>"},{"location":"zh/MEASUREMENT/notes/","title":"\u8bf4\u660e","text":""},{"location":"zh/MEASUREMENT/notes/#_2","title":"\u4f9d\u8d56","text":"<p>SYSTEM</p> <pre><code>#include \"esp_system.h\" // ESP32 System\n#include \"esp_log.h\"    // ESP32 Logging\n</code></pre> <p>RTOS</p> <pre><code>#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/event_groups.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/timers.h\"\n#include \"freertos/semphr.h\"\n</code></pre> <p>BSP</p> <pre><code>#include \"driver/gptimer.h\"\n#include \"led.h\"\n#include \"lcd.h\"\n#include \"tim.h\"\n#include \"esp_rtc.h\"\n#include \"spi_sdcard.h\"\n#include \"wifi_wpa2_enterprise.h\"\n#include \"mqtt.h\"\n#include \"mpu6050.h\"\n</code></pre> <p>TinyAuton/TinySHM</p> <pre><code>#include \"TinyAdapter.h\"\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_3","title":"\u91c7\u6837\u914d\u7f6e\u7ed3\u6784\u4f53","text":"<p>\u5b9a\u4e49</p> <pre><code>struct SenseConfig\n{\n    int sample_rate;\n    int sample_duration;\n    bool temperature_sense; // whether to sense temperature\n    bool printout;          // not recommened for high sample rate as it will slow down the process\n    bool mqtt_pub;          // not recommened for high sample rate as it will slow down the process\n};\n</code></pre> <p>\u4f7f\u7528 - \u5b9e\u65f6</p> <pre><code>// for streamline configuration\nstruct SenseConfig streamline_config = {\n    .sample_rate = 1,          // Sample rate in Hz. For local printout + mqtt, at most 25Hz; for only mqtt, at most 200Hz.\n    .temperature_sense = true, // Whether to sense temperature\n    .printout = true,          // Only available for sampling rate &lt;= 100Hz\n    .mqtt_pub = true           // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre> <p>\u4f7f\u7528 - \u5e38\u89c4\u91c7\u6837</p> <pre><code>// for sensing configuration\nstruct SenseConfig sense_config = {\n    .sample_rate = 500,   // Sample rate in Hz, only can be (1, 2, 5, 10, 20, 25, 50, 100, 200, 500) for FreeRTOS based sensing. Note can not be 1000Hz (no time to feed the watchdog).\n    .sample_duration = 1, // Sample duration in seconds\n    .printout = true      // Only available for sampling rate &lt;= 100Hz\n};\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_4","title":"\u91c7\u6837\u6570\u636e\u7ed3\u6784\u4f53","text":"<pre><code>struct DataStruct\n{\n    int sample_rate;\n    int sample_duration;\n    float sensor_temperature;\n    TinyTimeMark_t start_time_stamp;\n    TinyTimeMark_t *time_stamp;\n    float *acc_data;\n    float *temperature;\n};\n</code></pre> <p>\u4f7f\u7528</p> <pre><code>// for data structure\nstruct DataStruct data_struct = {\n    .sample_rate = 0,     // Sample rate in Hz\n    .sample_duration = 0, // Sample duration in seconds\n    .sensor_temperature = 0.0,\n    .start_time_stamp = 0,\n    .acc_data = NULL}; \n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_5","title":"\u91c7\u6837\u539f\u7406","text":"<p>\u76ee\u524d\u91c7\u6837**\u57fa\u4e8eFreeRTOS\u5faa\u73af**\u800c\u975e\u57fa\u4e8e**\u5b9a\u65f6\u5668\u4e2d\u65ad**\uff0c\u5b9e\u73b0\u7b80\u5355\uff0c\u672a\u6765\u6216\u8bb8\u4f1a\u6dfb\u52a0\u5b9a\u65f6\u5668\u4e2d\u65ad\u91c7\u6837\u7684\u65b9\u5f0f\u3002</p>"},{"location":"zh/MEASUREMENT/notes/#_6","title":"\u91c7\u6837\u6a21\u5f0f\u4e0e\u91c7\u6837\u4efb\u52a1","text":"<p>\u76ee\u524d\u5171\u6709\u4e24\u79cd\u91c7\u6837\u6a21\u5f0f\uff1a - \u5b9e\u65f6\u91c7\u6837 - \u5e38\u89c4\u91c7\u6837</p>"},{"location":"zh/MEASUREMENT/notes/#_7","title":"\u5b9e\u65f6\u91c7\u6837","text":"<p>\u91c7\u6837\u4efb\u52a1\u5b9a\u4e49</p> <pre><code>/**\n * @name acc_streamline_task\n * @brief This function is the task for streaming the accelerometer data.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_streamline_task(void *pvParameters)\n{\n\n    // streamline variables\n    float acc_x, acc_y, acc_z, temperature;\n    TinyTimeMark_t time_stamp;\n\n    // MQTT publish buffer\n    char streamline_buff[256];\n\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n\n    if (config-&gt;sample_rate &gt; 100 &amp;&amp; config-&gt;printout)\n    {\n        ESP_LOGW(TAG, \"Printout is disabled for sample rate &gt; 100Hz.\");\n        config-&gt;printout = false;\n    }\n\n    while (1)\n    {\n        // get the time stamp\n        time_stamp = tiny_get_running_time();\n\n        // get accelerometer data\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        acc_x = acce.acce_x;\n        acc_y = acce.acce_y;\n        acc_z = acce.acce_z;\n\n        // get temperature\n        mpu6050_get_temp(mpu6050, &amp;temp);\n        temperature = temp.temp;\n\n        // sprintf\n        if (config-&gt;printout || config-&gt;mqtt_pub)\n        {\n            snprintf(streamline_buff, sizeof(streamline_buff), \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Sensor Temperature: %4.2f \u00b0C\", time_stamp, acc_x, acc_y, acc_z, temperature);\n        }\n\n        // print out the data - comment out for higher sample rate\n        if (config-&gt;printout)\n        {\n            ESP_LOGI(TAG, \"%s\", streamline_buff);\n        }\n\n        // MQTT publish\n        if (config-&gt;mqtt_pub)\n        {\n            esp_mqtt_client_publish(s_mqtt_client, MQTT_PUBLIC_TOPIC, streamline_buff, strlen(streamline_buff), 0, 0); // for streamline, data quality is not expected to be high, so QoS = 0; data retaintion is also not required, so 0.\n        }\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n    ESP_LOGI(TAG, \"Streamline terminated. Task will delete itself.\");\n    vTaskDelete(NULL);\n}\n</code></pre> <p>\u91c7\u6837\u4efb\u52a1\u4f7f\u7528: \u5728\u5e94\u7528\u7a0b\u5e8f\u90e8\u5206\u521b\u5efa\u4efb\u52a1\u5373\u53ef</p> <pre><code>xTaskCreate(acc_streamline_task, \"Accel_Streamline_Task\", 4096, &amp;streamline_config, 5, NULL);\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_8","title":"\u5e38\u89c4\u91c7\u6837","text":"<p>\u91c7\u6837\u4efb\u52a1\u5b9a\u4e49</p> <pre><code>/**\n * @name acc_sense_task\n * @brief This function is the task for sensing the accelerometer data according to the configuration structure.\n * @param pvParameters for FreeRTOS, the passed parameters are all void pointers and need to be casted to the correct type.\n * @retval None\n */\nvoid acc_sense_task(void *pvParameters)\n{\n    struct SenseConfig *config = (struct SenseConfig *)pvParameters;\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1000 / config-&gt;sample_rate);\n    int total_samples = config-&gt;sample_rate * config-&gt;sample_duration;\n\n    // Fill global data_struct\n    data_struct.sample_rate = config-&gt;sample_rate;\n    data_struct.sample_duration = config-&gt;sample_duration;\n    mpu6050_get_temp(mpu6050, &amp;temp);\n    data_struct.sensor_temperature = temp.temp;\n    data_struct.start_time_stamp = tiny_get_running_time();\n\n    // Allocate memory\n    data_struct.acc_data = malloc(sizeof(float) * 3 * total_samples);\n    data_struct.temperature = malloc(sizeof(float) * total_samples);\n    data_struct.time_stamp = malloc(sizeof(TinyTimeMark_t) * total_samples);\n\n    if (data_struct.acc_data == NULL || data_struct.temperature == NULL || data_struct.time_stamp == NULL)\n    {\n        ESP_LOGE(TAG, \"Failed to allocate memory for sensing data.\");\n        if (data_struct.acc_data)\n            free(data_struct.acc_data);\n        if (data_struct.temperature)\n            free(data_struct.temperature);\n        if (data_struct.time_stamp)\n            free(data_struct.time_stamp);\n        vTaskDelete(NULL);\n    }\n\n    ESP_LOGI(TAG, \"Sampling started: %d Hz for %d seconds (%d samples)\",\n             config-&gt;sample_rate, config-&gt;sample_duration, total_samples);\n\n    for (int i = 0; i &lt; total_samples; i++)\n    {\n        TinyTimeMark_t now = tiny_get_running_time();\n        mpu6050_get_acce(mpu6050, &amp;acce);\n        mpu6050_get_temp(mpu6050, &amp;temp);\n\n        // Store data\n        data_struct.time_stamp[i] = now;\n        data_struct.acc_data[i * 3 + 0] = acce.acce_x;\n        data_struct.acc_data[i * 3 + 1] = acce.acce_y;\n        data_struct.acc_data[i * 3 + 2] = acce.acce_z;\n        data_struct.temperature[i] = temp.temp;\n\n        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);\n    }\n\n    ESP_LOGI(TAG, \"Sampling complete.\");\n\n    // Print metadata\n    ESP_LOGI(TAG, \"-----------------------------\");\n    ESP_LOGI(TAG, \"Sensor Temperature : %.2f \u00b0C\", data_struct.sensor_temperature);\n    ESP_LOGI(TAG, \"Start Time Stamp   : %ld\", (long)data_struct.start_time_stamp);\n    ESP_LOGI(TAG, \"Sample Rate        : %d Hz\", data_struct.sample_rate);\n    ESP_LOGI(TAG, \"Sample Duration    : %d sec\", data_struct.sample_duration);\n    ESP_LOGI(TAG, \"Total Samples      : %d\", total_samples);\n    ESP_LOGI(TAG, \"Data Size          : %.2f KB\",\n             (sizeof(float) * 4 + sizeof(TinyTimeMark_t)) * total_samples / 1024.0f);\n    ESP_LOGI(TAG, \"-----------------------------\");\n\n    // Print collected data if enabled\n    if (config-&gt;printout)\n    {\n        for (int i = 0; i &lt; total_samples; i++)\n        {\n            ESP_LOGI(TAG, \"Time Stamp: %10ld, acc_x = %10.6f, acc_y = %10.6f, acc_z = %10.6f, Temperature: %.2f \u00b0C\",\n                     (long)data_struct.time_stamp[i],\n                     data_struct.acc_data[i * 3 + 0],\n                     data_struct.acc_data[i * 3 + 1],\n                     data_struct.acc_data[i * 3 + 2],\n                     data_struct.temperature[i]);\n\n            // Release CPU for a short time to avoid blocking\n            if ((i % 10) == 0)\n            {\n                vTaskDelay(pdMS_TO_TICKS(10));\n            }\n        }\n    }\n\n    // Free allocated memory\n    if (data_struct.acc_data)\n    {\n        free(data_struct.acc_data);\n        data_struct.acc_data = NULL;\n    }\n    if (data_struct.temperature)\n    {\n        free(data_struct.temperature);\n        data_struct.temperature = NULL;\n    }\n    if (data_struct.time_stamp)\n    {\n        free(data_struct.time_stamp);\n        data_struct.time_stamp = NULL;\n    }\n\n    vTaskDelete(NULL);\n}\n</code></pre> <p>\u91c7\u6837\u4efb\u52a1\u4f7f\u7528: \u5728\u5e94\u7528\u7a0b\u5e8f\u90e8\u5206\u521b\u5efa\u4efb\u52a1\u5373\u53ef</p> <pre><code>xTaskCreate(acc_sense_task, \"Accel_Sense_Task\", 8192, &amp;sense_config, 5, NULL);\n</code></pre>"},{"location":"zh/MEASUREMENT/notes/#_9","title":"\u5f85\u5f00\u53d1","text":"<ul> <li>\u6807\u51c6\u65f6\u95f4\u6233</li> <li>\u6821\u51c6</li> <li>\u5b9a\u65f6\u5668+\u4e2d\u65ad</li> <li>DMA</li> <li>ADC+\u6a21\u62df</li> <li>\u6570\u636e\u540e\u5904\u7406</li> <li>\u6279\u91cf\u6570\u636eMQTT\u4e0a\u4f20</li> <li>\u5b9e\u65f6\u5904\u7406\u529f\u80fd\u5f00\u53d1</li> </ul>"},{"location":"zh/RELEASES/releases/","title":"\u53d1\u5e03","text":""},{"location":"zh/RELEASES/releases/#dnesp32s3m-stable","title":"DNESP32S3M-STABLE","text":"<p>\u7a33\u5b9a\u7248</p>"},{"location":"zh/RELEASES/releases/#dnesp32s3m-latest","title":"DNESP32S3M-LATEST","text":"<p>\u6700\u65b0\u529f\u80fd\u7248</p>"},{"location":"zh/TOOLBOX/code/","title":"\u4ee3\u7801","text":"<p>\u6ce8\u610f</p> <p>\u4ee5\u4e0b\u4ee3\u7801\u5e94\u4ee5\u53d1\u5e03\u4ee3\u7801\u4e2d\u7684\u4ee3\u7801\u4e3a\u51c6\uff0c\u53ef\u80fd\u4f1a\u6709\u66f4\u65b0\u3002</p>"},{"location":"zh/TOOLBOX/log/","title":"\u5f00\u53d1\u65e5\u5fd7","text":"<p>2025-04-08</p> <ul> <li>\u8fd0\u884c\u65f6\u95f4\u67e5\u8be2\u51fd\u6570 tiny_get_running_time() </li> </ul>"},{"location":"zh/TOOLBOX/notes/","title":"\u8bf4\u660e","text":""},{"location":"zh/TOOLBOX/notes/#_2","title":"\u4f9d\u8d56","text":"<p>FreeRTOS</p> <pre><code>#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n</code></pre> <p>log</p> <pre><code>#include \"esp_log.h\"\n</code></pre> <p>timer</p> <pre><code>#include \"esp_timer.h\"\n</code></pre>"},{"location":"zh/TOOLBOX/notes/#_3","title":"\u8fd0\u884c\u65f6\u95f4\u67e5\u8be2","text":"<p>\u9996\u5148\u57fa\u4e8eESP32\u5e73\u53f0\u7684\u6570\u636e\u7c7b\u578b\u5b9a\u4e49\u4e86\u65b0\u7684\u6570\u636e\u7c7b\u578b</p> <pre><code>typedef TickType_t TinyTimeMark_t;\n</code></pre> <p>\u7136\u540e\u5728\u9002\u914d\u5c42\u4e2d\u5b9a\u4e49\u4e86\u4e00\u4e2a\u51fd\u6570\u7528\u4e8e\u83b7\u53d6\u5f53\u524d\u7684\u7cfb\u7edf\u81ea\u542f\u52a8\u540e\u7684\u8fd0\u884c\u65f6\u95f4\u6233\uff0c\u5355\u4f4d\u4e3a\u5fae\u79d2</p> <pre><code>TinyTimeMark_t tiny_get_running_time(void)\n{\n    return esp_timer_get_time();\n}\n</code></pre>"},{"location":"zh/TOOLBOX/toolbox/","title":"\u5de5\u5177\u7bb1","text":"<p>TinyToolbox</p> <p>\u5de5\u5177\u7bb1TinyToolbox\u5b9a\u4f4d\u662f\u7528\u4e8e \u5e73\u53f0\u9002\u914d\u4e0e\u4f18\u5316 \u5e76\u63d0\u4f9b \u5404\u79cd\u5b9e\u7528\u5de5\u5177 \u7684\u5e93\uff0c\u670d\u52a1\u4e8e\u8fb9\u7f18\u8ba1\u7b97\u4e0e\u5e94\u7528\u5f00\u53d1\u3002\u6ce8\u610f\uff0c\u4e4b\u6240\u4ee5\u5c06\u9002\u914d\u548c\u5de5\u5177\u653e\u5728\u4e00\u4e2a\u5e93\u91cc\u9762\uff0c\u662f\u56e0\u4e3a\u5f88\u591a\u5de5\u5177\u5e95\u5c42\u5229\u7528\u7684\u662f\u5e73\u53f0\u63d0\u4f9b\u7684\u529f\u80fd\uff0c\u6240\u4ee5\u5c06\u5e73\u53f0\u9002\u914d\u548c\u5404\u7c7b\u5de5\u5177\u653e\u5728\u540c\u4e00\u4e2a\u5e93\u91cc\u9762\uff0c\u4fbf\u4e8e\u4f7f\u7528\u548c\u7ef4\u62a4\u3002</p> <p>Warning</p> <p>\u76ee\u524d\u5f00\u53d1\u4ee5ESP32\u4e3a\u57fa\u7840\uff0c\u5411STM32\u7b49\u5e73\u53f0\u7684\u8fc1\u79fb\u9700\u8981\u5bf9\u9002\u914d\u5c42\u8fdb\u884c\u4e00\u5b9a\u7684\u4fee\u6539\u3002</p>"},{"location":"zh/TOOLBOX/toolbox/#_2","title":"\u529f\u80fd\u76ee\u5f55","text":""},{"location":"zh/TOOLBOX/toolbox/#_3","title":"\u65f6\u95f4","text":"<ul> <li>\u83b7\u53d6\u8fd0\u884c\u65f6\u95f4\uff1a <code>tiny_get_running_time()</code></li> <li>SNTP\u5bf9\u65f6\uff1a <code>sync_time_with_timezone(\"CST-8\")</code></li> <li>\u83b7\u53d6\u4e16\u754c\u65f6\u95f4\uff1a <code>tiny_get_current_time(1)</code></li> </ul> <p>\u5f85\u5f00\u53d1:</p> <ul> <li>\u65e0\u7ebf\u4f20\u611f\u5668\u7f51\u7edc\u672c\u5730\u5bf9\u65f6-\u5fae\u79d2\u7ea7\u522b</li> </ul>"},{"location":"zh/TOOLBOX/TIME/time/","title":"\u65f6\u95f4","text":"<p>\u65f6\u95f4</p> <p>\u65f6\u95f4\u76f8\u5173\u7684\u529f\u80fd\u5bf9\u4e8eMCU\u6765\u8bf4\u975e\u5e38\u91cd\u8981\uff0c\u672c\u8282\u63d0\u4f9b\u4e00\u7cfb\u5217\u65f6\u95f4\u76f8\u5173\u7684\u5b9a\u4e49\u548c\u51fd\u6570\uff0c\u4f9b\u5f00\u53d1\u8005\u4f7f\u7528\u3002</p> <p>MCU\u4e2d\u7684\u65f6\u95f4\u53ef\u4ee5\u5206\u4ee5\u4e0b\u51e0\u79cd\u7c7b\u578b\uff1a</p> <ul> <li> <p>\u8fd0\u884c\u65f6\u95f4\uff1a \u6307\u7684\u662fMCU\u4ece\u4e0a\u7535\u5230\u73b0\u5728\u7684\u65f6\u95f4\u3002</p> </li> <li> <p>\u4e16\u754c\u65f6\u95f4\uff1a \u6307\u7684\u662fMCU\u6240\u5728\u7684\u65f6\u533a\u7684\u65f6\u95f4\u3002\u4e16\u754c\u65f6\u95f4\u53ef\u4ee5\u901a\u8fc7\u6807\u51c6\u7684\u5e74\u6708\u65e5\u65f6\u5206\u79d2\u6765\u8868\u793a\uff0c\u4e5f\u53ef\u4ee5\u8868\u793a\u4e3aUNIX\u65f6\u95f4\u6233\u3002</p> </li> </ul>"},{"location":"zh/TOOLBOX/TIME/time/#_2","title":"\u8fd0\u884c\u65f6\u95f4","text":"<p>ESP\u6709\u81ea\u5df1\u7684\u83b7\u53d6\u8fd0\u884c\u65f6\u95f4\u7684\u51fd\u6570<code>esp_timer_get_time</code>\uff0c\u4f9d\u8d56\u4e8e<code>esp_timer</code>\u5e93\u3002\u8be5\u51fd\u6570\u8fd4\u56de\u4ece\u4e0a\u7535\u5230\u73b0\u5728\u7684\u65f6\u95f4\uff0c\u5355\u4f4d\u4e3a\u5fae\u79d2\u3002</p> <p>\u4e3a\u4e86\u65b9\u4fbf\u4f7f\u7528\uff0cTinyToolbox\u91cd\u65b0\u5b9a\u4e49\u4e86\u6570\u636e\u7c7b\u578b<code>TinyTimeMark_t</code>\uff0c\u5e76\u63d0\u4f9b\u4e86\u4e00\u4e2a\u51fd\u6570<code>tiny_get_running_time</code>\u6765\u83b7\u53d6\u8fd0\u884c\u65f6\u95f4\u3002\u8be5\u51fd\u6570\u8fd4\u56de\u7684\u65f6\u95f4\u5355\u4f4d\u4e3aTickType_t\uff0cTickType_t\u662fFreeRTOS\u4e2d\u5b9a\u4e49\u7684\u65f6\u95f4\u5355\u4f4d\u3002</p> <pre><code>typedef TickType_t TinyTimeMark_t;\n</code></pre> <pre><code>/**\n * @brief Get the running time in microseconds\n * @return TinyTimeMark_t\n */\nTinyTimeMark_t tiny_get_running_time(void)\n{\n    return esp_timer_get_time();\n}\n</code></pre> <p>\u4f7f\u7528\u53c2\u8003\uff1a</p> <pre><code>void app_main(void)\n{\n    // Get running time\n    TinyTimeMark_t running_time = tiny_get_running_time();\n    ESP_LOGI(TAG_TIME, \"Running Time: %lld us\", running_time);\n}\n</code></pre>"},{"location":"zh/TOOLBOX/TIME/time/#_3","title":"\u4e16\u754c\u65f6\u95f4","text":"<p>Warning</p> <p>\u6ce8\u610f\uff0c\u83b7\u53d6\u4e16\u754c\u65f6\u95f4\u9700\u8981\u5efa\u7acb\u5728\u5df2\u7ecf\u8054\u7f51\u7684\u57fa\u7840\u4e0a\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u83b7\u53d6\u4e16\u754c\u65f6\u95f4\u7684\u51fd\u6570\u9700\u8981\u5728\u8054\u7f51\u6210\u529f\u540e\u8c03\u7528\u3002</p>"},{"location":"zh/TOOLBOX/TIME/time/#ntp","title":"NTP\u5bf9\u65f6","text":"<p>NTP\u5bf9\u65f6</p> <p>NTP\uff08Network Time Protocol\uff09\u662f\u7f51\u7edc\u65f6\u95f4\u534f\u8bae\u7684\u7f29\u5199\uff0c\u662f\u4e00\u79cd\u7528\u4e8e\u5728\u8ba1\u7b97\u673a\u7f51\u7edc\u4e2d\u540c\u6b65\u65f6\u95f4\u7684\u534f\u8bae\u3002\u5b83\u53ef\u4ee5\u901a\u8fc7\u4e92\u8054\u7f51\u6216\u5c40\u57df\u7f51\u83b7\u53d6\u51c6\u786e\u7684\u65f6\u95f4\u4fe1\u606f\u3002 NTP\u534f\u8bae\u4f7f\u7528UDP\u534f\u8bae\u8fdb\u884c\u901a\u4fe1\uff0c\u9ed8\u8ba4\u4f7f\u7528123\u7aef\u53e3\u3002NTP\u670d\u52a1\u5668\u4f1a\u5b9a\u671f\u5411\u5ba2\u6237\u7aef\u53d1\u9001\u65f6\u95f4\u4fe1\u606f\uff0c\u5ba2\u6237\u7aef\u6839\u636e\u8fd9\u4e9b\u4fe1\u606f\u6765\u6821\u6b63\u81ea\u5df1\u7684\u7cfb\u7edf\u65f6\u95f4\u3002</p> <pre><code>   Client                      Server\n     |-------------------&gt;      |     T1\uff1a\u8bf7\u6c42\u53d1\u51fa\n     |                         |\n     |        &lt;--------------- |     T2/T3\uff1a\u670d\u52a1\u5668\u6536\u5230 &amp; \u56de\u590d\n     |                         |\n     |-------------------&gt;      |     T4\uff1a\u5ba2\u6237\u7aef\u6536\u5230\u54cd\u5e94\n</code></pre> <p>NTP\u5bf9\u65f6\u539f\u7406</p> <p>NTP\u5bf9\u65f6\u662f\u57fa\u4e8e\u56db\u4e2a\u65f6\u95f4\u6233\uff1a1. \u5ba2\u6237\u7aef\u53d1\u9001\u8bf7\u6c42\u65f6\u7684\u65f6\u95f4\u6233T1 2. \u670d\u52a1\u5668\u63a5\u6536\u5230\u8bf7\u6c42\u65f6\u7684\u65f6\u95f4\u6233T2 3. \u670d\u52a1\u5668\u53d1\u9001\u54cd\u5e94\u65f6\u7684\u65f6\u95f4\u6233T3 4. \u5ba2\u6237\u7aef\u63a5\u6536\u5230\u54cd\u5e94\u65f6\u7684\u65f6\u95f4\u6233T4\u3002\u6839\u636e\u8fd9\u56db\u4e2a\u65f6\u95f4\u6233\uff0c\u53ef\u4ee5\u8ba1\u7b97 \u7f51\u7edc\u5ef6\u8fdf Delay = (T4 - T1) - (T3 - T2)\uff0c\u4ee5\u53ca \u65f6\u95f4\u504f\u79fb Offset = ((T2 - T1) + (T3 - T4)) / 2\u3002</p> <p>ESP32 SNTP\u5bf9\u65f6</p> <p>ESP32\u4e2d\u4f7f\u7528\u7684\u662fSNTP\uff0c\u4e5f\u5c31\u662fSimple Network Time Protocol\u3002SNTP\u662fNTP\u7684\u7b80\u5316\u7248\uff0c\u9002\u7528\u4e8e\u5bf9\u65f6\u95f4\u7cbe\u5ea6\u8981\u6c42\u4e0d\u9ad8\u7684\u573a\u666f\u3002ESP32\u4e2d\u5bf9\u65f6\u4f9d\u8d56\u4e8e<code>esp_sntp</code>\u5e93\u3002SNTP\u7684\u5de5\u4f5c\u539f\u7406\u4e0eNTP\u7c7b\u4f3c\uff0c\u4f46SNTP\u7684\u5b9e\u73b0\u76f8\u5bf9\u7b80\u5355\uff0c\u9002\u5408\u5d4c\u5165\u5f0f\u8bbe\u5907\u4f7f\u7528\u3002\u5176\u7cbe\u5ea6\u901a\u5e38\u5728ms\u7ea7\u522b\uff0c\u9002\u7528\u4e8e\u5927\u591a\u6570\u5e94\u7528\u573a\u666f\u3002</p> <p>\u9996\u5148\u5b9a\u4e49\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff0c\u7528\u4e8e\u63a5\u6536\u5bf9\u65f6\u901a\u77e5\uff1a</p> <p><pre><code>/* WORLD CURRENT TIME - SNTP */\n/**\n * @brief Callback function for time synchronization notification\n * @param tv Pointer to the timeval structure containing the synchronized time\n * @return None\n */\nvoid time_sync_notification_cb(struct timeval *tv)\n{\n    ESP_LOGI(TAG_SNTP, \"Time synchronized!\");\n}\n</code></pre> \u63a5\u4e0b\u6765\u662fSNTP\u7684\u521d\u59cb\u5316\u51fd\u6570\uff0c\u4e5f\u662f\u5bf9\u65f6\u7684\u6838\u5fc3\u51fd\u6570\uff0c\u901a\u5e38\u5728\u7cfb\u7edf\u521d\u59cb\u5316\u65f6\uff0c\u5b8c\u6210\u8054\u7f51\u540e\u8c03\u7528\u3002\u6ce8\u610f\u5176\u4e2d\u7684\u5bf9\u65f6\u670d\u52a1\u5668\u5730\u5740\u53ef\u4ee5\u6839\u636e\u9700\u8981\u8fdb\u884c\u4fee\u6539\u3002\u5bf9\u65f6\u5b8c\u6210\u540e\uff0cESP32\u4f1a\u5728\u5e95\u5c42\u5bf9\u672c\u673a\u65f6\u95f4\u8fdb\u884c\u8bbe\u7f6e\u3002</p> <pre><code>/**\n * @brief Initialize SNTP\n * @return None\n */\nvoid initialize_sntp(void)\n{\n    ESP_LOGI(TAG_SNTP, \"Initializing SNTP\");\n    sntp_setoperatingmode(SNTP_OPMODE_POLL);\n    sntp_setservername(0, \"pool.ntp.org\"); // NTP server // pool.ntp.org // ntp.aliyun.com\n    sntp_set_time_sync_notification_cb(time_sync_notification_cb);\n    sntp_init();\n}\n</code></pre> <p>\u518d\u63a5\u4e0b\u6765\u662f\u5bf9\u4ee5\u4e0a\u51fd\u6570\u7684\u8fdb\u4e00\u6b65\u5c01\u88c5\uff0c\u5305\u542b\u4e86\u65f6\u533a\u8bbe\u7f6e\u3002\u6ce8\u610f\u4ee5\u4e0b\u51fd\u6570\u4e2d\u5305\u62ec\u4e86\u5bf9RTC\u7684\u8bbe\u7f6e<code>rtc_set_time</code>\uff0c\u4f9d\u8d56\u4e8edriver\u5c42\u7684RTC\u9a71\u52a8\u3002\u6b64\u5904\u4f7f\u7528\u7684\u662f\u6211\u81ea\u5b9a\u4e49\u7684rtc\u9a71\u52a8\uff0c\u82e5\u6ca1\u6709\u76f8\u5173\u529f\u80fd\u53ef\u4ee5\u76f4\u63a5\u6ce8\u91ca\u6389\u3002</p> <pre><code>/**\n * @brief Obtain the current time with timezone\n * @param timezone_str Timezone string (e.g., \"CST-8\")\n * @note The timezone string should be in the format \"TZ=GMT+/-HH:MM\"\n * @note To use this function, in application, after internet connection, insert \"sync_time_with_timezone(\"CST-8\");\" will do\n * @return None\n */\nvoid sync_time_with_timezone(const char *timezone_str)\n{\n    // Set system timezone\n    setenv(\"TZ\", timezone_str, 1);\n    tzset();\n\n    // Initialize SNTP and start time sync\n    initialize_sntp();\n\n    // Wait for system time to be set\n    time_t now = 0;\n    struct tm timeinfo = { 0 };\n    int retry = 0;\n    const int retry_count = 15;\n\n    while (timeinfo.tm_year &lt; (2020 - 1900) &amp;&amp; ++retry &lt; retry_count) {\n        ESP_LOGI(TAG_SNTP, \"Waiting for system time to be set... (%d/%d)\", retry, retry_count);\n        vTaskDelay(2000 / portTICK_PERIOD_MS);\n        time(&amp;now);\n        localtime_r(&amp;now, &amp;timeinfo);\n    }\n\n    if (timeinfo.tm_year &gt;= (2020 - 1900)) {\n        rtc_set_time(timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday,\n                    timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec); // defined in esp_rtc.c\n        ESP_LOGI(TAG_SNTP, \"System time is set.\");\n    } else {\n        ESP_LOGW(TAG_SNTP, \"Failed to sync time.\");\n        return;\n    }\n\n    // Log current local time\n    ESP_LOGI(TAG_SNTP, \"Current time: %s\", asctime(&amp;timeinfo));\n\n    // vTaskDelay(10000 / portTICK_PERIOD_MS); // Wait for 10 second\n    // rtc_get_time(); // uncomment to check the RTC time\n    // ESP_LOGI(TAG_SNTP, \"Current RTC time: %04d-%02d-%02d %02d:%02d:%02d\",\n    //          calendar.year, calendar.month, calendar.date,\n    //          calendar.hour, calendar.min, calendar.sec); // uncomment to check the RTC time\n\n}\n</code></pre>"},{"location":"zh/TOOLBOX/TIME/time/#_4","title":"\u4e16\u754c\u65f6\u95f4\u83b7\u53d6","text":"<p>\u4e3a\u4e86\u65b9\u4fbf\u4e16\u754c\u65f6\u95f4\u7684\u83b7\u53d6\uff0c\u6211\u4eec\u9996\u5148\u5b9a\u4e49\u4e86\u4e00\u4e2a\u6570\u636e\u7ed3\u6784<code>DateTime_t</code>\uff0c\u7528\u4e8e\u5b58\u50a8\u5e74\u6708\u65e5\u65f6\u5206\u79d2\u7b49\u4fe1\u606f\u3002\u7136\u540e\u5b9a\u4e49\u4e86\u4e00\u4e2a\u51fd\u6570<code>tiny_get_current_time</code>\uff0c\u7528\u4e8e\u83b7\u53d6\u5f53\u524d\u7684\u4e16\u754c\u65f6\u95f4\u3002\u8be5\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a<code>DateTime_t</code>\u7ed3\u6784\u4f53\uff0c\u5305\u542b\u4e86\u5f53\u524d\u7684\u5e74\u6708\u65e5\u65f6\u5206\u79d2\u7b49\u4fe1\u606f\u3002\u5728\u4f7f\u7528\u65f6\uff0c\u4f20\u5165\u4e00\u4e2a\u5e03\u5c14\u503c<code>print_flag</code>\uff0c\u7528\u4e8e\u63a7\u5236\u662f\u5426\u6253\u5370\u5f53\u524d\u65f6\u95f4\u3002</p> <pre><code>/**\n * @brief Structure to hold date and time\n */\ntypedef struct TinyDateTime_t\n{\n    int year;\n    int month;\n    int day;\n    int hour;\n    int minute;\n    int second;\n    long microsecond;\n} TinyDateTime_t; \n</code></pre> <p><pre><code>/* WORLD CURRENT TIME - GET TIME */\n/**\n * @name tiny_get_current_time\n * @brief Get the current time as a TinyDateTime_t struct\n * @param print_flag Flag to indicate whether to print the time\n * @return TinyDateTime_t structure containing the current date and time\n */\nTinyDateTime_t tiny_get_current_time(bool print_flag)\n{\n    struct timeval tv;\n    gettimeofday(&amp;tv, NULL);  // Get current time (seconds + microseconds)\n\n    time_t now = tv.tv_sec;\n    struct tm timeinfo;\n    localtime_r(&amp;now, &amp;timeinfo);  // Convert to local time\n\n    TinyDateTime_t result;\n    result.year   = timeinfo.tm_year + 1900;\n    result.month  = timeinfo.tm_mon + 1;\n    result.day    = timeinfo.tm_mday;\n    result.hour   = timeinfo.tm_hour;\n    result.minute = timeinfo.tm_min;\n    result.second = timeinfo.tm_sec;\n    result.microsecond = tv.tv_usec;\n\n    if (print_flag)\n    {\n        ESP_LOGI(TAG_TIME, \"Current Time: %04d-%02d-%02d %02d:%02d:%02d.%06ld\",\n                 result.year, result.month, result.day,\n                 result.hour, result.minute, result.second, tv.tv_usec);\n    }\n\n    return result;\n}\n</code></pre> \u4f7f\u7528\u53c2\u8003\uff1a</p> <pre><code>void app_main(void)\n{\n    // Initialize SNTP and sync time\n    sync_time_with_timezone(\"CST-8\");\n\n    // Get current time\n    TinyDateTime_t current_time = tiny_get_current_time(true);\n\n    // Print current time\n    ESP_LOGI(TAG_TIME, \"Current Time: %04d-%02d-%02d %02d:%02d:%02d.%06ld\",\n             current_time.year, current_time.month, current_time.day,\n             current_time.hour, current_time.minute, current_time.second, current_time.microsecond);\n}\n</code></pre>"}]}